---
title: DICOMautomaton Reference Manual
---

# Overview

## About

DICOMautomaton is a collection of software tools for processing and analyzing medical images. Once a workflow has been
developed, the aim of DICOMautomaton is to require minimal interaction to perform the workflow in an automated way.
However, some interactive tools are also included for workflow development, exploratory analysis, and contouring.

DICOMautomaton is meant to be flexible enough to adapt to a wide variety of situations and has been incorporated into
projects to provide: a local PACs, image analysis for various types of QA, kinetic modeling of perfusion images,
automated fuzzy mapping of ROI names to a standard lexicon, dosimetric analysis, TCP and NTCP modeling, ROI
contour/volume manipulation, estimation of surface dose, ray casting through patient and phantom geometry, rudimentary
linac beam optimization, radiomics, and has been used in various ways to explore the relationship between toxicity and
dose in sub-organ compartments.

Note: DICOMautomaton should **NOT** be used for clinical purposes. It is experimental software. It is suitable for
research or support tool purposes only. It comes with no warranty or guarantee of any kind, either explicit or implied.
Users of DICOMautomaton do so fully at their own risk.

## Project Home

This project's homepage can be found at <https://www.halclark.ca/>. The source code is available at either
<https://gitlab.com/hdeanclark/DICOMautomaton/> or <https://github.com/hdclark/DICOMautomaton/>.

## Download

DICOMautomaton relies only on open source software and is itself open source software. Source code is available at
<https://github.com/hdclark/DICOMautomaton>.

Currently, binaries are not provided. Only linux is supported and a recent C++ compiler is needed. A ```PKGBUILD``` file
is provided for Arch Linux and derivatives, and CMake can be used to generate deb files for Debian derivatives. A docker
container is available for easy portability to other systems. DICOMautomaton has successfully run on x86, x86_64, and
most ARM systems. To maintain flexibility, DICOMautomaton is generally not ABI or API stable.

## License and Copying

All materials herein which may be copywrited, where applicable, are. Copyright 2010, 2011, 2012, 2013, 2014, 2015, 2016,
2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025 hal clark. See the ```LICENSE``` file for details about the
license. Informally, DICOMautomaton is available under a GPLv3+ license. The Imebra library is bundled for convenience
and was not written by hal clark; consult its license file in ```src/imebra20121219/license.txt```. The ImGui toolkit is
bundled for convenience and was not written by hal clark; consult its license file in
```src/imgui20210904/license.txt```.

All liability is herefore disclaimed. The person(s) who use this source and/or software do so strictly under their own
volition. They assume all associated liability for use and misuse, including but not limited to damages, harm, injury,
and death which may result, including but not limited to that arising from unforeseen and unanticipated implementation
defects.

## Dependencies

Dependencies are listed in the ```PKGBUILD``` file (using Arch Linux package naming conventions) and in the
```CMakeLists.txt``` file (Debian package naming conventions) bundled with the source code. See
<https://github.com/hdclark/DICOMautomaton>. Broadly, DICOMautomaton depends on Boost, CGAL, SFML, SDL2, glew, Eigen,
Asio, Wt, NLopt, and PostgreSQL. Disabling some functionality at compile time can eliminate some dependencies. This
instance has been compiled with the following functionality.


  Dependency       Functionality Enabled?
  ---------------  ---------------------------------------
  Ygor             true (required)
  YgorClustering   true (required; header-only)
  Explicator       true (required)
  Imebra           true (required; bundled)
  Boost            true (required)
  asio             true (required)
  zlib             true (required)
  MPFR             true (required)
  GNU GMP          true (required)
  Eigen            true
  CGAL             true
  NLOpt            true
  SFML             true
  SDL2             true
  glew             true
  Wt               true
  GNU GSL          true
  pqxx             true
  Jansson          true

  Table: Dependencies enabled for this instance.

Notably, DICOMautomaton depends on the author's 'Ygor,' 'Explicator,' and 'YgorClustering' projects. See
<https://gitlab.com/hdeanclark/Ygor> (mirrored at <https://github.com/hdclark/Ygor>),
<https://gitlab.com/hdeanclark/Explicator> (mirrored at <https://github.com/hdclark/Explicator>), and (only for
compilation) <https://gitlab.com/hdeanclark/YgorClustering> (mirrored at <https://github.com/hdclark/YgorClustering>).

## Feedback

All feedback, questions, comments, and pull requests are welcomed.

## FAQs

**Q.** What is the best way to use DICOMautomaton?  
**A.** DICOMautomaton provides a command-line interface, SFML-based image viewer, and limited web interface. The
command-line interface is most conducive to automation, the viewer works best for interactive tasks, and the web
interface works well for specific installations.

**Q.** How do I contribute, report bugs, or contact the author?  
**A.** All feedback, questions, comments, and pull requests are welcomed. Please find contact information at
<https://github.com/hdclark/DICOMautomaton>.

## Citing

DICOMautomaton can be cited as a whole using [doi:10.5281/zenodo.4088796](https://doi.org/10.5281/zenodo.4088796).
Individual releases are assigned a DOI too; the latest release DOI can be found
[here](https://zenodo.org/badge/latestdoi/89630691).

Several publications and presentations refer to DICOMautomaton or describe some aspect of it. Here are a few:

- H. Clark, J. Beaudry, J. Wu, and S. Thomas. Making use of virtual dimensions for visualization and contouring. Poster
  presentation at the International Conference on the use of Computers in Radiation Therapy, London, UK. June 27-30,
  2016.

- H. Clark, S. Thomas, V. Moiseenko, R. Lee, B. Gill, C. Duzenli, and J. Wu. Automated segmentation and dose-volume
  analysis with DICOMautomaton. In the Journal of Physics: Conference Series, vol. 489, no. 1, p. 012009. IOP
  Publishing, 2014.

- H. Clark, J. Wu, V. Moiseenko, R. Lee, B. Gill, C. Duzenli, and S. Thomas. Semi-automated contour recognition using
  DICOMautomaton. In the Journal of Physics: Conference Series, vol. 489, no. 1, p. 012088. IOP Publishing, 2014.

- H. Clark, J. Wu, V. Moiseenko, and S. Thomas. Distributed, asynchronous, reactive dosimetric and outcomes analysis
  using DICOMautomaton. Poster presentation at the COMP Annual Scientific Meeting, Banff, Canada. July 9-12, 2014.

If you use DICOMautomaton in an academic work, we ask that you please cite the most relevant publication for that work
or the most relevant release DOI, if possible.

## Components

### dicomautomaton_dispatcher

#### Description

The core command-line interface to DICOMautomaton is the `dicomautomaton_dispatcher` program. It is presents an
interface based on chaining of discrete operations on collections of images, DICOM images, DICOM radiotherapy files
(RTSTRUCTs, RTPLANs, and RTDOSE), and various other types of files. `dicomautomaton_dispatcher` has access to all
defined operations described in [Operations](#operations). It can be used to launch both interactive and non-interactive
tasks. Data can be sourced from a database or files in a variety of formats.

Name/label selectors in dicomautomaton_dispatcher generally support fuzzy matching via
[libexplicator](https://gitlab.com/hdeanclark/Explicator) or regular expressions. The operations and parameters that
provide these options are documented in [Operations](#operations).

#### Usage Examples

- ```dicomautomaton_dispatcher --help```  
  *Print a listing of all available options.*

- ```dicomautomaton_dispatcher CT*dcm```  
  *Launch the default interactive viewer to inspect a collection of computed tomography images.*

- ```dicomautomaton_dispatcher MR*dcm```  
  *Launch the default interactive viewer to inspect a collection of magnetic resonance images.*

- ```dicomautomaton_dispatcher -o SFML_Viewer MR*dcm```  
  *Launch the default interactive viewer to inspect a collection of magnetic resonance images. Note that files specified
  on the command line are always loaded **prior** to running any operations. Injecting files midway through the
  operation chain must make use of an operation designed to do so.*

- ```dicomautomaton_dispatcher CT*dcm RTSTRUCT*dcm RTDOSE*dcm -o Average -o SFML_Viewer```  
  *Load DICOM files, perform an [averaging](#average) operation, and then launch the SFML viewer to inspect the output.*

- ```dicomautomaton_dispatcher ./RTIMAGE.dcm -o AnalyzePicketFence:ImageSelection='last':InteractivePlots='false'```  
  *Perform a [picket fence analysis](#analyzepicketfence) of an RTIMAGE file.*

- ```dicomautomaton_dispatcher -f create_temp_view.sql -f select_records_from_temp_view.sql -o ComputeSomething```  
  *Load a SQL common file that creates a SQL view, issue a query involving the view which returns some DICOM file(s).
  Perform analysis 'ComputeSomething' with the files.*

- ```dicomautomaton_dispatcher -f common.sql -f seriesA.sql -n -f seriesB.sql -o SFML_Viewer```  
  *Load two distinct groups of data. The second group does not 'see' the file 'common.sql' side effects -- the queries
  are totally separate.*

- ```dicomautomaton_dispatcher fileA fileB -s fileC adir/ -m PatientID=XYZ003 -o ComputeXYZ -o SFML_Viewer```  
  *Load standalone files and all files in specified directory. Inform the analysis 'ComputeXYZ' of the patient's ID,
  launch the analysis, and then interactively view.*

- ```dicomautomaton_dispatcher CT*dcm -o ModifyingOperation -o BoostSerializeDrover```  
  *Launch the default interactive viewer to inspect a collection of computed tomography images, perform an operation
  that modifies them, and serialize the internal state for later using the [BoostSerializeDrover](#boostserializedrover)
  operation.*

### dicomautomaton_webserver

#### Description

This web server presents most operations in an interactive web page. Some operations are disabled by default (e.g.,
[BuildLexiconInteractively](#buildlexiconinteractively) because they are not designed to be operated via remote
procedure calls. This routine should be run within a capability-limiting environment, but access to an X server is
required. A Docker script is bundled with DICOMautomaton sources which includes everything needed to function properly.

#### Usage Examples

- ```dicomautomaton_webserver --help```  
  *Print a listing of all available options. Note that most configuration is done via editing configuration files. See
  ```/etc/DICOMautomaton/```.*

- ```dicomautomaton_webserver --config /etc/DICOMautomaton/webserver.conf --http-address 0.0.0.0 --http-port 8080
  --docroot='/etc/DICOMautomaton/'```  
  *Launch the webserver on any interface and port 8080.*

### dicomautomaton_bsarchive_convert

#### Description

A program for converting Boost.Serialization archives types which DICOMautomaton can read. These archives need to be
created by the [BoostSerializeDrover](#boostserializedrover) operation. Some archive types are concise and not portable
(i.e., binary archives), or verbose (and thus slow to read and write) and portable (i.e., XML, plain text). To combat
verbosity, on-the-fly gzip compression and decompression is supported. This program can be used to convert archive
types.

#### Usage Examples

- ```dicomautomaton_bsarchive_convert --help```  
  *Print a listing of all available options.*

- ```dicomautomaton_bsarchive_convert -i file.binary -o file.xml -t 'XML'```  
  *Convert a binary archive to a portable XML archive.*

- ```dicomautomaton_bsarchive_convert -i file.binary.gz -o file.xml.gz -t 'gzip-xml'```  
  *Convert a binary archive to a gzipped portable XML archive.*

- ```dicomautomaton_bsarchive_convert -i file.binary.gz -o file.xml -t 'XML'```  
  *Convert a gzipped binary archive to a non-gzipped portable XML archive.*

- ```dicomautomaton_bsarchive_convert -i file.xml.gz -o file.txt -t 'txt'```  
  *Convert a gzipped binary archive to a non-gzipped, portable, and inspectable text archive.*

- ```dicomautomaton_bsarchive_convert -i file.txt -o file.txt.gz -t 'gzip-txt'```  
  *Convert an uncompressed text archive to a compressed text archive. Note that this conversion is effectively the same
  as simply ```gzip file.txt```.*

- ```dicomautomaton_bsarchive_convert -i file.xml.gz -o file.bin -t 'binary'```  
  *Convert a compressed archive to a binary file.* Note that binary archives should only expect to be readable on the
  same hardware with the same versions and are therefore best for checkpointing calculations that can fail or may need
  to be tweaked later.*

- ```dicomautomaton_bsarchive_convert -i file.xml.gz -o file.bin.gz -t 'gzip-binary'```  
  *Convert a compressed archive to a compressed binary file.*

### dicomautomaton_dump

#### Description

This program is extremely simplistic. Given a single DICOM file, it prints to stdout the value of one DICOM tag. This
program is best used in scripts, for example to check the modality or a file.

#### Usage Examples

- ```dicomautomaton_dump afile.dcm 0x0008 0x0060```  
  *Print the value of the DICOM tag (0x0008,0x0060) aka (0008,0060).*

### pacs_ingress

#### Description

Given a DICOM file and some additional metadata, insert the data into a PACs system database. The file itself will be
copied into the database and various bits of data will be deciphered. Note that at the moment a 'gdcmdump' file must be
provided and is stored alongside the DICOM file in the database filestore. This sidecar file is meant to support ad-hoc
DICOM queries without having to index the entire file. Also note that imports into the database are minimal, leaving
files with multiple NULL values. This is done to improve ingress times. A separate database refresh
([pacs_refresh](#pacs_refresh)) must be performed to replace NULL values.

#### Usage Examples

- ```pacs_ingress --help```  
  *Print a listing of all available options.*

- ```pacs_ingress -f '/tmp/a.dcm' -g '/tmp/a.gdcmdump' -p 'XYZ Study 2019' -c 'Study concerning XYZ.'```  
  *Insert the file '/tmp/a.dcm' into the database.*

### pacs_refresh

#### Description

A program for trying to replace database NULLs, if possible, using stored files. This program is complementary to
[pacs_ingress](#pacs_ingress). Note that the ```--days-back/-d``` parameter should always be specified.

#### Usage Examples

- ```pacs_refresh --help```  
  *Print a listing of all available options.*

- ```pacs_refresh -d 7```  
  *Perform a refresh of the database, restricting to files imported within the previous 7 days.*

### pacs_duplicate_cleaner

#### Description

Given a DICOM file, check if it is in the PACS DB. If so, delete the file. Note that a full, byte-by-byte comparison is
NOT performed -- rather only the top-level DICOM unique identifiers are (currently) compared. No other metadata is
considered. So this program is not suitable if DICOM files have been modified without re-assigning unique identifiers!
(Which is non-standard behaviour.) Note that if an *exact* comparison is desired, using a traditional file de-duplicator
will work.

#### Usage Examples

- ```pacs_duplicate_cleaner --help```  
  *Print a listing of all available options.*

- ```pacs_duplicate_cleaner -f '/path/to/a/dicom/file.dcm'```  
  *Check if 'file.dcm' is already in the PACS DB. If so, delete it ('file.dcm').*

- ```pacs_duplicate_cleaner -f '/path/to/a/dicom/file.dcm' -n```  
  *Check if 'file.dcm' is already in the PACS DB, but do not delete anything.*

# List of Available Operations

- AccumulateRowsColumns
- AllOf (alias for And)
- Always (alias for Ignore)
- AnalyzeHistograms
- AnalyzeLightRadFieldCoincidence
- AnalyzePicketFence
- AnalyzeRTPlan
- And
- AnyOf
- ApplyCalibrationCurve
- AutoCropImages
- Average
- BCCAExtractRadiomicFeatures
- BEDConvert
- BoostSerializeDrover
- Break (alias for False)
- BuildLexiconInteractively
- CT_Liver_Perfusion
- CT_Liver_Perfusion_First_Run
- CT_Liver_Perfusion_Ortho_Views
- CT_Liver_Perfusion_Pharmaco_1C2I_5Param
- CT_Liver_Perfusion_Pharmaco_1C2I_Reduced3Param
- CellularAutomata
- ClusterDBSCAN
- Coalesce (alias for AnyOf)
- CombineImages
- CombineMeshes
- ComparePixels
- CompileScript
- ContourBasedRayCastDoseAccumulate
- ContourBooleanOperations
- ContourSimilarity
- ContourViaGeometry
- ContourViaThreshold
- ContourVote
- ContourWholeImages
- ContouringAides
- ConvertContoursToImages (alias for HighlightROIs)
- ConvertContoursToMeshes
- ConvertContoursToPoints
- ConvertDoseToImage
- ConvertImageToDose
- ConvertImageToMeshes
- ConvertImageToWarp
- ConvertImagesToContours (alias for ContourViaThreshold)
- ConvertMeshesToContours
- ConvertMeshesToPoints
- ConvertNaNsToAir
- ConvertNaNsToZeros
- ConvertParametersToTable
- ConvertPixelsToPoints
- ConvertTableToParameters (alias for MapTableToParameters)
- ConvertWarpToImage
- ConvertWarpToMeshes
- ConvolveImages
- CopyContours
- CopyImages
- CopyLineSamples
- CopyMeshes
- CopyPoints
- CopyTables
- CountObjects
- CountVoxels
- CropImageDoseToROIs
- CropImages
- CropROIDose
- DCEMRI_IAUC
- DCEMRI_Nonparametric_CE
- DICOMExportContours
- DICOMExportImagesAsCT
- DICOMExportImagesAsDose
- DICOMExportImagesAsMR
- DeDuplicateImages
- DecayDoseOverTimeHalve
- DecayDoseOverTimeJones2014
- DecimatePixels
- DecomposeImagesSVD
- Delay (alias for Sleep)
- DeleteContours
- DeleteImages
- DeleteLineSamples
- DeleteMeshes
- DeletePoints
- DeleteTables
- DetectGrid3D
- DetectShapes3D
- DrawGeometry
- DroverDebug
- DumpAllOrderedImageMetadataToFile
- DumpAnEncompassedPoint
- DumpFilesPartitionedByTime
- DumpImageMeshes
- DumpImageMetadataOccurrencesToFile
- DumpPerROIParams_KineticModel_1C2I_5P
- DumpPixelValuesOverTimeForAnEncompassedPoint
- DumpPlanSummary
- DumpROIContours
- DumpROIData
- DumpROISNR
- DumpROISurfaceMeshes
- DumpRTPlanMetadataOccurrencesToFile
- DumpVoxelDoseInfo
- EQDXTable
- ElseIf (alias for IfElse)
- EvaluateDoseVolumeStats
- EvaluateNTCPModels
- EvaluateParameters
- EvaluateTCPModels
- ExecuteShell
- ExplodeImages
- ExportContours
- ExportDrover
- ExportFITSImages
- ExportLineSamples
- ExportOriginalFiles
- ExportPointClouds
- ExportSNCImages
- ExportSurfaceMeshes
- ExportSurfaceMeshesOBJ
- ExportSurfaceMeshesOFF
- ExportSurfaceMeshesPLY
- ExportSurfaceMeshesSTL
- ExportTables
- ExportWarps
- ExtractAlphaBeta
- ExtractImageHistograms
- ExtractPointsWarp
- ExtractRadiomicFeatures
- FVPicketFence
- False
- FindFiles
- FirstOf (alias for AnyOf)
- For
- ForEachDistinct
- ForEachRTPlan
- Force (alias for Ignore)
- Fork
- GenerateCalibrationCurve
- GenerateMapTiles
- GenerateMeshes
- GenerateSurfaceMask
- GenerateSyntheticImages
- GenerateTable
- GenerateVirtualDataContourViaThresholdTestV1
- GenerateVirtualDataDoseStairsV1
- GenerateVirtualDataImageSphereV1
- GenerateVirtualDataPerfusionV1
- GenerateWarp
- GiveWholeImageArrayABoneWindowLevel
- GiveWholeImageArrayAHeadAndNeckWindowLevel
- GiveWholeImageArrayAThoraxWindowLevel
- GiveWholeImageArrayAnAbdominalWindowLevel
- GiveWholeImageArrayAnAlphaBetaWindowLevel
- GridBasedRayCastDoseAccumulate
- Group (alias for And)
- GroupImages
- GrowContours
- HighlightROIs
- If (alias for IfElse)
- IfElse
- IfThenElse (alias for IfElse)
- Ignore
- ImageRoutineTests
- ImportDrover
- ImprintImages
- InterpolateSlices
- Invert (alias for NoneOf)
- InvokeStandardScript
- Isolate
- IsolatedVoxelFilter
- LoadFiles
- LoadFilesInteractively
- LogScale
- MakeMeshesManifold
- MapTableToParameters
- MaskLogs (alias for MaskVerbosity)
- MaskMetadata (alias for MaskParameters)
- MaskNotifications (alias for MaskVerbosity)
- MaskParameters
- MaskVerbosity
- MaskWarnings (alias for MaskVerbosity)
- MaxMinPixels
- MeldDose
- MinkowskiSum3D
- ModelIVIM
- ModifyContourMetadata
- ModifyImageMetadata
- ModifyLineSamples
- ModifyParameters
- Negate (alias for NoneOf)
- NegatePixels
- NoOp
- NoneOf
- NormalizeLineSamples
- NormalizePixels
- Not (alias for NoneOf)
- NotifyUser
- OptimizeStaticBeams
- Or (alias for AnyOf)
- OrderImages
- PartitionContours
- PartitionImages (alias for GroupImages)
- PerturbPixels
- PlotLineSamples
- PlotPerROITimeCourses
- PointSeparation
- PollDirectories
- Polyominoes
- PreFilterEnormousCTValues
- PresentationImage
- PrintMetadata
- PromoteMetadata
- PruneEmptyImageDoseArrays
- PurgeContours
- QuantizePixels
- QueryUserInteractively
- RPCReceive
- RPCSend
- RankPixels
- ReduceNeighbourhood
- RemeshSurfaceMeshes
- Repeat
- ReportROIData
- ResampleImages
- RigidWarpImages
- SDL_Viewer
- SFML_Viewer
- ScalePixels
- SeamContours
- SelectDirectory
- SelectFilename
- SelectFolder (alias for SelectDirectory)
- SelectSlicesIntersectingROI
- SelectionIsPresent
- SilenceLogs (alias for MaskVerbosity)
- SilenceNotifications (alias for MaskVerbosity)
- SilenceVerbosity (alias for MaskVerbosity)
- SilenceWarnings (alias for MaskVerbosity)
- SimplifyContours
- SimplifySurfaceMeshes
- SimulateRadiograph
- Sleep
- SpatialBlur
- SpatialDerivative
- SpatialSharpen
- Spawn (alias for Fork)
- SpecifyDirectory (alias for SelectDirectory)
- SpecifyFilename (alias for SelectFilename)
- SpecifyFolder (alias for SelectDirectory)
- SubdivideSurfaceMeshes
- SubsegmentContours
- Subsegment_ComputeDose_VanLuijk
- SubtractImages
- SupersampleImageGrid
- TabulateImageMetadata
- Terminal_Viewer
- ThresholdImages
- ThresholdOtsu
- Throw (alias for False)
- Time
- Transaction
- TrimROIDose
- True
- UBC3TMRI_DCE
- UBC3TMRI_DCE_Differences
- UBC3TMRI_DCE_Experimental
- UBC3TMRI_IVIM_ADC
- ValidateRTPlan
- VolumetricCorrelationDetector
- VolumetricSpatialBlur
- VolumetricSpatialDerivative
- VoxelRANSAC
- Wait (alias for Sleep)
- WarpContours
- WarpImages
- WarpImagesRigid (alias for RigidWarpImages)
- WarpMeshes
- WarpPoints
- While
- WidenTable

# Operations Reference

## AccumulateRowsColumns

### Tags

- accepts parameter: images
- category: image processing
- category: interactive

### Description

This operation generates row- and column-profiles of images in which the entire row or column has been summed together.
It is useful primarily for detection of axes-aligned edges or ridges.

### Notes

- It is often useful to pre-process inputs by computing an in-image-plane derivative, gradient magnitude, or similar
  (i.e., something to emphasize edges) before calling this routine. It is not necessary, however.

### Parameters

- ImageSelection

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## AnalyzeHistograms

### Tags

- accepts parameter: line samples
- category: acquires futex
- category: file export
- category: line sample processing

### Description

This operation analyzes the selected line samples as if they were cumulative dose-volume histograms (DVHs). Multiple
criteria can be specified. Results can be written to a CSV file that can be concatenated or appended to other output
files to provide a summary of multiple criteria, or stored as key-values in the global parameter table.

### Notes

- This routine will filter out non-matching line samples. Currently required: Modality=Histogram; each must be
  explicitly marked as a cumulative, unscaled abscissa + unscaled ordinate histogram; and differential distribution
  statistics must be available (e.g., min, mean, and max voxel doses).

- No output files will be written when (1) there are no constraints to evaluate, and/or (2) results are written in the
  global parameter table.

### Parameters

- LineSelection
- SummaryFilename
- UserComment
- Description
- MetadataColumns
- Constraints
- ReferenceDose

#### LineSelection

##### Description

Select one or more line samples. Selection specifiers can be of three types: positional, metadata-based key@value regex,
and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth line sample (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last line sample.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the line sample composed of the greatest and fewest number of samples. Only one or zero line sample will be
selected; if there are ties, there is no guarantee which line sample will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple line sample based on a threshold count, i.e., where all selected line sample have
more than or fewer than $N$ samples. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all line sample that do not have the greatest number of samples, not the least-numerous line sample (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### SummaryFilename

##### Description

A summary of the criteria and results will be appended to this file. The format is CSV. Leave empty to dump to generate
a unique temporary file. If an existing file is present, rows will be appended without writing a header. If there is
nothing to write, a no file will be created.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data. Even if left empty, the column will remain in the output to
ensure the outputs from multiple runs can be safely concatenated. Preceding alphanumeric variables with a '$' will cause
them to be treated as metadata keys and replaced with the corresponding key's value, if present. Metadata sources are
(1) from the global parameter table, and (2) from the current line sample / histogram being processed. For example, 'The
modality is $Modality' might be (depending on the metadata) expanded to 'The modality is Histogram'. If the metadata key
is not present, the expression will remain unexpanded (i.e., with a preceeding '$').

##### Default

- ```""```

##### Examples

- ```"Using XYZ"```
- ```"Patient treatment plan C"```
- ```"$PatientID"```

#### Description

##### Description

A string that will be inserted into the output file which should be used to describe the constraint and any caveats that
the viewer should be aware of. Generally, the UserComment is best for broadly-defined notes whereas the Description is
tailored for each constraint. Preceding alphanumeric variables with a '$' will cause them to be treated as metadata keys
and replaced with the corresponding key's value, if present. Metadata sources are (1) from the global parameter table,
and (2) from the current line sample / histogram being processed. For example, 'The modality is $Modality' might be
(depending on the metadata) expanded to 'The modality is Histogram'. If the metadata key is not present, the expression
will remain unexpanded (i.e., with a preceeding '$').

##### Default

- ```""```

##### Examples

- ```"Liver"```
- ```"Lung"```
- ```"Liver - GTV"```
- ```"$LineName"```

#### MetadataColumns

##### Description

A comma-separated list of metadata key-value keys that will each be inserted as a separate column. The values will be
expanded by first attempting to use the histogram's metadata, and if not present, the global parameter table. If not
present in the global parameter table, the column will remain empty.

##### Default

- ```""```

##### Examples

- ```"Modality"```
- ```"PatientID"```
- ```"PatientID,StudyDate,StudyTime"```

#### Constraints

##### Description

Constraint criteria that will be evaluated against the selected line samples. Three general types of constraints are
recognized. Note that in the examples below, 'D' represents radiation dose, but can be replaced with 'I' which
represents generic scalar intensity.

First, constraints in the style of 'Dmax < 50.0 Gy'. The left-hand-size (LHS) can be any of {Dmin, Dmean, Dmax}. The
inequality can be any of {<, lt, <=, lte, >, gt, >=, gte}. The right-hand-side (RHS) units can be any of {Gy, cGy, %,
none} where the default units are assumed to be 'Gy', '%' means the RHS number is a percentage of the ReferenceDose, and
'none' uses the existing values without printing or conversion.

Second, constraints in the style of 'D(coldest 500.0 cc) < 50.4 Gy'. The inner LHS can be any of {coldest, hottest}. The
inner LHS units can be any of {cc, cm3, cm^3, %} where '%' means the inner LHS number is a percentage of the total
volume. The inequality can be any of {<, lt, <=, lte, >, gt, >=, gte}. The RHS units can be any of {Gy, cGy, %, none}
where the default units are assumed to be 'Gy', '%' means the RHS number is a percentage of the ReferenceDose and 'none'
uses the existing values without printing or conversion.

Third, constraints in the style of 'V(24.5 Gy) < 500.0 cc'. The inner LHS units can be any of {Gy, cGy, %, none} where
the default units are assumed to be 'Gy', '%' means the inner LHS number is a percentage of the ReferenceDose and 'none'
uses the existing values without printing or conversion. The inequality can be any of {<, lt, <=, lte, >, gt, >=, gte}.
The RHS units can be any of {cc, cm3, cm^3, %} where '%' means the inner LHS number is a percentage of the total volume.

All of the preceding constraints can be prefixed with '(x,y):' to assign the results to variables in the global
parameter table. For example, '(var_x, var_y) : Dmax < 50.0 Gy' will save the key-value 'var_x' as the extracted value
of Dmax, and 'var_y' as the boolean result of the inequality (i.e., either 'true' or 'false'). Dose and volume units are
consistent with the expression's RHS units. An underscore can be used to ignore one of the results. Note that saving
results in the parameter table precludes them from being written to file.

Additionally, dosimetric values can be directly assigned to a variable name and inserted into the global parameter
store, e.g., 'x : Dmin'. Dose is reported in the default units, as-is, without printing or conversion (e.g., DICOM
units; Gy). Note that variables assigned this way are not written to file.

Multiple constraints can be supplied by separating them with ';' delimiters. Each will be evaluated separately. Newlines
can also be used, though constraints should all end with a ';'. Comments can be included by preceeding with a '#', which
facilitate supplying lists of constraints piped in (e.g., from a file via Bash process substitution).

##### Default

- ```""```

##### Examples

- ```"Dmax < 50.0 Gy"```
- ```"Dmean lte 80 %"```
- ```"Dmin >= 80 %"```
- ```"Dmin >= 65 Gy"```
- ```"Dmin >= 65"```
- ```"Dmin >= 6500 cGy"```
- ```"Imean lte 50 %"```
- ```"Imean < 123.0"```
- ```"D(coldest 500.0 cc) <= 25.0 Gy"```
- ```"D(coldest 500.0 cc) <= 15.0 %"```
- ```"D(coldest 50%) <= 15.0 %"```
- ```"D(hottest 10%) gte 95.0 %"```
- ```"V(24.5 Gy) < 500.0 cc"```
- ```"V(10%) < 50.0 cc"```
- ```"V(24.5 Gy) < 500.0 cc"```
- ```"V(24.5) < 500.0 cc"```
- ```"(x,y) : V(24.5 Gy) < 500.0 cc"```
- ```"(x,_) : Dmean < 5 %"```
- ```"(_,x) : V(24.5 Gy) < 500.0 cc"```
- ```"max_dose = Dmax"```
- ```"x = D(coldest 10%)"```
- ```"x = I(coldest 10%)"```
- ```"(Dmax,_): Dmax < 50.0 Gy ; x: Dmin; (dose_median,passed): D(hottest 50%) <= 5 Gy; Dmean lte 80 % ; D(hottest 10%) gte 95.0 %"```

#### ReferenceDose

##### Description

The absolute dose (or intensity) that relative (i.e., percentage) constraint doses will be considered against.

Generally this will be the prescription dose (in DICOM units; Gy), but can also represent a generic scalar intensity.
(The units are not specified, so are considered to be the same as the source histogram data.)

If there are multiple prescriptions, either the prescription appropriate for the constraint should be supplied, or
relative dose constraints should not be used.

##### Default

- ```"nan"```

##### Examples

- ```"70.0"```
- ```"42.5"```


----------------------------------------------------

## AnalyzeLightRadFieldCoincidence

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation analyzes the selected images to compare light and radiation field coincidence for fixed, symmetric field
sizes. Coincidences are extracted automatically by fitting Gaussians to the peak nearest to one of the specified field
boundaries and comparing offset from one another. So, for example, a 10x10cm MLC-defined field would be compared to a
15x15cm field if there are sharp edges (say, metal rulers) that define a 10x10cm field (i.e., considered to represent
the light field). Horizontal and vertical directions (both positive and negative) are all analyzed separately.

### Notes

- This routine assumes both fields are squarely aligned with the image axes. Alignment need not be perfect, but the
  Gaussians may be significantly broadened if there is misalignment. This should be fixed in a future revision.

- It is often useful to pre-process inputs by computing an in-image-plane derivative, gradient magnitude, or similar
  (i.e., something to emphasize edges) before calling this routine. It may not be necessary, however.

### Parameters

- ImageSelection
- ToleranceLevel
- EdgeLengths
- SearchDistance
- PeakSimilarityThreshold
- UserComment
- OutputFileName
- InteractivePlots

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ToleranceLevel

##### Description

Controls detected edge visualization for easy identification of edges out of tolerance. Note: this value refers to
edge-to-edge separation, not edge-to-nominal distances. This value is in DICOM units.

##### Default

- ```"1.0"```

##### Examples

- ```"0.5"```
- ```"1.0"```
- ```"2.0"```
- ```"inf"```

#### EdgeLengths

##### Description

Comma-separated list of (symmetric) edge lengths fields should be analyzed at. For example, if 50x50, 100x100, 150x150,
and 200x200 (all in mm) fields are to be analyzed, this argument would be '50,100,150,200' and it will be assumed that
the field centre is at DICOM position (0,0,0). All values are in DICOM units.

##### Default

- ```"100"```

##### Examples

- ```"100.0"```
- ```"50,100,150,200,300"```
- ```"10.273,20.2456"```

#### SearchDistance

##### Description

The distance around the anticipated field edges to search for edges (actually sharp peaks arising from edges). If an
edge is further away than this value from the anticipated field edge, then the coincidence will be ignored altogether.
The value should be greater than the largest action/tolerance threshold with some additional margin (so gross errors can
be observed), but small enough that spurious edges (i.e., unintended features in the image, such as metal fasteners, or
artifacts near the field edge) do not replace the true field edges. The 'sharpness' of the field edge (resulting from
the density of the material used to demarcate the edge) can impact this value; if the edge is not sharp, then the peak
will be shallow, noisy, and may therefore travel around depending on how the image is pre-processed. Note that both
radiation field and light field edges may differ from the 'nominal' anticipated edges, so this wobble factor should be
incorporated in the search distance. This quantity must be in DICOM units.

##### Default

- ```"3.0"```

##### Examples

- ```"2.5"```
- ```"3.0"```
- ```"5.0"```

#### PeakSimilarityThreshold

##### Description

Images can be taken such that duplicate peaks will occur, such as when field sizes are re-used. Peaks are therefore
de-duplicated. This value (as a %, ranging from [0,100]) specifies the threshold of disimilarity below which peaks are
considered duplicates. A low value will make duplicates confuse the analysis, but a high value may cause legitimate
peaks to be discarded depending on the attenuation cababilties of the field edge markers.

##### Default

- ```"25"```

##### Examples

- ```"5"```
- ```"10"```
- ```"15"```
- ```"50"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data. If left empty, the column will be omitted from the output.

##### Default

- ```""```

##### Examples

- ```""```
- ```"6MV"```
- ```"Using XYZ"```
- ```"Test with thick metal edges"```

#### OutputFileName

##### Description

A filename (or full path) in which to append field edge coincidence data generated by this routine. The format is CSV.
Leave empty to dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### InteractivePlots

##### Description

Whether to interactively show plots showing detected edges.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```


----------------------------------------------------

## AnalyzePicketFence

### Tags

- accepts parameter: images
- category: acquires futex
- category: file export
- category: image processing

### Description

This operation extracts MLC positions from a picket fence image.

### Notes

- This routine requires data to be pre-processed. The gross picket area should be isolated and the leaf junction areas
  contoured (one contour per junction). Both can be accomplished via thresholding. Additionally, stray pixels should be
  filtered out using, for example, median or conservative filters.

- This routine analyzes the picket fences on the plane in which they are specified within the DICOM file, which often
  coincides with the image receptor ('RTImageSID'). Tolerances are evaluated on the isoplane, so the image is projected
  before measuring distances, but the image itself is not altered; a uniform magnification factor of SAD/SID is applied
  to all distances.

### Parameters

- ImageSelection
- MLCModel
- MLCROILabel
- JunctionROILabel
- PeakROILabel
- MinimumJunctionSeparation
- ThresholdDistance
- LeafGapsFileName
- ResultsSummaryFileName
- UserComment
- InteractivePlots

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### MLCModel

##### Description

The MLC design geometry to use. 'VarianMillenniumMLC80' has 40 leafs in each bank; leaves are 10mm wide at isocentre;
and the maximum static field size is 40cm x 40cm. 'VarianMillenniumMLC120' has 60 leafs in each bank; the 40 central
leaves are 5mm wide at isocentre; the 20 peripheral leaves are 10mm wide; and the maximum static field size is 40cm x
40cm. 'VarianHD120' has 60 leafs in each bank; the 32 central leaves are 2.5mm wide at isocentre; the 28 peripheral
leaves are 5mm wide; and the maximum static field size is 40cm x 22cm.

##### Default

- ```"VarianMillenniumMLC120"```

##### Supported Options

- ```"VarianMillenniumMLC80"```
- ```"VarianMillenniumMLC120"```
- ```"VarianHD120"```

#### MLCROILabel

##### Description

An ROI imitating the MLC axes of leaf pairs is created. This is the label to apply to it. Note that the leaves are
modeled with thin contour rectangles of virtually zero area. Also note that the outline colour is significant and
denotes leaf pair pass/fail.

##### Default

- ```"Leaves"```

##### Examples

- ```"MLC_leaves"```
- ```"MLC"```
- ```"approx_leaf_axes"```

#### JunctionROILabel

##### Description

An ROI imitating the junction is created. This is the label to apply to it. Note that the junctions are modeled with
thin contour rectangles of virtually zero area.

##### Default

- ```"Junction"```

##### Examples

- ```"Junction"```
- ```"Picket_Fence_Junction"```

#### PeakROILabel

##### Description

ROIs encircling the leaf profile peaks are created. This is the label to apply to it. Note that the peaks are modeled
with small squares.

##### Default

- ```"Peak"```

##### Examples

- ```"Peak"```
- ```"Picket_Fence_Peak"```

#### MinimumJunctionSeparation

##### Description

The minimum distance between junctions on the SAD isoplane in DICOM units (mm). This number is used to de-duplicate
automatically detected junctions. Analysis results should not be sensitive to the specific value.

##### Default

- ```"10.0"```

##### Examples

- ```"5.0"```
- ```"10.0"```
- ```"15.0"```
- ```"25.0"```

#### ThresholdDistance

##### Description

The threshold distance in DICOM units (mm) above which MLC separations are considered to 'fail'. Each leaf pair is
evaluated separately. Pass/fail status is also indicated by setting the leaf axis contour colour (blue for pass, red for
fail).

##### Default

- ```"1.0"```

##### Examples

- ```"0.5"```
- ```"1.0"```
- ```"2.0"```

#### LeafGapsFileName

##### Description

This file will contain gap and nominal-vs-actual offset distances for each leaf pair. The format is CSV. Leave empty to
dump to generate a unique temporary file. If an existing file is present, rows will be appended without writing a
header.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### ResultsSummaryFileName

##### Description

This file will contain a brief summary of the results. The format is CSV. Leave empty to dump to generate a unique
temporary file. If an existing file is present, rows will be appended without writing a header.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```

#### InteractivePlots

##### Description

Whether to interactively show plots showing detected edges.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```


----------------------------------------------------

## AnalyzeRTPlan

### Tags

- category: acquires futex
- category: file export
- category: rtplan processing

### Description

This operation analyzes the selected RT plans, performing a general analysis suitable for exploring or comparing plans
at a high-level. Currently, only the total leaf opening (i.e., the sum of all leaf openings -- the distance between a
leaf in bank A to the opposing leaf in bank B) is reported for each plan, beam, and control point. The output is a CSV
file that can be concatenated or appended to other output files to provide a summary of multiple criteria.

### Parameters

- RTPlanSelection
- SummaryFilename
- UserComment
- Description

#### RTPlanSelection

##### Description

Select one or more treatment plans. Note that a single treatment plan may be composed of multiple beams; if delivered
sequentially, they should collectively represent a single logically cohesive plan. Selection specifiers can be of three
types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth treatment plan (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last treatment plan.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the treatment plan composed of the greatest and fewest number of control points. Only one or zero treatment plan
will be selected; if there are ties, there is no guarantee which treatment plan will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple treatment plan based on a threshold count, i.e., where all selected treatment plan
have more than or fewer than $N$ control points. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all treatment plan that do not have the greatest number of control points, not the least-numerous
treatment plan (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### SummaryFilename

##### Description

Analysis results will be appended to this file. The format is CSV. Leave empty to dump to generate a unique temporary
file. If an existing file is present, rows will be appended without writing a header.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data. Even if left empty, the column will remain in the output to
ensure the outputs from multiple runs can be safely concatenated. Preceding alphanumeric variables with a '$' will cause
them to be treated as metadata keys and replaced with the corresponding key's value, if present. For example, 'The
modality is $Modality' might be (depending on the metadata) expanded to 'The modality is RTPLAN'. If the metadata key is
not present, the expression will remain unexpanded (i.e., with a preceeding '$').

##### Default

- ```""```

##### Examples

- ```"Using XYZ"```
- ```"Patient treatment plan C"```
- ```"$PatientID"```

#### Description

##### Description

A string that will be inserted into the output file which should be used to describe the constraint and any caveats that
the viewer should be aware of. Generally, the UserComment is best for broadly-defined notes whereas the Description is
tailored for each constraint. Preceding alphanumeric variables with a '$' will cause them to be treated as metadata keys
and replaced with the corresponding key's value, if present. For example, 'The modality is $Modality' might be
(depending on the metadata) expanded to 'The modality is RTPLAN'. If the metadata key is not present, the expression
will remain unexpanded (i.e., with a preceeding '$').

##### Default

- ```""```

##### Examples

- ```"2 Arcs"```
- ```"1 Arc"```
- ```"IMRT"```


----------------------------------------------------

## And

### Tags

- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that requires all children to complete successfully.

### Aliases

- AllOf
- Group

### Notes

- If this operation has no children, this operation will evaluate to a no-op.

- Each child is performed sequentially in the order specified, and all side-effects are carried forward. In particular,
  all selectors in child operations are evaluated lazily, at the moment when the child operation is invoked.

### Parameters

No registered options.

----------------------------------------------------

## AnyOf

### Tags

- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that performs an 'any-of' or 'first-of' Boolean check by evaluating
child operations. The first child operation that succeeds short-circuits the remaining checks and returns true. If no
child operation succeeds, false is returned. Side effects from all evaluated operations are possible.

### Aliases

- FirstOf
- Or
- Coalesce

### Notes

- Child operations are performed in order, and all side-effects are carried forward. In particular, all selectors in
  child operations are evaluated lazily, at the moment when the child operation is invoked.

- If this operation has no children, or no children complete successfully, then this operation signals false truthiness.

- Some operations may succeed without directly signalling failure. For example, an operation that loops over all
  selected images may not throw if zero images are selected. This operation works well with other control flow
  meta-operations, for example as a conditional in an if-else statement.

### Parameters

No registered options.

----------------------------------------------------

## ApplyCalibrationCurve

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This operation applies a given calibration curve to voxel data inside the specified ROI(s). It is designed to apply
calibration curves, but is useful for transforming voxel intensities using any supplied 1D curve.

### Notes

- This routine can handle overlapping or duplicate contours.

### Parameters

- Channel
- ImageSelection
- ContourOverlap
- Inclusivity
- CalibCurveFileName
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### Channel

##### Description

The image channel to use. Zero-based. Use '-1' to operate on all available channels.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. The option 'honour_opposite_orientations' makes overlapping contours with opposite
orientation cancel. Otherwise, orientation is ignored. The latter is useful for Boolean structures where contour
orientation is significant for interior contours (holes). The option 'overlapping_contours_cancel' ignores orientation
and cancels all contour overlap.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### CalibCurveFileName

##### Description

The file from which a calibration curve should be read from. The format should be line-based with either 2 or 4 numbers
per line. For 2 numbers: (current pixel value) (new pixel value) and for 4 numbers: (current pixel value) (uncertainty)
(new pixel value) (uncertainty). Uncertainties refer to the prior number and may be uniformly zero if unknown. Lines
beginning with '#' are treated as comments and ignored. The curve is linearly interpolated, and must span the full range
of pixel values. This is done to avoid extrapolation within the operation since the correct behaviour will differ
depending on the specifics of the calibration.

##### Default

- ```""```

##### Examples

- ```"/tmp/calib.dat"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## AutoCropImages

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation crops image slices using image-specific metadata embedded within the image.

### Parameters

- ImageSelection
- DICOMMargin
- RTIMAGE

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### DICOMMargin

##### Description

The amount of margin (in the DICOM coordinate system) to spare from cropping.

##### Default

- ```"0.0"```

##### Examples

- ```"0.1"```
- ```"2.0"```
- ```"-0.5"```
- ```"20.0"```

#### RTIMAGE

##### Description

If true, attempt to crop the image using information embedded in an RTIMAGE. This option cannot be used with the other
options.

##### Default

- ```"true"```

##### Examples

- ```"true"```
- ```"false"```


----------------------------------------------------

## Average

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation averages image arrays/volumes. It can average over spatial or temporal dimensions. However, rather than
relying specifically on time for temporal averaging, any images that have overlapping voxels can be averaged.

### Notes

- This operation is typically used to create an aggregate view of a large volume of data. It may also increase SNR and
  can be used for contouring purposes.

### Parameters

- ImageSelection
- AveragingMethod

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### AveragingMethod

##### Description

The averaging method to use. Valid methods are 'overlapping-spatially' and 'overlapping-temporally'.

##### Default

- ```""```

##### Supported Options

- ```"overlapping-spatially"```
- ```"overlapping-temporally"```


----------------------------------------------------

## BCCAExtractRadiomicFeatures

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This operation extracts radiomic features from an image and one or more ROIs.

### Notes

- This is a 'simplified' version of the full radiomics extract routine that uses defaults that are expected to be
  reasonable across a wide range of scenarios.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- FractionalAreaTolerance
- SimplificationMethod
- UserComment
- FeaturesFileName
- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- ScaleFactor
- ImageFileName
- ColourMapRegex
- WindowLow
- WindowHigh

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### FractionalAreaTolerance

##### Description

The fraction of area each contour will tolerate during simplified. This is a measure of how much the contour area can
change due to simplification.

##### Default

- ```"0.05"```

##### Examples

- ```"0.001"```
- ```"0.01"```
- ```"0.02"```
- ```"0.05"```
- ```"0.10"```

#### SimplificationMethod

##### Description

The specific algorithm used to perform contour simplification. 'Vertex removal' is a simple algorithm that removes
vertices one-by-one without replacement. It iteratively ranks vertices and removes the single vertex that has the least
impact on contour area. It is best suited to removing redundant vertices or whenever new vertices should not be added.
'Vertex collapse' combines two adjacent vertices into a single vertex at their midpoint. It iteratively ranks vertex
pairs and removes the single vertex that has the least total impact on contour area. Note that small sharp features that
alternate inward and outward will have a small total area cost, so will be pruned early. Thus this technique acts as a
low-pass filter and will defer simplification of high-curvature regions until necessary. It is more economical compared
to vertex removal in that it will usually simplify contours more for a given tolerance (or, equivalently, can retain
contour fidelity better than vertex removal for the same number of vertices). However, vertex collapse performs an
averaging that may result in numerical imprecision.

##### Default

- ```"vert-rem"```

##### Supported Options

- ```"vertex-collapse"```
- ```"vertex-removal"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```

#### FeaturesFileName

##### Description

Features will be appended to this file. The format is CSV. Leave empty to dump to generate a unique temporary file. If
an existing file is present, rows will be appended without writing a header.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ScaleFactor

##### Description

This factor is applied to the image width and height to magnify (larger than 1) or shrink (less than 1) the image. This
factor only affects the output image size. Note that aspect ratio is retained, but rounding for non-integer factors may
lead to small (1-2 pixel) discrepancies.

##### Default

- ```"1.5"```

##### Examples

- ```"0.5"```
- ```"1.0"```
- ```"2.0"```
- ```"5.23"```

#### ImageFileName

##### Description

The file name to use for the image. If blank, a filename will be generated sequentially.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/an_image.png"```
- ```"afile.png"```

#### ColourMapRegex

##### Description

The colour mapping to apply to the image if there is a single channel. The default will match the first available, and
if there is no matching map found, the first available will be selected.

##### Default

- ```".*"```

##### Supported Options

- ```"Viridis"```
- ```"Magma"```
- ```"Plasma"```
- ```"Inferno"```
- ```"Jet"```
- ```"MorelandBlueRed"```
- ```"MorelandBlackBody"```
- ```"MorelandExtendedBlackBody"```
- ```"KRC"```
- ```"ExtendedKRC"```
- ```"Kovesi_LinKRYW_5-100_c64"```
- ```"Kovesi_LinKRYW_0-100_c71"```
- ```"Kovesi_Cyclic_cet-c2"```
- ```"LANLOliveGreentoBlue"```
- ```"YgorIncandescent"```
- ```"LinearRamp"```

#### WindowLow

##### Description

If provided, this parameter will override any existing window and level. All pixels with the intensity value or lower
will be assigned the lowest possible colour according to the colour map. Not providing a valid number will disable
window overrides.

##### Default

- ```""```

##### Examples

- ```""```
- ```"-1.23"```
- ```"0"```
- ```"1E4"```

#### WindowHigh

##### Description

If provided, this parameter will override any existing window and level. All pixels with the intensity value or higher
will be assigned the highest possible colour according to the colour map. Not providing a valid number will disable
window overrides.

##### Default

- ```""```

##### Examples

- ```""```
- ```"1.23"```
- ```"0"```
- ```"10.3E4"```


----------------------------------------------------

## BEDConvert

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation performs Biologically Effective Dose (BED) and Equivalent Dose with 'x'-dose per fraction (EQDx)
conversions. Currently, only photon external beam therapy conversions are supported.

### Notes

- For an 'EQD2' transformation, select an EQDx conversion model with 2 Gy per fraction (i.e., $x=2$).

- This operation treats all tissue as either early-responding (e.g., tumour) or late-responding (e.g., some normal
  tissues). A single alpha/beta estimate for each type (early or late) can be provided. Currently, only two tissue types
  can be specified.

- This operation requires specification of the initial number of fractions and cannot use dose per fraction. The
  rationale is that for some models, the dose per fraction would need to be specified for *each individual voxel* since
  the prescription dose per fraction is **not** the same for voxels outside the PTV.

- Be careful in handling the output of a BED calculation. In particular, BED doses with a given $\alpha/\beta$ should
  **only** be summed with BED doses that have the same $\alpha/\beta$.

### Parameters

- ImageSelection
- AlphaBetaRatioLate
- AlphaBetaRatioEarly
- PriorNumberOfFractions
- PriorPrescriptionDose
- TargetDosePerFraction
- Model
- EarlyROILabelRegex
- EarlyNormalizedROILabelRegex

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### AlphaBetaRatioLate

##### Description

The value to use for alpha/beta in late-responding (i.e., 'normal', non-cancerous) tissues. Generally a value of 3.0 Gy
is used. Tissues that are sensitive to fractionation may warrant smaller ratios, such as 1.5-3 Gy for cervical central
nervous tissues and 2.3-4.9 for lumbar central nervous tissues (consult table 8.1, page 107 in: Joiner et al.,
'Fractionation: the linear-quadratic approach', 4th Ed., 2009, in the book 'Basic Clinical Radiobiology', ISBN:
0340929669). Note that the selected ROIs denote early-responding tissues; all remaining tissues are considered
late-responding.

##### Default

- ```"3.0"```

##### Examples

- ```"2.0"```
- ```"3.0"```

#### AlphaBetaRatioEarly

##### Description

The value to use for alpha/beta in early-responding tissues (i.e., tumourous and some normal tissues). Generally a value
of 10.0 Gy is used. Note that the selected ROIs denote early-responding tissues; all remaining tissues are considered
late-responding.

##### Default

- ```"10.0"```

##### Examples

- ```"10.0"```

#### PriorNumberOfFractions

##### Description

The number of fractions over which the dose distribution was (or will be) delivered. This parameter is required for both
BED and EQDx conversions. Decimal fractions are supported to accommodate multi-pass BED conversions.

##### Default

- ```"35"```

##### Examples

- ```"10"```
- ```"20.5"```
- ```"35"```
- ```"40.123"```

#### PriorPrescriptionDose

##### Description

The prescription dose that was (or will be) delivered to the PTV. This parameter is only used for the
'eqdx-lq-simple-pinned' model. Note that this is a theoretical dose since the PTV or CTV will only nominally receive
this dose. Also note that the specified dose need not exist somewhere in the image. It can be purely theoretical to
accommodate previous BED conversions.

##### Default

- ```"70"```

##### Examples

- ```"15"```
- ```"22.5"```
- ```"45.0"```
- ```"66"```
- ```"70.001"```

#### TargetDosePerFraction

##### Description

The desired dose per fraction 'x' for an EQDx conversion. For an 'EQD2' conversion, this value *must* be 2 Gy. For an
'EQD3.5' conversion, this value should be 3.5 Gy. Note that the specific interpretation of this parameter depends on the
model.

##### Default

- ```"2.0"```

##### Examples

- ```"1.8"```
- ```"2.0"```
- ```"5.0"```
- ```"8.0"```

#### Model

##### Description

The BED or EQDx model to use. All assume e was delivered using photon external beam therapy. Current options are
'bed-lq-simple', 'eqdx-lq-simple', and 'eqdx-lq-simple-pinned'. The 'bed-lq-simple' model uses a standard
linear-quadratic model that disregards time delays, including repopulation ($BED = (1 + \alpha/\beta)nd$). The
'eqdx-lq-simple' model uses the widely-known, standard formula $EQD_{x} = nd(d + \alpha/\beta)/(x + \alpha/\beta)$ which
is dervied from the linear-quadratic radiobiological model and is also known as the 'Withers' formula. This model
disregards time delays, including repopulation. The 'eqdx-lq-simple-pinned' model is an **experimental** alternative to
the 'eqdx-lq-simple' model. The 'eqdx-lq-simple-pinned' model implements the 'eqdx-lq-simple' model, but avoids having
to specify *x* dose per fraction. First the prescription dose is transformed to EQDx with *x* dose per fraction and the
effective number of fractions is extracted. Then, each voxel is transformed assuming this effective number of fractions
rather than a specific dose per fraction. This model conveniently avoids having to awkwardly specify *x* dose per
fraction for voxels that receive less than *x* dose. It is also idempotent. Note, however, that the
'eqdx-lq-simple-pinned' model produces EQDx estimates that are **incompatbile** with 'eqdx-lq-simple' EQDx estimates.

##### Default

- ```"eqdx-lq-simple"```

##### Supported Options

- ```"bed-lq-simple"```
- ```"eqdx-lq-simple"```
- ```"eqdx-lq-simple-pinned"```

#### EarlyROILabelRegex

##### Description

This parameter selects ROI labels/names to consider as bounding early-responding tissues. A regular expression (regex)
matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*GTV.*"```
- ```"PTV66"```
- ```".*PTV.*|.*GTV.**"```

#### EarlyNormalizedROILabelRegex

##### Description

This parameter selects ROI labels/names to consider as bounding early-responding tissues. A regular expression (regex)
matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*GTV.*"```
- ```"PTV66"```
- ```".*PTV.*|.*GTV.**"```


----------------------------------------------------

## BoostSerializeDrover

### Tags

- category: meta

### Description

This operation exports all loaded state to a serialized format that can be loaded again later. Is is especially useful
for suspending long-running operations with intermittant interactive sub-operations.

### Parameters

- Filename
- Components

#### Filename

##### Description

The filename (or full path name) to which the serialized data should be written. The file format is gzipped XML, which
should be portable across most CPUs.

##### Default

- ```"/tmp/boost_serialized_drover.xml.gz"```

##### Examples

- ```"/tmp/out.xml.gz"```
- ```"./out.xml.gz"```
- ```"out.xml.gz"```

#### Components

##### Description

Which components to include in the output. Currently, any combination of (all images), (all contours), (all point
clouds), (all surface meshes), and (all treatment plans) can be selected. Note that RTDOSEs are treated as images.

##### Default

- ```"images+contours+pointclouds+surfacemeshes+rtplans"```

##### Examples

- ```"images"```
- ```"images+pointclouds"```
- ```"images+pointclouds+surfacemeshes"```
- ```"pointclouds+surfacemeshes"```
- ```"rtplans+images+contours"```
- ```"contours+images+pointclouds"```


----------------------------------------------------

## BuildLexiconInteractively

### Tags

- category: interactive
- category: meta

### Description

This operation interactively builds a lexicon using the currently loaded contour labels. It is useful for constructing a
domain-specific lexicon from a set of representative data.

### Notes

- An exclusive approach is taken for ROI selection rather than an inclusive approach because regex negations are not
  easily supported in the POSIX syntax.

### Parameters

- CleanLabels
- JunkLabel
- OmitROILabelRegex
- LexiconSeedFile

#### CleanLabels

##### Description

A listing of the labels of interest. These will be (some of) the 'clean' entries in the finished lexicon. You should
only name ROIs you specifically care about and which have a single, unambiguous occurence in the data set (e.g.,
'Left_Parotid' is good, but 'JUNK' and 'Parotids' are bad -- you won't be able to select the single 'JUNK' label if all
you care about are parotids.

##### Default

- ```"Body,Brainstem,Chiasm,Cord,Larynx Pharynx,Left Eye,Left Optic Nerve,Left Parotid,Left Submand,Left Temp Lobe,Oral Cavity,Right Eye,Right Optic Nerve,Right Parotid,Right Submand,Right Temp Lobe"```

##### Examples

- ```"Left Parotid,Right Parotid,Left Submand,Right Submand"```
- ```"Left Submand,Right Submand"```

#### JunkLabel

##### Description

A label to apply to the un-matched labels. This helps prevent false positives by excluding names which are close to a
desired clean label. For example, if you are looking for 'Left_Parotid' you will want to mark 'left-parotid_opti' and
'OLDLeftParotid' as junk. Passing an empty string disables junk labeling.

##### Default

- ```"JUNK"```

##### Examples

- ```""```
- ```"Junk"```
- ```"Irrelevant"```
- ```"NA_Organ"```

#### OmitROILabelRegex

##### Description

This parameter selects ROI labels/names to prune. Only matching ROIs will be pruned. The default will match no ROIs. A
regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```""```

##### Examples

- ```".*left.*|.*right.*|.*eyes.*"```
- ```".*PTV.*|.*CTV.*|.*GTV.*"```

#### LexiconSeedFile

##### Description

A file containing a 'seed' lexicon to use and add to. This is the lexicon that is being built. It will be modified.

##### Default

- ```""```

##### Examples

- ```"./some_lexicon"```
- ```"/tmp/temp_lexicon"```


----------------------------------------------------

## CT_Liver_Perfusion

### Tags

- category: image processing
- category: perfusion

### Description

This operation performed dynamic contrast-enhanced CT perfusion image modeling on a time series image volume.

### Notes

- This routine is used for research purposes only.

### Parameters

No registered options.

----------------------------------------------------

## CT_Liver_Perfusion_First_Run

### Tags

- category: image processing
- category: perfusion

### Description

This operation performed dynamic contrast-enhanced CT perfusion image modeling on a time series image volume.

### Notes

- Use this mode when peeking at the data for the first time. It avoids computing much, just lets you *look* at the data,
  find t_0, etc..

### Parameters

No registered options.

----------------------------------------------------

## CT_Liver_Perfusion_Ortho_Views

### Tags

- category: image processing
- category: perfusion

### Description

This operation performs dynamic contrast-enhanced CT perfusion image modeling on a time series image volume.

### Notes

- Use this mode when you are only interested in oblique/orthogonal views. The point of this operation is to keep memory
  low so image sets can be compared.

### Parameters

No registered options.

----------------------------------------------------

## CT_Liver_Perfusion_Pharmaco_1C2I_5Param

### Tags

- category: image processing
- category: perfusion

### Description

This operation performed dynamic contrast-enhanced CT perfusion image modeling on a time series image volume.

### Parameters

- AIFROINameRegex
- ExponentialKernelCoeffTruncation
- FastChebyshevMultiplication
- PlotAIFVIF
- PlotPixelModel
- PreDecimateOutSizeR
- PreDecimateOutSizeC
- TargetROINameRegex
- UseBasisSplineInterpolation
- BasisSplineCoefficients
- BasisSplineOrder
- UseChebyshevPolyMethod
- ChebyshevPolyCoefficients
- VIFROINameRegex

#### AIFROINameRegex

##### Description

Regex for the name of the ROI to use as the AIF. It should generally be a major artery near the trunk or near the tissue
of interest.

##### Default

- ```"Abdominal_Aorta"```

##### Examples

- ```"Abdominal_Aorta"```
- ```".*Aorta.*"```
- ```"Major_Artery"```

#### ExponentialKernelCoeffTruncation

##### Description

Control the number of Chebyshev coefficients used to approximate the exponential kernel. Usually ~10 will suffice. ~20
is probably overkill, and ~5 is probably too few. It is probably better to err on the side of caution and enlarge this
number if you're worried about loss of precision -- this will slow the computation somewhat. (You might be able to
offset by retaining fewer coefficients in Chebyshev multiplication; see 'FastChebyshevMultiplication' parameter.)

##### Default

- ```"10"```

##### Examples

- ```"20"```
- ```"15"```
- ```"10"```
- ```"5"```

#### FastChebyshevMultiplication

##### Description

Control coefficient truncation/pruning to speed up Chebyshev polynomial multiplication. (This setting does nothing if
the Chebyshev method is not being used.) The choice of this number depends on how much precision you are willing to
forgo. It also strongly depends on the number of datum in the AIF, VIF, and the number of coefficients used to
approximate the exponential kernel (usually ~10 suffices). Numbers are specified relative to max(N,M), where N and M are
the number of coefficients in the two Chebyshev expansions taking part in the multiplication. If too many coefficients
are requested (i.e., more than (N+M-2)) then the full non-approximate multiplication is carried out.

##### Default

- ```"*10000000.0"```

##### Examples

- ```"*2.0"```
- ```"*1.5"```
- ```"*1.0"```
- ```"*0.5"```
- ```"*0.3"```

#### PlotAIFVIF

##### Description

Control whether the AIF and VIF should be shown prior to modeling.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```

#### PlotPixelModel

##### Description

Show a plot of the fitted model for a specified pixel. Plotting happens immediately after the pixel is processed. You
can supply arbitrary metadata, but must also supply Row and Column numbers. Note that numerical comparisons are
performed lexically, so you have to be exact. Also note the sub-separation token is a semi-colon, not a colon.

##### Default

- ```""```

##### Examples

- ```"Row@12;Column@4;Description@.*k1A.*"```
- ```"Row@256;Column@500;SliceLocation@23;SliceThickness@0.5"```
- ```"Row@256;Column@500;Some@thing#Row@256;Column@501;Another@thing"```
- ```"Row@0;Column@5#Row@4;Column@5#Row@8;Column@5#Row@12;Column@5"```

#### PreDecimateOutSizeR

##### Description

The number of pixels along the row unit vector to group into an outgoing pixel. This optional step can reduce
computation effort by downsampling (decimating) images before computing fitted parameter maps (but *after* computing AIF
and VIF time courses). Must be a multiplicative factor of the incoming image's row count. No decimation occurs if either
this or 'PreDecimateOutSizeC' is zero or negative.

##### Default

- ```"8"```

##### Examples

- ```"0"```
- ```"2"```
- ```"4"```
- ```"8"```
- ```"16"```
- ```"32"```
- ```"64"```
- ```"128"```
- ```"256"```
- ```"512"```

#### PreDecimateOutSizeC

##### Description

The number of pixels along the column unit vector to group into an outgoing pixel. This optional step can reduce
computation effort by downsampling (decimating) images before computing fitted parameter maps (but *after* computing AIF
and VIF time courses). Must be a multiplicative factor of the incoming image's column count. No decimation occurs if
either this or 'PreDecimateOutSizeR' is zero or negative.

##### Default

- ```"8"```

##### Examples

- ```"0"```
- ```"2"```
- ```"4"```
- ```"8"```
- ```"16"```
- ```"32"```
- ```"64"```
- ```"128"```
- ```"256"```
- ```"512"```

#### TargetROINameRegex

##### Description

Regex for the name of the ROI to perform modeling within. The largest contour is usually what you want, but you can also
be more focused.

##### Default

- ```".*Body.*"```

##### Examples

- ```"Liver_Patches_For_Testing_Smaller"```
- ```"Liver_Patches_For_Testing"```
- ```"Suspected_Liver_Rough"```
- ```"Rough_Body"```
- ```".*body.*"```
- ```".*something.*\|.*another.*thing.*"```

#### UseBasisSplineInterpolation

##### Description

Control whether the AIF and VIF should use basis spline interpolation in conjunction with the Chebyshev polynomial
method. If this option is not set, linear interpolation is used instead. Linear interpolation may result in a
less-smooth AIF and VIF (and therefore possibly slower optimizer convergence), but is safer if you cannot verify the AIF
and VIF plots are reasonable. This option currently produces an effect only if the Chebyshev polynomial method is being
used.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```

#### BasisSplineCoefficients

##### Description

Control the number of basis spline coefficients to use, if applicable. (This setting does nothing when basis splines are
not being used.) Valid options for this setting depend on the amount of data and b-spline order. This number controls
the number of coefficients that are fitted (via least-squares). You must verify that overfitting is not happening. If in
doubt, use fewer coefficients. There are two ways to specify the number: relative and absolute. Relative means relative
to the number of datum. For example, if the AIF and VIF have ~40 datum then generally '*0.5' is safe. ('*0.5' means
there are half the number of coefficients as datum.) Inspect for overfitting and poor fit. Because this routine happens
once and is fast, do not tweak to optimize for speed; the aim of this method is to produce a smooth and accurate AIF and
VIF. Because an integer number of coefficients are needed, so rounding is used. You can also specify the absolute number
of coefficients to use like '20'. It often makes more sense to use relative specification. Be aware that not all inputs
can be honoured due to limits on b-spline knots and breaks, and may cause unpredictable behaviour or internal failure.

##### Default

- ```"*0.5"```

##### Examples

- ```"*0.8"```
- ```"*0.5"```
- ```"*0.3"```
- ```"20.0"```
- ```"10.0"```

#### BasisSplineOrder

##### Description

Control the polynomial order of basis spline interpolation to use, if applicable. (This setting does nothing when basis
splines are not being used.) This parameter controls the order of polynomial used for b-spline interpolation, and
therefore has ramifications for the computability and numerical stability of AIF and VIF derivatives. Stick with '4' or
'5' if you're unsure.

##### Default

- ```"4"```

##### Examples

- ```"1"```
- ```"2"```
- ```"3"```
- ```"4"```
- ```"5"```
- ```"6"```
- ```"7"```
- ```"8"```
- ```"9"```
- ```"10"```

#### UseChebyshevPolyMethod

##### Description

Control whether the AIF and VIF should be approximated by Chebyshev polynomials. If this option is not set, a inear
interpolation approach is used instead.

##### Default

- ```"true"```

##### Examples

- ```"true"```
- ```"false"```

#### ChebyshevPolyCoefficients

##### Description

Control the number of Chebyshev polynomial coefficients to use, if applicable. (This setting does nothing when the
Chebyshev polynomial method is not being used.) This number controls the number of coefficients that are computed. There
are two ways to specify the number: relative and absolute. Relative means relative to the number of datum. For example,
if the AIF and VIF have ~40 datum then generally '*2' is safe. ('*2' means there are 2x the number of coefficients as
datum; usually overkill.) A good middle-ground is '*1' which is faster but should produce similar results. For speed
'/2' is even faster, but can produce bad results in some cases. Because an integer number of coefficients are needed,
rounding is used. You can also specify the absolute number of coefficients to use like '20'. It often makes more sense
to use relative specification. Be aware that not all inputs can be honoured (i.e., too large, too small, or negative),
and may cause unpredictable behaviour or internal failure.

##### Default

- ```"*2.0"```

##### Examples

- ```"*10.0"```
- ```"*5.0"```
- ```"*2.0"```
- ```"*1.23"```
- ```"*1.0"```
- ```"/1.0"```
- ```"/2.0"```
- ```"/3.0"```
- ```"/5.0"```
- ```"100.0"```
- ```"50.0"```
- ```"20"```
- ```"10.01"```

#### VIFROINameRegex

##### Description

Regex for the name of the ROI to use as the VIF. It should generally be a major vein near the trunk or near the tissue
of interest.

##### Default

- ```"Hepatic_Portal_Vein"```

##### Examples

- ```"Hepatic_Portal_Vein"```
- ```".*Portal.*Vein.*"```
- ```"Major_Vein"```


----------------------------------------------------

## CT_Liver_Perfusion_Pharmaco_1C2I_Reduced3Param

### Tags

- category: image processing
- category: perfusion

### Description

This operation performed dynamic contrast-enhanced CT perfusion image modeling on a time series image volume.

### Parameters

- AIFROINameRegex
- ExponentialKernelCoeffTruncation
- FastChebyshevMultiplication
- PlotAIFVIF
- PlotPixelModel
- PreDecimateOutSizeR
- PreDecimateOutSizeC
- TargetROINameRegex
- UseBasisSplineInterpolation
- BasisSplineCoefficients
- BasisSplineOrder
- ChebyshevPolyCoefficients
- VIFROINameRegex

#### AIFROINameRegex

##### Description

Regex for the name of the ROI to use as the AIF. It should generally be a major artery near the trunk or near the tissue
of interest.

##### Default

- ```"Abdominal_Aorta"```

##### Examples

- ```"Abdominal_Aorta"```
- ```".*Aorta.*"```
- ```"Major_Artery"```

#### ExponentialKernelCoeffTruncation

##### Description

Control the number of Chebyshev coefficients used to approximate the exponential kernel. Usually ~10 will suffice. ~20
is probably overkill, and ~5 is probably too few. It is probably better to err on the side of caution and enlarge this
number if you're worried about loss of precision -- this will slow the computation somewhat. (You might be able to
offset by retaining fewer coefficients in Chebyshev multiplication; see 'FastChebyshevMultiplication' parameter.)

##### Default

- ```"10"```

##### Examples

- ```"20"```
- ```"15"```
- ```"10"```
- ```"5"```

#### FastChebyshevMultiplication

##### Description

Control coefficient truncation/pruning to speed up Chebyshev polynomial multiplication. (This setting does nothing if
the Chebyshev method is not being used.) The choice of this number depends on how much precision you are willing to
forgo. It also strongly depends on the number of datum in the AIF, VIF, and the number of coefficients used to
approximate the exponential kernel (usually ~10 suffices). Numbers are specified relative to max(N,M), where N and M are
the number of coefficients in the two Chebyshev expansions taking part in the multiplication. If too many coefficients
are requested (i.e., more than (N+M-2)) then the full non-approximate multiplication is carried out.

##### Default

- ```"*10000000.0"```

##### Examples

- ```"*2.0"```
- ```"*1.5"```
- ```"*1.0"```
- ```"*0.5"```
- ```"*0.3"```

#### PlotAIFVIF

##### Description

Control whether the AIF and VIF should be shown prior to modeling.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```

#### PlotPixelModel

##### Description

Show a plot of the fitted model for a specified pixel. Plotting happens immediately after the pixel is processed. You
can supply arbitrary metadata, but must also supply Row and Column numbers. Note that numerical comparisons are
performed lexically, so you have to be exact. Also note the sub-separation token is a semi-colon, not a colon.

##### Default

- ```""```

##### Examples

- ```"Row@12;Column@4;Description@.*k1A.*"```
- ```"Row@256;Column@500;SliceLocation@23;SliceThickness@0.5"```
- ```"Row@256;Column@500;Some@thing#Row@256;Column@501;Another@thing"```
- ```"Row@0;Column@5#Row@4;Column@5#Row@8;Column@5#Row@12;Column@5"```

#### PreDecimateOutSizeR

##### Description

The number of pixels along the row unit vector to group into an outgoing pixel. This optional step can reduce
computation effort by downsampling (decimating) images before computing fitted parameter maps (but *after* computing AIF
and VIF time courses). Must be a multiplicative factor of the incoming image's row count. No decimation occurs if either
this or 'PreDecimateOutSizeC' is zero or negative.

##### Default

- ```"8"```

##### Examples

- ```"0"```
- ```"2"```
- ```"4"```
- ```"8"```
- ```"16"```
- ```"32"```
- ```"64"```
- ```"128"```
- ```"256"```
- ```"512"```

#### PreDecimateOutSizeC

##### Description

The number of pixels along the column unit vector to group into an outgoing pixel. This optional step can reduce
computation effort by downsampling (decimating) images before computing fitted parameter maps (but *after* computing AIF
and VIF time courses). Must be a multiplicative factor of the incoming image's column count. No decimation occurs if
either this or 'PreDecimateOutSizeR' is zero or negative.

##### Default

- ```"8"```

##### Examples

- ```"0"```
- ```"2"```
- ```"4"```
- ```"8"```
- ```"16"```
- ```"32"```
- ```"64"```
- ```"128"```
- ```"256"```
- ```"512"```

#### TargetROINameRegex

##### Description

Regex for the name of the ROI to perform modeling within. The largest contour is usually what you want, but you can also
be more focused.

##### Default

- ```".*Body.*"```

##### Examples

- ```"Liver_Patches_For_Testing_Smaller"```
- ```"Liver_Patches_For_Testing"```
- ```"Suspected_Liver_Rough"```
- ```"Rough_Body"```
- ```".*body.*"```
- ```".*something.*\|.*another.*thing.*"```

#### UseBasisSplineInterpolation

##### Description

Control whether the AIF and VIF should use basis spline interpolation in conjunction with the Chebyshev polynomial
method. If this option is not set, linear interpolation is used instead. Linear interpolation may result in a
less-smooth AIF and VIF (and therefore possibly slower optimizer convergence), but is safer if you cannot verify the AIF
and VIF plots are reasonable. This option currently produces an effect only if the Chebyshev polynomial method is being
used.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```

#### BasisSplineCoefficients

##### Description

Control the number of basis spline coefficients to use, if applicable. (This setting does nothing when basis splines are
not being used.) Valid options for this setting depend on the amount of data and b-spline order. This number controls
the number of coefficients that are fitted (via least-squares). You must verify that overfitting is not happening. If in
doubt, use fewer coefficients. There are two ways to specify the number: relative and absolute. Relative means relative
to the number of datum. For example, if the AIF and VIF have ~40 datum then generally '*0.5' is safe. ('*0.5' means
there are half the number of coefficients as datum.) Inspect for overfitting and poor fit. Because this routine happens
once and is fast, do not tweak to optimize for speed; the aim of this method is to produce a smooth and accurate AIF and
VIF. Because an integer number of coefficients are needed, so rounding is used. You can also specify the absolute number
of coefficients to use like '20'. It often makes more sense to use relative specification. Be aware that not all inputs
can be honoured due to limits on b-spline knots and breaks, and may cause unpredictable behaviour or internal failure.

##### Default

- ```"*0.5"```

##### Examples

- ```"*0.8"```
- ```"*0.5"```
- ```"*0.3"```
- ```"20.0"```
- ```"10.0"```

#### BasisSplineOrder

##### Description

Control the polynomial order of basis spline interpolation to use, if applicable. (This setting does nothing when basis
splines are not being used.) This parameter controls the order of polynomial used for b-spline interpolation, and
therefore has ramifications for the computability and numerical stability of AIF and VIF derivatives. Stick with '4' or
'5' if you're unsure.

##### Default

- ```"4"```

##### Examples

- ```"1"```
- ```"2"```
- ```"3"```
- ```"4"```
- ```"5"```
- ```"6"```
- ```"7"```
- ```"8"```
- ```"9"```
- ```"10"```

#### ChebyshevPolyCoefficients

##### Description

Control the number of Chebyshev polynomial coefficients to use, if applicable. (This setting does nothing when the
Chebyshev polynomial method is not being used.) This number controls the number of coefficients that are computed. There
are two ways to specify the number: relative and absolute. Relative means relative to the number of datum. For example,
if the AIF and VIF have ~40 datum then generally '*2' is safe. ('*2' means there are 2x the number of coefficients as
datum; usually overkill.) A good middle-ground is '*1' which is faster but should produce similar results. For speed
'/2' is even faster, but can produce bad results in some cases. Because an integer number of coefficients are needed,
rounding is used. You can also specify the absolute number of coefficients to use like '20'. It often makes more sense
to use relative specification. Be aware that not all inputs can be honoured (i.e., too large, too small, or negative),
and may cause unpredictable behaviour or internal failure.

##### Default

- ```"*2.0"```

##### Examples

- ```"*10.0"```
- ```"*5.0"```
- ```"*2.0"```
- ```"*1.23"```
- ```"*1.0"```
- ```"/1.0"```
- ```"/2.0"```
- ```"/3.0"```
- ```"/5.0"```
- ```"100.0"```
- ```"50.0"```
- ```"20"```
- ```"10.01"```

#### VIFROINameRegex

##### Description

Regex for the name of the ROI to use as the VIF. It should generally be a major vein near the trunk or near the tissue
of interest.

##### Default

- ```"Hepatic_Portal_Vein"```

##### Examples

- ```"Hepatic_Portal_Vein"```
- ```".*Portal.*Vein.*"```
- ```"Major_Vein"```


----------------------------------------------------

## CellularAutomata

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing
- category: simulation

### Description

This operation implements 2D cellular automata (Conway's Game of Life) with periodic boundary conditions.

### Notes

- The provided image collection must be rectilinear. All images will be modeled independently of one another.

### Parameters

- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Channel
- Method
- Iterations
- Low
- High

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Channel

##### Description

The channel to operated on (zero-based). Negative values will cause all channels to be operated on.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```

#### Method

##### Description

Controls the type of automata to simulate.

##### Default

- ```"conway's-game-of-life"```

##### Supported Options

- ```"conway's-game-of-life"```
- ```"gravity-down"```
- ```"gravity-up"```
- ```"gravity-left"```
- ```"gravity-right"```
- ```"gravity-in"```
- ```"gravity-out"```

#### Iterations

##### Description

The number of iterations to simulate. Note that intermediary iterations are not retained.

##### Default

- ```"1"```

##### Examples

- ```"1"```
- ```"10"```
- ```"1000"```

#### Low

##### Description

The voxel value that represents 'dead' cells. Since cells are either 'alive' or 'dead', the value halfway between the
low and high values is used as the threshold.

##### Default

- ```"0.0"```

##### Examples

- ```"0.0"```
- ```"-1.23"```
- ```"10.0"```

#### High

##### Description

The voxel value that represents 'alive' cells. Since cells are either 'alive' or 'dead', the value halfway between the
low and high values is used as the threshold.

##### Default

- ```"1.0"```

##### Examples

- ```"1.5"```
- ```"-0.23"```
- ```"255.0"```


----------------------------------------------------

## ClusterDBSCAN

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This routine performs DBSCAN clustering on an image volume. The clustering is limited within ROI(s) and also within a
range of voxel intensities. Voxels values are overwritten with the cluster ID (if applicable) or a generic configurable
background value.

### Notes

- This operation will work with single images and image volumes. Images need not be rectilinear.

### Parameters

- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- ContourOverlap
- Inclusivity
- Channel
- Lower
- Upper
- MinPoints
- MaxPoints
- Eps
- BackgroundValue
- Reduction

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. The option 'honour_opposite_orientations' makes overlapping contours with opposite
orientation cancel. Otherwise, orientation is ignored. The latter is useful for Boolean structures where contour
orientation is significant for interior contours (holes). The option 'overlapping_contours_cancel' ignores orientation
and cancels all contour overlap.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### Channel

##### Description

The channel to operated on (zero-based). Negative values will cause all channels to be operated on.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```

#### Lower

##### Description

Lower threshold (inclusive) below which voxels will be ignored by this routine.

##### Default

- ```"-inf"```

##### Examples

- ```"-inf"```
- ```"0.0"```
- ```"1024"```

#### Upper

##### Description

Upper threshold (inclusive) above which voxels will be ignored by this routine.

##### Default

- ```"inf"```

##### Examples

- ```"inf"```
- ```"1.0"```
- ```"2048"```

#### MinPoints

##### Description

DBSCAN algorithm parameter representing the minimum number of points that must appear in the vicinity for a cluster to
be recognized. Sanders, et al. (1998) recommend a default of twice the dimensionality, but what is considered to be a
reasonable value depends on the sparsity of the inputs and geometry. For regular grids, a slightly smaller value might
be more appropriate.

##### Default

- ```"5"```

##### Examples

- ```"4"```
- ```"6"```
- ```"15"```

#### MaxPoints

##### Description

Reject clusters if they would contain more than this many members. This parameter can be used to reject irrelevant
background clusters or to help search for disconnected clusters. Setting this parameter appropriately will improve both
memory usage and runtime considerably.

##### Default

- ```"inf"```

##### Examples

- ```"10"```
- ```"1000"```
- ```"1E6"```
- ```"inf"```

#### Eps

##### Description

DBSCAN algorithm parameter representing the threshold separation distance (in DICOM units; mm) between members of a
cluster. All members in a cluster must be separated from at least MinPoints points within a distance of Eps. There is a
standard way to determine an optimal value from the data itself, but requires generating a k-nearest-neighbours
clustering first, and then visually identifying an appropriate 'kink' in the k-distances plot. This approach is not
implemented here. Alternatively, the sparsity of the data and the specific problem domain must be used to estimate a
desirable separation Eps.

##### Default

- ```"4.0"```

##### Examples

- ```"1.5"```
- ```"2.5"```
- ```"4.0"```
- ```"10.0"```

#### BackgroundValue

##### Description

The voxel intensity that will be assigned to all voxels that are not members of a cluster. Note that this value can be
anything, but cluster numbers are zero-based, so a negative background is probably desired.

##### Default

- ```"-1.0"```

##### Examples

- ```"-1.0"```
- ```"0.0"```
- ```"100.23"```
- ```"nan"```
- ```"-inf"```

#### Reduction

##### Description

Voxels within a cluster can be marked as-is, or reduced in a variety of ways. If reduction is not used, voxels in a
valid cluster will have their values replaced with the cluster ID number. If 'median' reduction is specified, the
component-wise median is reported for each cluster; the x-, y-, and z-coordinates of all voxels in each individual
cluster will be reduced to the median coordinate.

##### Default

- ```"none"```

##### Supported Options

- ```"none"```
- ```"median"```


----------------------------------------------------

## CombineImages

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation combines the images in two or more image arrays, creating a single image array containing all images.

### Notes

- The original image arrays are removed and all images are placed into a image array appended at the end.

- Individual images (e.g., those that are spatially overlapping) are not merged together. No voxel resampling or
  combination is performed.

### Parameters

- ImageSelection

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"first"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## CombineMeshes

### Tags

- accepts parameter: surface meshes
- category: mesh processing

### Description

This operation deep-copies the selected surface meshes, combining all into a single mesh.

### Notes

- This operation does *not* implement 3D boolean operations. Using it can lead to mesh intersections and
  non-manifoldness, so it is best suited for visualization or as part of a controlled explode-alter-combine workflow.

### Parameters

- MeshSelection
- MeshLabel

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### MeshLabel

##### Description

A label to attach to the combined surface mesh.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"body"```
- ```"air"```
- ```"bone"```
- ```"invalid"```
- ```"above_zero"```
- ```"below_5.3"```


----------------------------------------------------

## ComparePixels

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This operation compares images ('test' images and 'reference' images) on a per-voxel/per-pixel basis. Any combination of
2D and 3D images is supported, including images which do not fully overlap, but the reference image array must be
rectilinear (this property is verified).

### Notes

- Images are overwritten, but ReferenceImages are not. Multiple Images may be specified, but only one ReferenceImages
  may be specified.

- The reference image array must be rectilinear. (This is a requirement specific to this implementation, a less
  restrictive implementation could overcome the issue.)

- For the fastest and most accurate results, test and reference image arrays should spatially align. However, alignment
  is **not** necessary. If test and reference image arrays are aligned, image adjacency can be precomputed and the
  analysis will be faster. If not, image adjacency must be evaluated for every voxel.

- The distance-to-agreement comparison will tend to overestimate the distance, especially when the DTA value is low,
  because voxel size effects will dominate the estimation. Reference images should be supersampled as necessary.

- This operation optionally makes use of interpolation for sub-voxel distance estimation. However, interpolation is
  currently limited to be along the edges connecting nearest- and next-nearest voxel centres. In other words, true
  volumetric interpolation is **not** available. Implicit interpolation is also used (via the intermediate value
  theorem) for the distance-to-agreement comparison, which results in distance estimation that may vary up to the
  largest caliper distance of a voxel. For this reason, the accuracy of all comparisons should be expected to be limited
  by image spatial resolution (i.e., voxel dimensions). Reference images should be supersampled as necessary.

### Parameters

- ImageSelection
- ReferenceImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Method
- Channel
- TestImgLowerThreshold
- TestImgUpperThreshold
- RefImgLowerThreshold
- RefImgUpperThreshold
- DiscType
- DTAVoxValEqAbs
- DTAVoxValEqRelDiff
- DTAMax
- DTAInterpolationMethod
- GammaDTAThreshold
- GammaDiscThreshold
- GammaTerminateAboveOne

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ReferenceImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Method

##### Description

The comparison method to compute. Three options are currently available: distance-to-agreement (DTA), discrepancy, and
gamma-index. All three are fully 3D, but can also work for 2D or mixed 2D-3D comparisons. DTA is a measure of how far
away the nearest voxel (in the reference images) is with a voxel intensity sufficiently close to each voxel in the test
images. This comparison ignores pixel intensities except to test if the values match within the specified tolerance. The
voxel neighbourhood is exhaustively explored until a suitable voxel is found. Implicit interpolation is used to detect
when the value could be found via interpolation, but explicit interpolation is not used. Thus distance might be
overestimated. A discrepancy comparison measures the point intensity discrepancy without accounting for spatial shifts.
A gamma analysis combines distance-to-agreement and point differences into a single index which is best used to test if
both DTA and discrepancy criteria are satisfied (gamma <= 1 iff both pass). It was proposed by Low et al. in 1998
((doi:10.1118/1.598248). Gamma analyses permits trade-offs between spatial and dosimetric discrepancies which can arise
when the image arrays slightly differ in alignment or pixel values.

##### Default

- ```"gamma-index"```

##### Supported Options

- ```"gamma-index"```
- ```"DTA"```
- ```"discrepancy"```

#### Channel

##### Description

The channel to compare (zero-based). Note that both test images and reference images will share this specifier.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"2"```

#### TestImgLowerThreshold

##### Description

Pixel lower threshold for the test images. Only voxels with values above this threshold (inclusive) will be altered.

##### Default

- ```"-inf"```

##### Examples

- ```"-inf"```
- ```"0.0"```
- ```"200"```

#### TestImgUpperThreshold

##### Description

Pixel upper threshold for the test images. Only voxels with values below this threshold (inclusive) will be altered.

##### Default

- ```"inf"```

##### Examples

- ```"inf"```
- ```"1.23"```
- ```"1000"```

#### RefImgLowerThreshold

##### Description

Pixel lower threshold for the reference images. Only voxels with values above this threshold (inclusive) will be
altered.

##### Default

- ```"-inf"```

##### Examples

- ```"-inf"```
- ```"0.0"```
- ```"200"```

#### RefImgUpperThreshold

##### Description

Pixel upper threshold for the reference images. Only voxels with values below this threshold (inclusive) will be
altered.

##### Default

- ```"inf"```

##### Examples

- ```"inf"```
- ```"1.23"```
- ```"1000"```

#### DiscType

##### Description

Parameter for all comparisons estimating the direct, voxel-to-voxel discrepancy. There are currently three types
available. 'Relative' is the absolute value of the difference of two voxel values divided by the largest of the two
values. 'Difference' is the difference of two voxel values. 'PinnedToMax' is the absolute value of the difference of two
voxel values divided by the largest voxel value in the selected images.

##### Default

- ```"relative"```

##### Supported Options

- ```"relative"```
- ```"difference"```
- ```"pinned-to-max"```

#### DTAVoxValEqAbs

##### Description

Parameter for all comparisons involving a distance-to-agreement (DTA) search. The difference in voxel values considered
to be sufficiently equal (absolute; in voxel intensity units). Note: This value CAN be zero. It is meant to help
overcome noise. Note that this value is ignored by all interpolation methods.

##### Default

- ```"1.0E-3"```

##### Examples

- ```"1.0E-3"```
- ```"1.0E-5"```
- ```"0.0"```
- ```"0.5"```

#### DTAVoxValEqRelDiff

##### Description

Parameter for all comparisons involving a distance-to-agreement (DTA) search. The difference in voxel values considered
to be sufficiently equal (~relative difference; in %). Note: This value CAN be zero. It is meant to help overcome noise.
Note that this value is ignored by all interpolation methods.

##### Default

- ```"1.0"```

##### Examples

- ```"0.1"```
- ```"1.0"```
- ```"10.0"```

#### DTAMax

##### Description

Parameter for all comparisons involving a distance-to-agreement (DTA) search. Maximally acceptable distance-to-agreement
(in DICOM units: mm) above which to stop searching. All voxels within this distance will be searched unless a matching
voxel is found. Note that a gamma-index comparison may terminate this search early if the gamma-index is known to be
greater than one. It is recommended to make this value approximately 1 voxel width larger than necessary in case a
matching voxel can be located near the boundary. Also note that some voxels beyond the DTA_max distance may be
evaluated.

##### Default

- ```"30.0"```

##### Examples

- ```"3.0"```
- ```"5.0"```
- ```"50.0"```

#### DTAInterpolationMethod

##### Description

Parameter for all comparisons involving a distance-to-agreement (DTA) search. Controls how precisely and how often the
space between voxel centres are interpolated to identify the exact position of agreement. There are currently three
options: no interpolation ('None'), nearest-neighbour ('NN'), and next-nearest-neighbour ('NNN'). (1) If no
interpolation is selected, the agreement position will only be established to within approximately the reference image
voxels dimensions. To avoid interpolation, voxels that straddle the target value are taken as the agreement distance.
Conceptually, if you view a voxel as having a finite spatial extent then this method may be sufficient for distance
assessment. Though it is not precise, it is fast. This method will tend to over-estimate the actual distance, though it
is possible that it slightly under-estimates it. This method works best when the reference image grid size is small in
comparison to the desired spatial accuracy (e.g., if computing gamma, the tolerance should be much larger than the
largest voxel dimension) so supersampling is recommended. (2) Nearest-neighbour interpolation considers the line
connecting directly adjacent voxels. Using linear interpolation along this line when adjacent voxels straddle the target
value, the 3D point where the target value appears can be predicted. This method can significantly improve distance
estimation accuracy, though will typically be much slower than no interpolation. On the other hand, this method lower
amounts of supersampling, though it is most reliable when the reference image grid size is small in comparison to the
desired spatial accuracy. Note that nearest-neighbour interpolation also makes use of the 'no interpolation' methods. If
you have a fine reference image, prefer either no interpolation or nearest-neighbour interpolation. (3) Finally,
next-nearest-neighbour considers the diagonally-adjacent neighbours separated by taxi-cab distance of 2 (so in-plane
diagonals are considered, but 3D diagonals are not). Quadratic (i.e., bi-linear) interpolation is analytically solved to
determine where along the straddling diagonal the target value appears. This method is more expensive than linear
interpolation but will generally result in more accurate distance estimates. This method may require lower amounts of
supersampling than linear interpolation, but is most reliable when the reference image grid size is small in comparison
to the desired spatial accuracy. Use of this method may not be appropriate in all cases considering that supersampling
may be needed and a quadratic equation is solved for every voxel diagonal. Note that next-nearest-neighbour
interpolation also makes use of the nearest-neighbour and 'no interpolation' methods.

##### Default

- ```"NN"```

##### Supported Options

- ```"None"```
- ```"NN"```
- ```"NNN"```

#### GammaDTAThreshold

##### Description

Parameter for gamma-index comparisons. Maximally acceptable distance-to-agreement (in DICOM units: mm). When the
measured DTA is above this value, the gamma index will necessarily be greater than one. Note this parameter can differ
from the DTA_max search cut-off, but should be <= to it.

##### Default

- ```"5.0"```

##### Examples

- ```"3.0"```
- ```"5.0"```
- ```"10.0"```

#### GammaDiscThreshold

##### Description

Parameter for gamma-index comparisons. Voxel value discrepancies lower than this value are considered acceptable, but
values above will result in gamma values >1. The specific interpretation of this parameter (and the units) depend on the
specific type of discrepancy used. For percentage-based discrepancies, this parameter is interpretted as a percentage
(i.e., '5.0' = '5%'). For voxel intensity measures such as the absolute difference, this value is interpretted as an
absolute threshold with the same intensity units (i.e., '5.0' = '5 HU' or similar).

##### Default

- ```"5.0"```

##### Examples

- ```"3.0"```
- ```"5.0"```
- ```"10.0"```

#### GammaTerminateAboveOne

##### Description

Parameter for gamma-index comparisons. Halt spatial searching if the gamma index will necessarily indicate failure
(i.e., gamma >1). Note this can parameter can drastically reduce the computational effort required to compute the gamma
index, but the reported gamma values will be invalid whenever they are >1. This is often tolerable since the magnitude
only matters when it is <1. In lieu of the true gamma-index, a value slightly >1 will be assumed.

##### Default

- ```"true"```

##### Examples

- ```"true"```
- ```"false"```


----------------------------------------------------

## CompileScript

### Tags

- category: meta
- category: scripting

### Description

This operation can be used to parse, optionally validate, and optionally run a DICOMautomaton script.

### Parameters

- Filename
- Actions

#### Filename

##### Description

The name of a file containing the script.

##### Default

- ```""```

##### Examples

- ```"script.dscr"```
- ```"/path/to/script.dscr"```

#### Actions

##### Description

The actions to perform on or using the script. Current options are 'parse', 'validate', and 'run'.

The 'parse' action loads the script and attempts to parse it. An abstract syntax tree is constructed, but no warnings,
errors, or feedback is provided. The script is not actually executed. In this mode, the return value indicates whether
parsing errors were detected.

The 'validate' action parses the script, then prints out warnings, errors, and notices. The script is not actually
executed. In this mode, the return value indicates whether validation errors were detected (note: warnings are ignored).
Note that 'lint' and 'compile' are currently synonyms for 'validate'.

The 'run' action parses and validates the script, then immediately executes it. In this mode, the return value indicates
two things: (1) that there were no errors detected during the parsing and validation steps, and (2) the return value of
the operations. Note that 'execute' is a synonym for 'run'.

##### Default

- ```"validate"```

##### Supported Options

- ```"parse"```
- ```"validate"```
- ```"lint"```
- ```"compile"```
- ```"run"```
- ```"execute"```


----------------------------------------------------

## ContourBasedRayCastDoseAccumulate

### Tags

- accepts parameter: contours
- category: file export
- category: image processing
- category: radiation dose
- category: simulation

### Description

This operation performs ray-casting to estimate the dose of a surface. The surface is represented as a set of contours
(i.e., an ROI).

### Parameters

- DoseLengthMapFileName
- LengthMapFileName
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- CylinderRadius
- RaydL
- Rows
- Columns

#### DoseLengthMapFileName

##### Description

A filename (or full path) for the (dose)*(length traveled through the ROI peel) image map. The format is TBD. Leave
empty to dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.img"```
- ```"derivative_data.img"```

#### LengthMapFileName

##### Description

A filename (or full path) for the (length traveled through the ROI peel) image map. The format is TBD. Leave empty to
dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.img"```
- ```"derivative_data.img"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### CylinderRadius

##### Description

The radius of the cylinder surrounding contour line segments that defines the 'surface'. Quantity is in the DICOM
coordinate system.

##### Default

- ```"3.0"```

##### Examples

- ```"1.0"```
- ```"2.0"```
- ```"0.5"```
- ```"5.0"```

#### RaydL

##### Description

The distance to move a ray each iteration. Should be << img_thickness and << cylinder_radius. Making too large will
invalidate results, causing rays to pass through the surface without registering any dose accumulation. Making too small
will cause the run-time to grow and may eventually lead to truncation or round-off errors. Quantity is in the DICOM
coordinate system.

##### Default

- ```"0.1"```

##### Examples

- ```"0.1"```
- ```"0.05"```
- ```"0.01"```
- ```"0.005"```

#### Rows

##### Description

The number of rows in the resulting images.

##### Default

- ```"256"```

##### Examples

- ```"10"```
- ```"50"```
- ```"128"```
- ```"1024"```

#### Columns

##### Description

The number of columns in the resulting images.

##### Default

- ```"256"```

##### Examples

- ```"10"```
- ```"50"```
- ```"128"```
- ```"1024"```


----------------------------------------------------

## ContourBooleanOperations

### Tags

- category: contour processing

### Description

This routine performs 2D Boolean operations on user-provided sets of ROIs. The ROIs themselves are planar contours
embedded in R^3, but the Boolean operation is performed once for each 2D plane where the selected ROIs reside. This
routine can only perform Boolean operations on co-planar contours. This routine can operate on single contours (rather
than ROIs composed of several contours) by simply presenting this routine with a single contour to select.

### Notes

- Contour ROI regex matches comprise the sets 'A' and 'B', as in f(A,B) where f is the Boolean operation.

- This routine DOES support disconnected ROIs, such as left- and right-parotid contours that have been joined into a
  single 'parotids' ROI.

- Many Boolean operations can produce contours with holes. This operation currently connects the interior and exterior
  with a seam so that holes can be represented by a single polygon (rather than a separate hole polygon). It *is*
  possible to export holes as contours with a negative orientation, but this was not needed when writing.

- Only the common metadata between contours is propagated to the product contours.

### Parameters

- NormalizedROILabelRegexA
- ROILabelRegexA
- NormalizedROILabelRegexB
- ROILabelRegexB
- Operation
- OutputROILabel

#### NormalizedROILabelRegexA

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegexA

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### NormalizedROILabelRegexB

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegexB

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### Operation

##### Description

The Boolean operation (e.g., the function 'f') to perform on the sets of contour polygons 'A' and 'B'. 'Symmetric
difference' is also known as 'XOR'.

##### Default

- ```"join"```

##### Supported Options

- ```"intersection"```
- ```"join"```
- ```"difference"```
- ```"symmetric_difference"```

#### OutputROILabel

##### Description

The label to attach to the ROI contour product of f(A,B).

##### Default

- ```"Boolean_result"```

##### Examples

- ```"A+B"```
- ```"A-B"```
- ```"AuB"```
- ```"AnB"```
- ```"AxB"```
- ```"A^B"```
- ```"union"```
- ```"xor"```
- ```"combined"```
- ```"body_without_spinal_cord"```


----------------------------------------------------

## ContourSimilarity

### Tags

- accepts parameter: images
- category: contour processing

### Description

This operation estimates the similarity or overlap between two sets of contours. The comparison is based on point
samples. It is useful for comparing contouring styles. This operation currently reports Dice and Jaccard similarity
metrics.

### Notes

- This routine requires an image grid, which is used to control where the contours are sampled. Images are not modified.

### Parameters

- ImageSelection
- ROILabelRegexA
- NormalizedROILabelRegexA
- ROILabelRegexB
- NormalizedROILabelRegexB
- FileName
- UserComment

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ROILabelRegexA

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### NormalizedROILabelRegexA

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegexB

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### NormalizedROILabelRegexB

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### FileName

##### Description

A filename (or full path) in which to append similarity data generated by this routine. The format is CSV. Leave empty
to dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```


----------------------------------------------------

## ContourViaGeometry

### Tags

- accepts parameter: images
- category: contour processing

### Description

This operation constructs ROI contours using geometrical primitives.

### Notes

- This routine requires an image array onto which the contours will be written.

- This routine expects images to be non-overlapping. In other words, if images overlap then the contours generated may
  also overlap. This is probably not what you want (but there is nothing intrinsically wrong with presenting this
  routine with multiple images if you intentionally want overlapping contours).

- Existing contours are ignored and unaltered.

- Small and degenerate contours produced by this routine are suppressed. If a specific number of contours must be
  generated, provide a slightly larger radius to compensate for the degenerate cases at the extrema.

### Parameters

- ROILabel
- ImageSelection
- Shapes

#### ROILabel

##### Description

A label to attach to the ROI contours.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"body"```
- ```"air"```
- ```"bone"```
- ```"invalid"```
- ```"above_zero"```
- ```"below_5.3"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Shapes

##### Description

This parameter is used to specify the shapes to consider. There is currently a single supported shape: sphere. However,
it is likely that more shapes will be accepted in the future. Spheres have two configurable parameters: centre and
radius. A sphere with centre (1.0,2.0,3.0) and radius 12.3 can be specified as 'sphere(1.0, 2.0, 3.0, 12.3)'.

##### Default

- ```""```

##### Examples

- ```"sphere(-1.0, 2.0, 3.0,  12.3)"```


----------------------------------------------------

## ContourViaThreshold

### Tags

- accepts parameter: images
- category: contour processing

### Description

This operation constructs ROI contours using images and pixel/voxel value thresholds. There are three methods of contour
generation available: a simple binary method in which voxels are either fully in or fully out of the contour, marching
squares (which uses linear interpolation to give smooth contours), and a method based on 3D marching cubes that will
also provide smooth contours. The marching cubes method does **not** construct a full surface mesh; rather each
individual image slice has their own mesh constructed in parallel.

### Aliases

- ConvertImagesToContours

### Notes

- This routine expects images to be non-overlapping. In other words, if images overlap then the contours generated may
  also overlap. This is probably not what you want (but there is nothing intrinsically wrong with presenting this
  routine with multiple images if you intentionally want overlapping contours).

- Existing contours are ignored and unaltered.

- Contour orientation is (likely) not properly handled in this routine, so 'pinches' and holes will produce contours
  with inconsistent or invalid topology. If in doubt, disable merge simplifications and live with the computational
  penalty. The marching cubes approach will properly handle 'pinches' and contours should all be topologically valid.

- Note that the marching-squares method currently only honours the lower threshold.

### Parameters

- ROILabel
- Lower
- Upper
- Channel
- ImageSelection
- Method
- SimplifyMergeAdjacent

#### ROILabel

##### Description

A label to attach to the ROI contours.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"body"```
- ```"air"```
- ```"bone"```
- ```"invalid"```
- ```"above_zero"```
- ```"below_5.3"```

#### Lower

##### Description

The lower bound (inclusive). Pixels with values < this number are excluded from the ROI. If the number is followed by a
'%', the bound will be scaled between the min and max pixel values [0-100%]. If the number is followed by 'tile', the
bound will be replaced with the corresponding percentile [0-100tile]. Both percentages and percentiles are assessed per
image array. Note that upper and lower bounds can be specified separately (e.g., lower bound is a percentage, but upper
bound is a percentile).

##### Default

- ```"-inf"```

##### Examples

- ```"0.0"```
- ```"-1E-99"```
- ```"1.23"```
- ```"0.2%"```
- ```"23tile"```
- ```"23.123 tile"```

#### Upper

##### Description

The upper bound (inclusive). Pixels with values > this number are excluded from the ROI. If the number is followed by a
'%', the bound will be scaled between the min and max pixel values [0-100%]. If the number is followed by 'tile', the
bound will be replaced with the corresponding percentile [0-100tile]. Both percentages and percentiles are assessed per
image array. Note that upper and lower bounds can be specified separately (e.g., lower bound is a percentage, but upper
bound is a percentile).

##### Default

- ```"inf"```

##### Examples

- ```"1.0"```
- ```"1E-99"```
- ```"2.34"```
- ```"98.12%"```
- ```"94tile"```
- ```"94.123 tile"```

#### Channel

##### Description

The image channel to use. Zero-based.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"2"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Method

##### Description

There are currently three supported methods for generating contours: (1) a simple (and fast) 'binary' inclusivity
checker, that simply checks if a voxel is within the ROI by testing the value at the voxel centre, (2) the
'marching-squares' method, which samples the corners of every voxel and uses linear interpolation to estimate the
threshold value isoline crossings, and (3) a robust but slow method based on 'marching-cubes'. The binary method is
fast, but produces extremely jagged contours. It may also have problems with 'pinches' and topological consistency.
Marching-squares is reasonably fast and general-purpose, and should produce good quality contours that approximate the
threshold value isocurves to first-order. It also handles boundaries well by inserting an extra virtual row and column
around the image to ensure contours are all closed. The marching-cubes method is more robust and should reliably produce
contours for even the most complicated topologies, but is considerably slower than the binary method. It may produce
worse on boundaries, though otherwise it should produce the same contours as marching-squares.

##### Default

- ```"binary"```

##### Supported Options

- ```"binary"```
- ```"marching-squares"```
- ```"marching-cubes"```

#### SimplifyMergeAdjacent

##### Description

Simplify contours by merging adjacent contours. This reduces the number of contours dramatically, but will cause issues
if there are holes (two contours are generated if there is a single hole, but most DICOMautomaton code disregards
orientation -- so the pixels within the hole will be considered part of the ROI, possibly even doubly so depending on
the algorithm). Disabling merges is always safe (and is therefore the default) but can be extremely costly for large
images. Furthermore, if you know the ROI does not have holes (or if you don't care) then it is safe to enable merges.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```


----------------------------------------------------

## ContourVote

### Tags

- accepts parameter: contours
- category: contour processing

### Description

This routine pits contours against one another using various criteria. A number of 'closest' or 'best' or 'winning'
contours are copied into a new contour collection with the specified ROILabel. The original ROIs are not altered, even
the winning ROIs.

### Notes

- This operation considers individual contours only at the moment. It could be extended to operate on whole ROIs (i.e.,
  contour_collections), or to perform a separate vote within each ROI. The individual contour approach was taken for
  relevance in 2D image (e.g., RTIMAGE) analysis.

- This operation currently cannot perform voting on multiple criteria. Several criteria could be specified, but an
  awkward weighting system would also be needed.

### Parameters

- WinnerROILabel
- ROILabelRegex
- NormalizedROILabelRegex
- Area
- Perimeter
- CentroidX
- CentroidY
- CentroidZ
- WinnerCount

#### WinnerROILabel

##### Description

The ROI label to attach to the winning contour(s). All other metadata remains the same.

##### Default

- ```"unspecified"```

##### Examples

- ```"closest"```
- ```"best"```
- ```"winners"```
- ```"best-matches"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### Area

##### Description

If this option is provided with a valid positive number, the contour(s) with an area closest to the specified value
is/are retained. Note that the DICOM coordinate space is used. (Supplying the default, NaN, will disable this option.)
Note: if several criteria are specified, it is not specified in which order they are considered.

##### Default

- ```"nan"```

##### Examples

- ```"nan"```
- ```"100.0"```
- ```"1000"```
- ```"10.23E8"```

#### Perimeter

##### Description

If this option is provided with a valid positive number, the contour(s) with a perimeter closest to the specified value
is/are retained. Note that the DICOM coordinate space is used. (Supplying the default, NaN, will disable this option.)
Note: if several criteria are specified, it is not specified in which order they are considered.

##### Default

- ```"nan"```

##### Examples

- ```"nan"```
- ```"0.0"```
- ```"123.456"```
- ```"1E6"```

#### CentroidX

##### Description

If this option is provided with a valid positive number, the contour(s) with a centroid closest to the specified value
is/are retained. Note that the DICOM coordinate space is used. (Supplying the default, NaN, will disable this option.)
Note: if several criteria are specified, it is not specified in which order they are considered.

##### Default

- ```"nan"```

##### Examples

- ```"nan"```
- ```"0.0"```
- ```"123.456"```
- ```"-1E6"```

#### CentroidY

##### Description

If this option is provided with a valid positive number, the contour(s) with a centroid closest to the specified value
is/are retained. Note that the DICOM coordinate space is used. (Supplying the default, NaN, will disable this option.)
Note: if several criteria are specified, it is not specified in which order they are considered.

##### Default

- ```"nan"```

##### Examples

- ```"nan"```
- ```"0.0"```
- ```"123.456"```
- ```"-1E6"```

#### CentroidZ

##### Description

If this option is provided with a valid positive number, the contour(s) with a centroid closest to the specified value
is/are retained. Note that the DICOM coordinate space is used. (Supplying the default, NaN, will disable this option.)
Note: if several criteria are specified, it is not specified in which order they are considered.

##### Default

- ```"nan"```

##### Examples

- ```"nan"```
- ```"0.0"```
- ```"123.456"```
- ```"-1E6"```

#### WinnerCount

##### Description

Retain this number of 'best' or 'winning' contours.

##### Default

- ```"1"```

##### Examples

- ```"0"```
- ```"1"```
- ```"3"```
- ```"10000"```


----------------------------------------------------

## ContourWholeImages

### Tags

- accepts parameter: images
- category: contour processing
- category: image processing

### Description

This operation constructs contours for an ROI that encompasses voxels of the specified images. It is useful for
operations that operate on ROIs whenever you want to compute something over the whole image. This routine avoids having
to manually contour.

### Notes

- This routine will attempt to avoid repeat contours. Generated contours are tested for intersection with an image
  before the image is processed.

- Existing contours are ignored and unaltered.

### Parameters

- ROILabel
- ImageSelection
- EncircleMethod

#### ROILabel

##### Description

A label to attach to the ROI contours.

##### Default

- ```"everything"```

##### Examples

- ```"everything"```
- ```"whole_images"```
- ```"unspecified"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### EncircleMethod

##### Description

The method used to generate the ROI contours. Options include 'whole' and 'FOV'.

The default option, 'whole', makes contours that encircle all voxels. Contours are set slightly inside the outer
boundary so they can be easily visualized by overlaying on an image. All voxel centres will be within the ROI contours.

Option 'FOV' uses image metadata (if available) to only encircle image voxels which are within the scanned field of
view. In practice, this will be a large circle centred on the middle of an image.

##### Default

- ```"whole"```

##### Examples

- ```"whole"```
- ```"FOV"```


----------------------------------------------------

## ContouringAides

### Tags

- category: image processing

### Description

This operation attempts to prepare an image for easier contouring.

### Notes

- At the moment, only logarithmic scaling is applied.

### Parameters

No registered options.

----------------------------------------------------

## ConvertContoursToMeshes

### Tags

- accepts parameter: contours
- category: contour processing
- category: mesh processing

### Description

This routine creates a mesh from contours. There are four supported methods:

- 'direct', which stitches together contours (polygons) by finding a correspondence between adjacent contours and
zippering them together;

- 'marching', which uses contours to first generate an image mask and then uses Marching Cubes to extract a mesh;

- 'convex-hull', which builds the convex hull around the provided contours; and

- 'contours', which converts the contours into thin triangle strips.

The 'direct' method, when it can be used appropriately, should be significantly faster than meshing via voxelization
(e.g., marching cubes). It will also insert few (or zero) additional vertices on the original contour planes, meaning
the resulting mesh can be sliced to give (nearly) the exact original contours. However, please note that the 'direct'
method is not robust and should only be expected to work for simple, sphere-like contours (i.e., convex polyhedra and
mostly-convex polyhedra with only small concavities; see notes for additional information).

The 'marching' method is robust, but slow since it requires conversion to an intermediate bitmask. There is also a loss
of spatial resolution due to use of bitmasks.

The 'convex-hull' method is reasonably accurate, but scales poorly. It will also provide a zero-volume (i.e.,
non-manifold) surface if only a single contour is present.

The 'contours' method will not produce a manifold surface mesh, but will symmetrically extrude each contour to make a
thin strip. This method is best suited for display purposes.

### Notes

- The 'direct' method is experimental and currently relies on simple heuristics to find an adjacent contour
  correspondence.

- Using the 'direct' method, meshes sliced on the same planes as the original contours *should* reproduce the original
  contours (barring numerical instabilities). In between the original slices, the mesh may exhibit distortions or
  obviously invalid correspondence with adjacent contours. Using the 'marching' method, contours may vary somewhat.

- For the 'direct' method, mesh 'pairing' on adjacent slices is evaluated using a mutual overlap heuristic. The
  following adjacent slice pairing scenarios are supported: 1-0, 1-1, N-0, N-1, and N-M (for any N and M greater than
  1). Adjacent contours with inconsistent orientations will either be reordered or wholly disregarded. For N-0, N-1, and
  N-M pairings all contours in N (and M) are fused using with a simple distance heuristic; the fusion bridges are
  extended off the original contour plane so that mesh slicing will recover the original contours. For 1-0 and N-0
  pairings the 'hole' is filled by placing a single vertex offset from the occupied contour plane from the centroid and
  connecting all vertices; mesh slicing should also recover the original contours in this case.

- For the 'direct' method, overlapping contours **on the same plane** are **not** currently supported. Only the contour
  with the largest area will be retained.

- The 'direct' method should only be expected to work for simple, sphere-like geometries (i.e., convex polyhedra). Some
  concavities can be tolerated, but not all. For example, tori can only be meshed if the 'hole' is oriented away from
  the contour normal. (Otherwise the 'hole' produces concentric contours -- which are not supported.) Contours
  representing convex polyhedra **should** result in manifold meshes, though they may not be watertight and if contour
  vertices are degenerate (or too close together numerically) meshes will fail to remain manifold.

- The 'convex-hull' method uses an algorithm that scales poorly, especially when the contours are mostly convex (and
  thus have many vertices on the hull).

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- MeshLabel
- Method

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### MeshLabel

##### Description

A label to attach to the surface mesh.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"body"```
- ```"air"```
- ```"bone"```
- ```"invalid"```
- ```"above_zero"```
- ```"below_5.3"```

#### Method

##### Description

There are currently three supported methods: 'direct' -- a simplistic but fast contour stitching method; 'marching' -- a
method that first converts contours to a binary bitmask and then uses Marching Cubes to extract meshes; and
'convex-hull' -- a robust routine that only works for convex contours. See operation description and notes for more
details.

##### Default

- ```"direct"```

##### Supported Options

- ```"direct"```
- ```"marching"```
- ```"convex-hull"```
- ```"contours"```


----------------------------------------------------

## ConvertContoursToPoints

### Tags

- accepts parameter: contours
- category: contour processing
- category: point cloud processing

### Description

This operation extracts vertices from the selected contours and converts them into a point cloud. Contours are not
modified.

### Notes

- Existing point clouds are ignored and unaltered.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Label
- Method

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Label

##### Description

A label to attach to the point cloud.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"POIs"```
- ```"peaks"```
- ```"above_zero"```
- ```"below_5.3"```

#### Method

##### Description

The conversion method to use. Two options are available: 'vertices' and 'centroid'. The 'vertices' option extracts all
vertices from all selected contours and directly inserts them into the new point cloud. Point clouds created this way
will contain as many points as there are contour vertices. The 'centroid' option finds the centroid of all vertices from
all selected contours. Note that the centroid gives every point an equal weighting, so heterogeneous contour vertex
density will shift the position of the centroid (unless the distribution is symmetric about the centroid, which should
roughly be the case for spherical contour collections). Point clouds created this way will contain a single point.

##### Default

- ```"vertices"```

##### Supported Options

- ```"vertices"```
- ```"centroid"```


----------------------------------------------------

## ConvertDoseToImage

### Tags

- category: image processing
- category: radiation dose

### Description

This operation converts all loaded images from RTDOSE modality to CT modality. Image contents will not change, but the
intent to treat as an image or dose matrix will of course change.

### Parameters

- Modality

#### Modality

##### Description

The modality that will replace 'RTDOSE'.

##### Default

- ```"CT"```

##### Examples

- ```"CT"```
- ```"MR"```
- ```"UNKNOWN"```


----------------------------------------------------

## ConvertImageToDose

### Tags

- category: image processing
- category: radiation dose

### Description

This operation converts all loaded image modalities into RTDOSE. Image contents will not change, but the intent to treat
as an image or dose matrix will of course change.

### Parameters

No registered options.

----------------------------------------------------

## ConvertImageToMeshes

### Tags

- accepts parameter: images
- category: image processing
- category: mesh processing

### Description

This operation extracts surface meshes from images and pixel/voxel value thresholds. Meshes are appended to the back of
the Surface_Mesh stack. There are three methods of mesh extract available: (1) a simple 'binary' method in which voxels
are either fully in or fully out of the contour, (2) a method based on 'marching' cubes that will provide smoother
contours, and (3) a purely 'geometrical' method that extracts only the shape and extent of images but does not use the
pixel intensities. Both pixel-based methods (2) and (3) make use of marching cubes -- the binary method involves
pre-processing.

### Notes

- This routine requires images to be regular (i.e., exactly abut nearest adjacent images without any overlap).

### Parameters

- ImageSelection
- Lower
- Upper
- Channel
- Method
- MeshLabel

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Lower

##### Description

The lower bound (inclusive). Pixels with values < this number are excluded from the ROI. If the number is followed by a
'%', the bound will be scaled between the min and max pixel values [0-100%]. If the number is followed by 'tile', the
bound will be replaced with the corresponding percentile [0-100tile]. Note that upper and lower bounds can be specified
separately (e.g., lower bound is a percentage, but upper bound is a percentile). Note that computed bounds (i.e.,
percentages and percentiles) consider the entire image volume.

##### Default

- ```"-inf"```

##### Examples

- ```"0.0"```
- ```"-1E-99"```
- ```"1.23"```
- ```"0.2%"```
- ```"23tile"```
- ```"23.123 tile"```

#### Upper

##### Description

The upper bound (inclusive). Pixels with values > this number are excluded from the ROI. If the number is followed by a
'%', the bound will be scaled between the min and max pixel values [0-100%]. If the number is followed by 'tile', the
bound will be replaced with the corresponding percentile [0-100tile]. Note that upper and lower bounds can be specified
separately (e.g., lower bound is a percentage, but upper bound is a percentile). Note that computed bounds (i.e.,
percentages and percentiles) consider the entire image volume.

##### Default

- ```"inf"```

##### Examples

- ```"1.0"```
- ```"1E-99"```
- ```"2.34"```
- ```"98.12%"```
- ```"94tile"```
- ```"94.123 tile"```

#### Channel

##### Description

The image channel to use. Zero-based.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"2"```

#### Method

##### Description

There are currently three supported methods for generating meshes:

1. A simple (and fast) binary inclusivity checker, that simply checks if a voxel is within an ROI by testing the value
at the voxel centre. This method is fast, but produces extremely jagged contours. It may also have problems with
'pinches' and topological consistency.

2. A robust (but comparatively slower) method based on marching cubes. This method is more robust than the binary method
and should reliably produce meshes for even the most complicated topologies. It is expected to run slower than the
binary method.

3. A method that only extracts the geometrical aspects of images, including orientation, position, and spatial extent.
This method does not use pixel intensities. It is useful for inspecting or debugging spatial alignment.

##### Default

- ```"marching"```

##### Supported Options

- ```"binary"```
- ```"marching"```
- ```"geometrical"```

#### MeshLabel

##### Description

A label to attach to the surface mesh.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"body"```
- ```"air"```
- ```"bone"```
- ```"invalid"```
- ```"above_zero"```
- ```"below_5.3"```


----------------------------------------------------

## ConvertImageToWarp

### Tags

- accepts parameter: images
- category: image processing
- category: spatial transform processing

### Description

This operation attempts to convert an image array into a warp (i.e., a spatial registration or deformable spatial
registration).

### Notes

- This operation creates a deformation field transformation. The input images are required to have three channels and be
  regular.

### Parameters

- ImageSelection
- KeyValues

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### KeyValues

##### Description

Key-value pairs in the form of 'key1@value1;key2@value2' that will be injected into the selected objects. Values can use
macros that refer to other metadata keys using the '$' character. If macros refer to non-existent metadata elements,
then the replacement is literal. Dates, times, and datetimes can be converted to seconds (since the Unix epoch) using
the 'to_seconds()' function.

Existing conflicting metadata will be overwritten. Both keys and values are case-sensitive. Note that a semi-colon
separates key-value pairs, not a colon. Note that quotation marks are not stripped internally, but may have to be
provided on the command line for shells to properly interpret the argument. Also note that updating spatial metadata
will not result in the object characteristics being altered -- use the specific parameters provided to update spatial
characteristics.

##### Default

- ```""```

##### Examples

- ```"Description@'some description'"```
- ```"'Description@some description'"```
- ```"'Description@Research scan performed on $ContentDate'"```
- ```"'ContentTimeInSeconds@to_seconds($ContentDate-$ContentDate)'"```
- ```"MinimumSeparation@1.23"```
- ```"'Description@some description;MinimumSeparation@1.23'"```


----------------------------------------------------

## ConvertMeshesToContours

### Tags

- accepts parameter: images
- accepts parameter: surface meshes
- category: contour processing
- category: mesh processing

### Description

This operation constructs ROI contours by slicing the given meshes on a set of image planes.

### Notes

- Surface meshes should represent polyhedra.

- This routine does **not** require images to be regular, rectilinear, or even contiguous.

- Images and meshes are unaltered. Existing contours are ignored and unaltered.

- Contour orientation is (likely) not guaranteed to be consistent in this routine.

### Parameters

- ROILabel
- MeshSelection
- ImageSelection

#### ROILabel

##### Description

A label to attach to the ROI contours.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"body"```
- ```"air"```
- ```"bone"```
- ```"invalid"```
- ```"above_zero"```
- ```"below_5.3"```

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## ConvertMeshesToPoints

### Tags

- accepts parameter: surface meshes
- category: mesh processing
- category: point cloud processing

### Description

This operation converts meshes to point clouds.

### Notes

- Meshes are unaltered. Existing point clouds are ignored and unaltered.

### Parameters

- MeshSelection
- Label
- Method
- RandomSeed
- RandomSampleDensity

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Label

##### Description

A label to attach to the point cloud.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"POIs"```
- ```"peaks"```
- ```"above_zero"```
- ```"below_5.3"```

#### Method

##### Description

The conversion method to use. Two options are currently available: 'vertices' and 'random'. The 'vertices' option
extracts all vertices from all selected meshes and directly inserts them into the new point cloud. Point clouds created
this way will contain as many points as there are mesh vertices. The 'random' option samples the surface mesh uniformly.
The likelihood of specific a face being sampled is proportional to its area. This method requires a target sample
density, which determines the number of samples taken; this density is an average over the entire mesh surface area, and
individual samples may have less or more separation from neighbouring samples. Note that the 'random' method will tend
to result in clusters of samples and pockets without samples. This is unavoidable when sampling randomly. The 'random'
method accepts two parameters: a pseudo-random number generator seed and the desired sample density.

##### Default

- ```"vertices"```

##### Supported Options

- ```"vertices"```
- ```"random"```

#### RandomSeed

##### Description

A parameter for the 'random' method: the seed used for the random surface sampling method.

##### Default

- ```"1595813"```

##### Examples

- ```"25633"```
- ```"20771"```
- ```"271"```
- ```"1006003"```
- ```"11"```
- ```"3511"```

#### RandomSampleDensity

##### Description

A parameter for the 'random' method: the target sample density (as samples/area where area is in DICOM units, nominally
$mm^{-2}$)). This parameter effectively controls the total number of samples. Note that the sample density is averaged
over the entire surface, so individual samples may cluster or spread out and develop pockets.

##### Default

- ```"1.0"```

##### Examples

- ```"0.1"```
- ```"0.5"```
- ```"1.0"```
- ```"5.0"```
- ```"10.0"```


----------------------------------------------------

## ConvertNaNsToAir

### Tags

- category: image processing

### Description

This operation runs the data through a per-pixel filter, converting NaN's to air in Hounsfield units (-1024).

### Parameters

No registered options.

----------------------------------------------------

## ConvertNaNsToZeros

### Tags

- category: image processing

### Description

This operation runs the data through a per-pixel filter, converting NaN's to zeros.

### Parameters

No registered options.

----------------------------------------------------

## ConvertParametersToTable

### Tags

- accepts parameter: tables
- category: parameter table
- category: table processing

### Description

Convert one or more key-value parameters from the global parameter table into a table. If no table is selected, a new
table will be created. If an existing table is selected, row(s) will be appended to the bottom.

### Parameters

- KeySelection
- TableSelection
- TableLabel
- EmitHeader
- Shape

#### KeySelection

##### Description

A regular expression that will select key-values to include in the table.

This regular expression will be applied only to keys. Note that multiple keys can be selected; whether they are emitted
on one or multiple rows is controlled by the 'Shape' parameter.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```"a_specific_key"```
- ```"^a_specific_prefix.*"```

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TableLabel

##### Description

A label to attach to table if and only if a new table is created.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"xyz"```
- ```"sheet A"```

#### EmitHeader

##### Description

Controls whether a header (consisting of the key names) is emitted. If 'false' no header is emitted. If 'true', two rows
are emitted regardless of whether there is a pre-existing header. If 'empty', a header is only emitted when the table is
empty (i.e., no content in any cells). Consistency of the emitted row with the existing table content and structure is
not verified and is therefore left to the user.

##### Default

- ```"empty"```

##### Supported Options

- ```"true"```
- ```"false"```
- ```"empty"```

#### Shape

##### Description

Controls whether the table is written in 'wide' or 'tall' format.

The 'wide' shape places all output from a single invocation onto a single row (or two if a header is also emitted). This
format is most useful for analysis since the relationship between metadata elements can be analyzed more easily (e.g.,
regression or classification).

The 'tall' shape places every metadata key-value pair on a separate row. This format is most useful for simplistic data
extraction or simple analysis where the relationship between metadata elements is not important (e.g., grepping for a
specific key-value, checking if one-of-any tags are present).

##### Default

- ```"wide"```

##### Supported Options

- ```"wide"```
- ```"tall"```


----------------------------------------------------

## ConvertPixelsToPoints

### Tags

- accepts parameter: images
- category: image processing
- category: point cloud processing

### Description

This operation extracts pixels from the selected images and converts them into a point cloud. Images are not modified.

### Notes

- Existing point clouds are ignored and unaltered.

### Parameters

- Label
- Lower
- Upper
- Channel
- ImageSelection

#### Label

##### Description

A label to attach to the point cloud.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"POIs"```
- ```"peaks"```
- ```"above_zero"```
- ```"below_5.3"```

#### Lower

##### Description

The lower bound (inclusive). Pixels with values < this number are excluded from the ROI. If the number is followed by a
'%', the bound will be scaled between the min and max pixel values [0-100%]. If the number is followed by 'tile', the
bound will be replaced with the corresponding percentile [0-100tile]. Note that upper and lower bounds can be specified
separately (e.g., lower bound is a percentage, but upper bound is a percentile).

##### Default

- ```"-inf"```

##### Examples

- ```"0.0"```
- ```"-1E-99"```
- ```"1.23"```
- ```"0.2%"```
- ```"23tile"```
- ```"23.123 tile"```

#### Upper

##### Description

The upper bound (inclusive). Pixels with values > this number are excluded from the ROI. If the number is followed by a
'%', the bound will be scaled between the min and max pixel values [0-100%]. If the number is followed by 'tile', the
bound will be replaced with the corresponding percentile [0-100tile]. Note that upper and lower bounds can be specified
separately (e.g., lower bound is a percentage, but upper bound is a percentile).

##### Default

- ```"inf"```

##### Examples

- ```"1.0"```
- ```"1E-99"```
- ```"2.34"```
- ```"98.12%"```
- ```"94tile"```
- ```"94.123 tile"```

#### Channel

##### Description

The image channel to use. Zero-based.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"2"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## ConvertWarpToImage

### Tags

- category: image processing
- category: spatial transform processing

### Description

This operation attempts to convert a warp (i.e., a spatial registration or deformable spatial registration) to an image
array suitable for viewing or inspecting the geometry.

### Parameters

- TransformSelection
- KeyValues

#### TransformSelection

##### Description

Select one or more transform objects (aka 'warp' objects). Selection specifiers can be of three types: positional,
metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth transformation (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last transformation.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the transformation composed of the greatest and fewest number of sub-objects. Only one or zero transformation
will be selected; if there are ties, there is no guarantee which transformation will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple transformation based on a threshold count, i.e., where all selected transformation
have more than or fewer than $N$ sub-objects. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all transformation that do not have the greatest number of sub-objects, not the least-numerous
transformation (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```

#### KeyValues

##### Description

Key-value pairs in the form of 'key1@value1;key2@value2' that will be injected into the selected objects. Values can use
macros that refer to other metadata keys using the '$' character. If macros refer to non-existent metadata elements,
then the replacement is literal. Dates, times, and datetimes can be converted to seconds (since the Unix epoch) using
the 'to_seconds()' function.

Existing conflicting metadata will be overwritten. Both keys and values are case-sensitive. Note that a semi-colon
separates key-value pairs, not a colon. Note that quotation marks are not stripped internally, but may have to be
provided on the command line for shells to properly interpret the argument. Also note that updating spatial metadata
will not result in the object characteristics being altered -- use the specific parameters provided to update spatial
characteristics.

##### Default

- ```""```

##### Examples

- ```"Description@'some description'"```
- ```"'Description@some description'"```
- ```"'Description@Research scan performed on $ContentDate'"```
- ```"'ContentTimeInSeconds@to_seconds($ContentDate-$ContentDate)'"```
- ```"MinimumSeparation@1.23"```
- ```"'Description@some description;MinimumSeparation@1.23'"```


----------------------------------------------------

## ConvertWarpToMeshes

### Tags

- category: mesh processing
- category: spatial transform processing

### Description

This operation attempts to convert a warp (i.e., a spatial registration or deformable spatial registration) to a mesh
suitable for viewing or inspecting the geometry.

### Parameters

- TransformSelection
- VoxelCadence
- RemoveRigid
- KeyValues

#### TransformSelection

##### Description

Select one or more transform objects (aka 'warp' objects). Selection specifiers can be of three types: positional,
metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth transformation (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last transformation.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the transformation composed of the greatest and fewest number of sub-objects. Only one or zero transformation
will be selected; if there are ties, there is no guarantee which transformation will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple transformation based on a threshold count, i.e., where all selected transformation
have more than or fewer than $N$ sub-objects. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all transformation that do not have the greatest number of sub-objects, not the least-numerous
transformation (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```

#### VoxelCadence

##### Description

The number of voxels to skip over. This can be used to reduce the number of triangles in the resulting mesh. Prefer
prime numbers distant to the number of rows, columns, images, and multiples of all three to minimize
bunching/clustering. Set to negative or zero to display all voxels.

##### Default

- ```"7"```

##### Examples

- ```"0"```
- ```"7"```
- ```"71"```
- ```"197"```
- ```"313"```
- ```"971"```
- ```"1663"```
- ```"3739"```

#### RemoveRigid

##### Description

If enabled, this option subtracts off any rigid component of a deformation field. The rigid component is estimated by
averaging all vectors and can misrepresent the true rigid component if the perhiphery are inconsistent with the
transformation in a sub-volume. Nevertheless, this option can help remove large translations that otherwise would make
visualization challenging.

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```

#### KeyValues

##### Description

Key-value pairs in the form of 'key1@value1;key2@value2' that will be injected into the selected objects. Values can use
macros that refer to other metadata keys using the '$' character. If macros refer to non-existent metadata elements,
then the replacement is literal. Dates, times, and datetimes can be converted to seconds (since the Unix epoch) using
the 'to_seconds()' function.

Existing conflicting metadata will be overwritten. Both keys and values are case-sensitive. Note that a semi-colon
separates key-value pairs, not a colon. Note that quotation marks are not stripped internally, but may have to be
provided on the command line for shells to properly interpret the argument. Also note that updating spatial metadata
will not result in the object characteristics being altered -- use the specific parameters provided to update spatial
characteristics.

##### Default

- ```""```

##### Examples

- ```"Description@'some description'"```
- ```"'Description@some description'"```
- ```"'Description@Research scan performed on $ContentDate'"```
- ```"'ContentTimeInSeconds@to_seconds($ContentDate-$ContentDate)'"```
- ```"MinimumSeparation@1.23"```
- ```"'Description@some description;MinimumSeparation@1.23'"```


----------------------------------------------------

## ConvolveImages

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This routine convolves, correlates, or pattern-matches one rectilinear image array with another in voxel number space
(i.e., the DICOM coordinate system of the convolution kernel image is entirely disregarded).

### Notes

- Both provided image arrays must be rectilinear. In many instances they should both be regular, not just rectilinear,
  but rectilinearity is sufficient for constructing voxel-by-voxel adjacency relatively quickly, and some applications
  may require rectilinear kernels to be supported, so rectilinear inputs are permitted.

- This operation can be used to apply arbitrary convolution kernels to an image array. It can also be used to search for
  instances of one image array in another.

- If the magnitude of the outgoing voxels will be interpretted in absolute (i.e., thresholding based on an absolute
  magnitude) then the kernel should be weighted so that the sum of all kernel voxel intensities is zero. This will
  maintain the average voxel intensity. However, for pattern matching the kernel need not be normalized (though it may
  make interpretting partial matches easier.)

### Parameters

- ImageSelection
- ReferenceImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Channel
- Operation

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ReferenceImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Channel

##### Description

The channel to operate on (zero-based). Negative values will cause all channels to be operated on.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```

#### Operation

##### Description

Controls the way the kernel is applied and the reduction is tallied. Currently, 'convolution', 'correlation', and
'pattern-match' are supported. For convolution, the reference image is spatially inverted along row-, column-, and
image-axes. The outgoing voxel intensity is the inner (i.e., dot) product of the paired intensities of the surrounding
voxel neighbourhood (i.e., the voxel at (-1,3,0) from the centre of the kernel is paired with the neighbouring voxel at
(-1,3,0) from the current/outgoing voxel). For pattern-matching, the difference between the kernel and each voxel's
neighbourhood voxels is compared using a 2-norm (i.e., Euclidean) cost function. With this cost function, a perfect,
pixel-for-pixel match (i.e., if the kernel images appears exactly in the image being transformed) will result in the
outgoing voxel having zero intensity (i.e., zero cost). For correlation, the kernel is applied as-is (just like
pattern-matching), but the inner product of the paired voxel neighbourhood intensities is reported (just like
convolution). In all cases the kernel is (approximately) centred.

##### Default

- ```"convolution"```

##### Supported Options

- ```"convolution"```
- ```"correlation"```
- ```"pattern-match"```


----------------------------------------------------

## CopyContours

### Tags

- accepts parameter: contours
- category: contour processing

### Description

This operation deep-copies the selected contours.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- ROILabel

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ROILabel

##### Description

A label to attach to the copied ROI contours.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"copy"```
- ```"duplicate"```
- ```"bone"```
- ```"roi_xyz"```


----------------------------------------------------

## CopyImages

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation deep-copies the selected image arrays.

### Parameters

- ImageSelection

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## CopyLineSamples

### Tags

- accepts parameter: line samples
- category: line sample processing

### Description

This operation deep-copies the selected line samples.

### Parameters

- LineSelection

#### LineSelection

##### Description

Select one or more line samples. Selection specifiers can be of three types: positional, metadata-based key@value regex,
and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth line sample (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last line sample.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the line sample composed of the greatest and fewest number of samples. Only one or zero line sample will be
selected; if there are ties, there is no guarantee which line sample will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple line sample based on a threshold count, i.e., where all selected line sample have
more than or fewer than $N$ samples. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all line sample that do not have the greatest number of samples, not the least-numerous line sample (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## CopyMeshes

### Tags

- accepts parameter: surface meshes
- category: mesh processing

### Description

This operation deep-copies the selected surface meshes.

### Parameters

- MeshSelection

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## CopyPoints

### Tags

- accepts parameter: point clouds
- category: point cloud processing

### Description

This operation deep-copies the selected point clouds.

### Parameters

- PointSelection

#### PointSelection

##### Description

Select one or more point clouds. Note that point clouds can hold a variety of data with varying attributes, but each
point cloud is meant to represent a single logically cohesive collection of points. Be aware that it is possible to mix
logically unrelated points together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## CopyTables

### Tags

- accepts parameter: tables
- category: table processing

### Description

This operation deep-copies the selected tables.

### Parameters

- TableSelection

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## CountObjects

### Tags

- accepts parameter: contours
- accepts parameter: images
- accepts parameter: line samples
- accepts parameter: point clouds
- accepts parameter: surface meshes
- accepts parameter: tables
- category: meta

### Description

This operation is a meta-operatio that counts the number of selected objects and stores the result in the global
parameter table. It can be used to control for loops and test for the presence of data to make conditional program
flows.

### Notes

- Multiple selection criteria can be provided. If multiple criteria are specified, this operation returns the total
  number of objects selected.

- This operation is read-only and produces no side-effects. It does not alter the selection.

- Selectors for this operation are only considered when you explicitly provide them. The default values are not used by
  this operation.

### Parameters

- Key
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- ImageSelection
- LineSelection
- MeshSelection
- PointSelection
- TableSelection

#### Key

##### Description

The key used to insert the object count into the key-value global parameter table.

##### Default

- ```"unspecified"```

##### Examples

- ```"count"```
- ```"N"```
- ```"x"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### LineSelection

##### Description

Select one or more line samples. Selection specifiers can be of three types: positional, metadata-based key@value regex,
and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth line sample (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last line sample.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the line sample composed of the greatest and fewest number of samples. Only one or zero line sample will be
selected; if there are ties, there is no guarantee which line sample will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple line sample based on a threshold count, i.e., where all selected line sample have
more than or fewer than $N$ samples. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all line sample that do not have the greatest number of samples, not the least-numerous line sample (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### PointSelection

##### Description

Select one or more point clouds. Note that point clouds can hold a variety of data with varying attributes, but each
point cloud is meant to represent a single logically cohesive collection of points. Be aware that it is possible to mix
logically unrelated points together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## CountVoxels

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: acquires futex
- category: file export
- category: image processing

### Description

This operation counts the number of voxels confined to one or more ROIs within a user-provided range.

### Notes

- This operation is read-only.

### Parameters

- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Inclusivity
- ContourOverlap
- Lower
- Upper
- Channel
- ResultsSummaryFileName
- UserComment

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. The option 'honour_opposite_orientations' makes overlapping contours with opposite
orientation cancel. Otherwise, orientation is ignored. The latter is useful for Boolean structures where contour
orientation is significant for interior contours (holes). The option 'overlapping_contours_cancel' ignores orientation
and cancels all contour overlap.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Lower

##### Description

The lower bound (inclusive). Pixels with values < this number are excluded from the ROI. If the number is followed by a
'%', the bound will be scaled between the min and max pixel values [0-100%]. If the number is followed by 'tile', the
bound will be replaced with the corresponding percentile [0-100tile]. Note that upper and lower bounds can be specified
separately (e.g., lower bound is a percentage, but upper bound is a percentile).

##### Default

- ```"-inf"```

##### Examples

- ```"0.0"```
- ```"-1E-99"```
- ```"1.23"```
- ```"0.2%"```
- ```"23tile"```
- ```"23.123 tile"```

#### Upper

##### Description

The upper bound (inclusive). Pixels with values > this number are excluded from the ROI. If the number is followed by a
'%', the bound will be scaled between the min and max pixel values [0-100%]. If the number is followed by 'tile', the
bound will be replaced with the corresponding percentile [0-100tile]. Note that upper and lower bounds can be specified
separately (e.g., lower bound is a percentage, but upper bound is a percentile).

##### Default

- ```"inf"```

##### Examples

- ```"1.0"```
- ```"1E-99"```
- ```"2.34"```
- ```"98.12%"```
- ```"94tile"```
- ```"94.123 tile"```

#### Channel

##### Description

The image channel to use. Zero-based.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"2"```

#### ResultsSummaryFileName

##### Description

This file will contain a brief summary of the results. The format is CSV. Leave empty to dump to generate a unique
temporary file. If an existing file is present, rows will be appended without writing a header.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```


----------------------------------------------------

## CropImageDoseToROIs

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing
- category: radiation dose

### Description

This operation crops image slices to the specified ROI(s), with an additional margin.

### Parameters

- DICOMMargin
- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### DICOMMargin

##### Description

The amount of margin (in the DICOM coordinate system) to surround the ROI(s).

##### Default

- ```"0.5"```

##### Examples

- ```"0.1"```
- ```"2.0"```
- ```"-0.5"```
- ```"20.0"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## CropImages

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation crops image slices in either pixel or DICOM coordinate spaces.

### Parameters

- ImageSelection
- RowsL
- RowsH
- ColumnsL
- ColumnsH
- DICOMMargin

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### RowsL

##### Description

The number of rows to remove, starting with the first row. Can be absolute (px), percentage (%), or distance in terms of
the DICOM coordinate system. Note the DICOM coordinate system can be flipped, so the first row can be either on the top
or bottom of the image.

##### Default

- ```"0px"```

##### Examples

- ```"0px"```
- ```"10px"```
- ```"100px"```
- ```"15%"```
- ```"15.75%"```
- ```"123.45"```

#### RowsH

##### Description

The number of rows to remove, starting with the last row. Can be absolute (px), percentage (%), or distance in terms of
the DICOM coordinate system. Note the DICOM coordinate system can be flipped, so the first row can be either on the top
or bottom of the image.

##### Default

- ```"0px"```

##### Examples

- ```"0px"```
- ```"10px"```
- ```"100px"```
- ```"15%"```
- ```"15.75%"```
- ```"123.45"```

#### ColumnsL

##### Description

The number of columns to remove, starting with the first column. Can be absolute (px), percentage (%), or distance in
terms of the DICOM coordinate system. Note the DICOM coordinate system can be flipped, so the first column can be either
on the top or bottom of the image.

##### Default

- ```"0px"```

##### Examples

- ```"0px"```
- ```"10px"```
- ```"100px"```
- ```"15%"```
- ```"15.75%"```
- ```"123.45"```

#### ColumnsH

##### Description

The number of columns to remove, starting with the last column. Can be absolute (px), percentage (%), or distance in
terms of the DICOM coordinate system. Note the DICOM coordinate system can be flipped, so the first column can be either
on the top or bottom of the image.

##### Default

- ```"0px"```

##### Examples

- ```"0px"```
- ```"10px"```
- ```"100px"```
- ```"15%"```
- ```"15.75%"```
- ```"123.45"```

#### DICOMMargin

##### Description

The amount of margin (in the DICOM coordinate system) to spare from cropping.

##### Default

- ```"0.0"```

##### Examples

- ```"0.1"```
- ```"2.0"```
- ```"-0.5"```
- ```"20.0"```


----------------------------------------------------

## CropROIDose

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing
- category: radiation dose

### Description

This operation provides a simplified interface for overriding voxel values outside a ROI. For example, this operation
can be used to modify a base plan by eliminating dose outside an OAR.

### Notes

- This operation performs the opposite of the 'Trim' operation, which trims voxel values **inside** a ROI.

- The inclusivity of a voxel that straddles the ROI boundary can be specified in various ways. Refer to the Inclusivity
  parameter documentation.

### Parameters

- Channel
- ImageSelection
- ContourOverlap
- Inclusivity
- Method
- ExteriorVal
- InteriorVal
- ExteriorOverwrite
- InteriorOverwrite
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- ImageSelection
- Filename
- ParanoiaLevel

#### Channel

##### Description

The image channel to use. Zero-based. Use '-1' to operate on all available channels.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. This will effectively honour only the outermost contour regardless of orientation,
but provides the most predictable and consistent results. The option 'honour_opposite_orientations' makes overlapping
contours with opposite orientation cancel. Otherwise, orientation is ignored. This is useful for Boolean structures
where contour orientation is significant for interior contours (holes). If contours do not have consistent overlap
(e.g., if contours intersect) the results can be unpredictable and hard to interpret. The option
'overlapping_contours_cancel' ignores orientation and alternately cancerls all overlapping contours. Again, if the
contours do not have consistent overlap (e.g., if contours intersect) the results can be unpredictable and hard to
interpret.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"planar_inc"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### Method

##### Description

Controls the type of image mask that is generated. The default, 'binary', exclusively overwrites voxels with the
InteriorValue or ExteriorValue. Another method is 'receding_squares' which creates a mask which, if processed with the
marching-squares algorithm, will (mostly) recreate the original contours. The 'receding_squares' can be considered the
inverse of the marching-squares algorithm. Note that the 'receding_squares' implementation is not optimized for speed.

##### Default

- ```"binary"```

##### Supported Options

- ```"binary"```
- ```"receding_squares"```

#### ExteriorVal

##### Description

The value to give to voxels outside the specified ROI(s). For the 'binary' method, note that this value will be ignored
if exterior overwrites are disabled. For the 'receding_squares' method this value is used to define the threshold needed
to recover the original contours (mean of InteriorVal and ExteriorVal).

##### Default

- ```"0.0"```

##### Examples

- ```"0.0"```
- ```"-1.0"```
- ```"1.23"```
- ```"2.34E26"```

#### InteriorVal

##### Description

The value to give to voxels within the specified ROI(s). For the 'binary' method, note that this value will be ignored
if interior overwrites are disabled. For the 'receding_squares' method this value is used to define the threshold needed
to recover the original contours (mean of InteriorVal and ExteriorVal).

##### Default

- ```"0.0"```

##### Examples

- ```"0.0"```
- ```"-1.0"```
- ```"1.23"```
- ```"2.34E26"```

#### ExteriorOverwrite

##### Description

Whether to overwrite voxels exterior to the specified ROI(s).

##### Default

- ```"true"```

##### Supported Options

- ```"true"```
- ```"false"```

#### InteriorOverwrite

##### Description

Whether to overwrite voxels interior to the specified ROI(s).

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

The filename (or full path name) to which the DICOM file should be written.

##### Default

- ```"/tmp/RD.dcm"```

##### Examples

- ```"/tmp/RD.dcm"```
- ```"./RD.dcm"```
- ```"RD.dcm"```

#### ParanoiaLevel

##### Description

At low paranoia setting, only top-level UIDs are replaced. At medium paranoia setting, many UIDs, descriptions, and
labels are replaced, but the PatientID and FrameOfReferenceUID are retained. The high paranoia setting is the same as
the medium setting, but the PatientID and FrameOfReferenceUID are also replaced. (Note: this is not a full
anonymization.) Use the low setting if you want to retain linkage to the originating data set. Use the medium setting if
you don't. Use the high setting if your TPS goes overboard linking data sets by PatientID and/or FrameOfReferenceUID.

##### Default

- ```"medium"```

##### Supported Options

- ```"low"```
- ```"medium"```
- ```"high"```


----------------------------------------------------

## DCEMRI_IAUC

### Tags

- category: diffusion
- category: image processing

### Description

This operation will compute the Integrated Area Under the Curve (IAUC) for any images present.

### Notes

- This operation is not optimized in any way and operates on whole images. It can be fairly slow, especially if the
  image volume is huge, so it is best to crop images if possible.

### Parameters

No registered options.

----------------------------------------------------

## DCEMRI_Nonparametric_CE

### Tags

- category: diffusion
- category: image processing

### Description

This operation takes a single DCE-MRI scan ('measurement') and generates a "poor-mans's" contrast enhancement signal.
This is accomplished by subtracting the pre-contrast injection images average ('baseline') from later images (and then
possibly/optionally averaging relative to the baseline).

### Notes

- Only a single image volume is required. It is expected to have temporal sampling beyond the contrast injection
  timepoint (or some default value -- currently around ~30s). The resulting images retain the baseline portion, so
  you'll need to trim yourself if needed.

- Be aware that this method of deriving contrast enhancement is not valid! It ignores nuances due to differing T1 or T2
  values due to the presence of contrast agent. It should only be used for exploratory purposes or cases where the
  distinction with reality is irrelevant.

### Parameters

No registered options.

----------------------------------------------------

## DICOMExportContours

### Tags

- accepts parameter: contours
- category: contour processing
- category: file export

### Description

This operation exports the selected contours to a DICOM RTSTRUCT-modality file.

### Notes

- There are various 'paranoia' levels that can be used to partially de-identify / anonymize the output for purposes of
  retaining or breaking linkage to originating data sets.. Note that the 'paranoia' option is **not** sufficient to
  de-identify / anonymize data since other tags may contain personally identifying information. Beyond metadata and
  UIDs, personally identifying information may still be found by a determined individual via inspection of the contour
  vertex data. **Do not rely on this routine to de-identify / anonymize data.**

### Parameters

- Filename
- ParanoiaLevel
- Encoding
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### Filename

##### Description

The filename (or full path name) to which the DICOM file should be written.

##### Default

- ```"/tmp/RTSTRUCT.dcm"```

##### Examples

- ```"/tmp/RTSTRUCT.dcm"```
- ```"./RTSTRUCT.dcm"```
- ```"RTSTRUCT.dcm"```

#### ParanoiaLevel

##### Description

Controls how metadata is emitted.

At the `low` paranoia setting, top-level UIDs are replaced. Use the `low` setting if you want to retain linkage to the
originating data set.

At low `medium` paranoia setting, many UIDs, descriptions, and labels are replaced, but the PatientID and
FrameOfReferenceUID are retained. Use the `medium` setting if you do not want to retain linkage to the originating data
set.

The low `high` paranoia setting is the same as the `medium` setting, but the PatientID and FrameOfReferenceUID are also
replaced. Use the `high` setting if your treatment planning system or other processing software goes overboard linking
data sets using (possibly only) PatientID and/or FrameOfReferenceUID.

##### Default

- ```"medium"```

##### Supported Options

- ```"low"```
- ```"medium"```
- ```"high"```

#### Encoding

##### Description

Controls the transfer syntax of the emitted DICOM file. Options include `explicit` and `implicit`.

`Explicit` transfer syntax directly encodes the DICOM Value Representation (VR) types of tags, which can make them
appropriate for distribution and archival. However, `explicit` transfer syntax imposes limits on some VR types (e.g.,
maximum string length) and will likely produce larger files than `implicit` transfer syntax.

`Implicit` transfer syntax does not encode the DICOM VR, instead writing tags in a standardized way. However, the DICOM
dictionary, which codifies this encoding, may differ from implementation to implementation or over time. `Implicit`
transfer syntax will likely produce smaller files than `explicit` transfer syntax, but there is increased risk of data
misinterpretation.

Note that little-endian encoding is always used.

##### Default

- ```"explicit"```

##### Supported Options

- ```"explicit"```
- ```"implicit"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## DICOMExportImagesAsCT

### Tags

- accepts parameter: images
- category: file export
- category: image processing

### Description

This operation exports the selected Image_Array(s) to DICOM CT-modality files.

### Notes

- There are various 'paranoia' levels that can be used to partially anonymize the output. In particular, most metadata
  and UIDs are replaced, but the files may still be recognized by a determined individual by comparing the coordinate
  system and pixel values. Do NOT rely on this routine to fully anonymize the data!

### Parameters

- ImageSelection
- Filename
- ParanoiaLevel

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

The filename (or full path name) to which the DICOM files should be written. The file format is a gzipped-TAR file
containing multiple CT-modality files.

##### Default

- ```"CTs.tgz"```

##### Examples

- ```"/tmp/CTs.tgz"```
- ```"./CTs.tar.gz"```
- ```"CTs.tgz"```

#### ParanoiaLevel

##### Description

At low paranoia setting, only top-level UIDs are replaced. At medium paranoia setting, many UIDs, descriptions, and
labels are replaced, but the PatientID and FrameOfReferenceUID are retained. The high paranoia setting is the same as
the medium setting, but the PatientID and FrameOfReferenceUID are also replaced. (Note: this is not a full
anonymization.) Use the low setting if you want to retain linkage to the originating data set. Use the medium setting if
you don't. Use the high setting if your TPS goes overboard linking data sets by PatientID and/or FrameOfReferenceUID.

##### Default

- ```"medium"```

##### Supported Options

- ```"low"```
- ```"medium"```
- ```"high"```


----------------------------------------------------

## DICOMExportImagesAsDose

### Tags

- accepts parameter: images
- category: file export
- category: image processing
- category: radiation dose

### Description

This operation exports the selected Image_Array to a DICOM dose file.

### Notes

- There are various 'paranoia' levels that can be used to partially anonymize the output. In particular, most metadata
  and UIDs are replaced, but the files may still be recognized by a determined individual by comparing the coordinate
  system and pixel values. Do NOT rely on this routine to fully anonymize the data!

### Parameters

- ImageSelection
- Filename
- ParanoiaLevel

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

The filename (or full path name) to which the DICOM file should be written.

##### Default

- ```"/tmp/RD.dcm"```

##### Examples

- ```"/tmp/RD.dcm"```
- ```"./RD.dcm"```
- ```"RD.dcm"```

#### ParanoiaLevel

##### Description

At low paranoia setting, only top-level UIDs are replaced. At medium paranoia setting, many UIDs, descriptions, and
labels are replaced, but the PatientID and FrameOfReferenceUID are retained. The high paranoia setting is the same as
the medium setting, but the PatientID and FrameOfReferenceUID are also replaced. (Note: this is not a full
anonymization.) Use the low setting if you want to retain linkage to the originating data set. Use the medium setting if
you don't. Use the high setting if your TPS goes overboard linking data sets by PatientID and/or FrameOfReferenceUID.

##### Default

- ```"medium"```

##### Supported Options

- ```"low"```
- ```"medium"```
- ```"high"```


----------------------------------------------------

## DICOMExportImagesAsMR

### Tags

- accepts parameter: images
- category: file export
- category: image processing

### Description

This operation exports the selected Image_Array(s) to DICOM MR-modality files.

### Notes

- There are various 'paranoia' levels that can be used to partially anonymize the output. In particular, most metadata
  and UIDs are replaced, but the files may still be recognized by a determined individual by comparing the coordinate
  system and pixel values. Do NOT rely on this routine to fully anonymize the data!

### Parameters

- ImageSelection
- Filename
- ParanoiaLevel

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

The filename (or full path name) to which the DICOM files should be written. The file format is a gzipped-TAR file
containing multiple MR-modality files.

##### Default

- ```"MRs.tgz"```

##### Examples

- ```"/tmp/MRs.tgz"```
- ```"./MRs.tar.gz"```
- ```"MRs.tgz"```

#### ParanoiaLevel

##### Description

At low paranoia setting, only top-level UIDs are replaced. At medium paranoia setting, many UIDs, descriptions, and
labels are replaced, but the PatientID and FrameOfReferenceUID are retained. The high paranoia setting is the same as
the medium setting, but the PatientID and FrameOfReferenceUID are also replaced. (Note: this is not a full
anonymization.) Use the low setting if you want to retain linkage to the originating data set. Use the medium setting if
you don't. Use the high setting if your TPS goes overboard linking data sets by PatientID and/or FrameOfReferenceUID.

##### Default

- ```"medium"```

##### Supported Options

- ```"low"```
- ```"medium"```
- ```"high"```


----------------------------------------------------

## DeDuplicateImages

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation de-duplicates image arrays, identifying sets of duplicates based on user-specified criteria and purging
all but one of the duplicates.

### Notes

- This routine is experimental.

### Parameters

- ImageSelection

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## DecayDoseOverTimeHalve

### Tags

- accepts parameter: contours
- category: image processing
- category: radiation dose

### Description

This operation transforms a dose map (assumed to be delivered some distant time in the past) to simulate 'decay' or
'evaporation' or 'forgivance' of radiation dose by simply halving the value. This model is only appropriate at long
time-scales, but there is no cut-off or threshold to denote what is sufficiently 'long'. So use at your own risk. As a
rule of thumb, do not use this routine if fewer than 2-3y have elapsed.

### Notes

- This routine will combine spatially-overlapping images by summing voxel intensities. So if you have a time course it
  may be more sensible to aggregate images in some way (e.g., spatial averaging) prior to calling this routine.

- Since this routine is meant to be applied multiple times in succession for different ROIs (which possibly overlap),
  all images are imbued with a second channel that is treated as a mask. Mask channels are permanently attached so that
  multiple passes will not erroneously decay dose. If this will be problematic, the extra column should be trimmed
  immediately after calling this routine.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## DecayDoseOverTimeJones2014

### Tags

- accepts parameter: contours
- category: image processing
- category: radiation dose

### Description

This operation transforms a dose map (delivered some time in the past) to account for tissue recovery (i.e., 'dose
decay,' 'dose evaporation,' or 'dose forgivance') using the time-dependent model of Jones and Grant (2014;
doi:10.1016/j.clon.2014.04.027). This model is specific to reirradiation of central nervous tissues. See the Jones and
Grant paper or 'Nasopharyngeal Carcinoma' by Wai Tong Ng et al. (2016; doi:10.1007/174_2016_48) for more information.

### Notes

- This routine will combine spatially-overlapping images by summing voxel intensities. So if you have a time course it
  may be more sensible to aggregate images in some way (e.g., spatial averaging) prior to calling this routine.

- Since this routine is meant to be applied multiple times in succession for different ROIs (which possibly overlap),
  all images are imbued with a second channel that is treated as a mask. Mask channels are permanently attached so that
  multiple passes will not erroneously decay dose. If this will be problematic, the extra column should be trimmed
  immediately after calling this routine.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Course1NumberOfFractions
- ToleranceTotalDose
- ToleranceNumberOfFractions
- TimeGap
- AlphaBetaRatio
- UseMoreConservativeRecovery

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Course1NumberOfFractions

##### Description

The number of fractions delivered for the first (i.e., previous) course. If several apply, you can provide a single
effective fractionation scheme's 'n'.

##### Default

- ```"35"```

##### Examples

- ```"15"```
- ```"25"```
- ```"30.001"```
- ```"35.3"```

#### ToleranceTotalDose

##### Description

The dose delivered (in Gray) for a hypothetical 'lifetime dose tolerance' course. This dose corresponds to a
hypothetical radiation course that nominally corresponds to the toxicity of interest. For CNS tissues, it will probably
be myelopathy or necrosis at some population-level onset risk (e.g., 5% risk of myelopathy). The value provided will be
converted to a BED_{a/b} so you can safely provide a 'nominal' value. Be aware that each voxel is treated independently,
rather than treating OARs/ROIs as a whole. (Many dose limits reported in the literature use whole-ROI D_mean or D_max,
and so may be not be directly applicable to per-voxel risk estimation!) Note that the QUANTEC 2010 reports almost all
assume 2 Gy/fraction. If several fractionation schemes were used, you should provide a cumulative BED-derived dose here.

##### Default

- ```"52"```

##### Examples

- ```"15"```
- ```"20"```
- ```"25"```
- ```"50"```
- ```"83.2"```

#### ToleranceNumberOfFractions

##### Description

The number of fractions ('n') for the 'lifetime dose tolerance' toxicity you are interested in. Note that this is
converted to a BED_{a/b} so you can safely provide a 'nominal' value. If several apply, you can provide a single
effective fractionation scheme's 'n'.

##### Default

- ```"35"```

##### Examples

- ```"15"```
- ```"25"```
- ```"30.001"```
- ```"35.3"```

#### TimeGap

##### Description

The number of years between radiotherapy courses. Note that this is normally estimated by (1) extracting study/series
dates from the provided dose files and (2) using the current date as the second course date. Use this parameter to
override the autodetected gap time. Note: if the provided value is negative, autodetection will be used. Autodetection
can fail if the data has been anonymized with date-shifting.

##### Default

- ```"-1"```

##### Examples

- ```"0.91"```
- ```"2.6"```
- ```"5"```

#### AlphaBetaRatio

##### Description

The ratio alpha/beta (in Gray) to use when converting to a biologically-equivalent dose distribution for central nervous
tissues. Jones and Grant (2014) recommend alpha/beta = 2 Gy to be conservative. It is more commonplace to use alpha/beta
= 3 Gy, but this is less conservative and there is some evidence that it may be erroneous to use 3 Gy.

##### Default

- ```"2"```

##### Examples

- ```"2"```
- ```"2.5"```
- ```"3"```

#### UseMoreConservativeRecovery

##### Description

Jones and Grant (2014) provide two ways to estimate the function 'r'. One is fitted to experimental data, and one is a
more conservative estimate of the fitted function. This parameter controls whether or not the more conservative function
is used.

##### Default

- ```"true"```

##### Examples

- ```"true"```
- ```"false"```


----------------------------------------------------

## DecimatePixels

### Tags

- category: image processing

### Description

This operation spatially aggregates blocks of pixels, thereby decimating them and making the images consume far less
memory. The precise size reduction and spatial aggregate can be set in the source.

### Parameters

- OutSizeR
- OutSizeC

#### OutSizeR

##### Description

The number of pixels along the row unit vector to group into an outgoing pixel. Must be a multiplicative factor of the
incoming image's row count. No decimation occurs if either this or 'OutSizeC' is zero or negative.

##### Default

- ```"8"```

##### Examples

- ```"0"```
- ```"2"```
- ```"4"```
- ```"8"```
- ```"16"```
- ```"32"```
- ```"64"```
- ```"128"```
- ```"256"```
- ```"512"```

#### OutSizeC

##### Description

The number of pixels along the column unit vector to group into an outgoing pixel. Must be a multiplicative factor of
the incoming image's column count. No decimation occurs if either this or 'OutSizeR' is zero or negative.

##### Default

- ```"8"```

##### Examples

- ```"0"```
- ```"2"```
- ```"4"```
- ```"8"```
- ```"16"```
- ```"32"```
- ```"64"```
- ```"128"```
- ```"256"```
- ```"512"```


----------------------------------------------------

## DecomposeImagesSVD

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation uses Singular Value Decomposition (SVD) on a set of images to generate an orthonormal basis. The basis is
ordered and such that the first image corresponds with the largest singular value. The resulting basis can be used for
classification, compression, and principal component analysis, among other things.

### Notes

- Images are 'reshaped' from a MxN matrix to a vector with length MxN using the default Ygor image pixel ordering
  (row-major).

- Spatial information is disregarded for all images, and the basis images have default geometry.

### Parameters

- ImageSelection
- Channel

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Channel

##### Description

The image channel to use. Zero-based. Use '-1' to operate on all available channels.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```


----------------------------------------------------

## DeleteContours

### Tags

- accepts parameter: contours
- category: contour processing

### Description

This operation deletes the selected contours.

### Notes

- Contours can be shallow copies that are shared amongst multiple Drover class instances. Deleting contours in one
  Drover instance will delete them from all linked instances. Typically, contours are deep-copied to avoid this problem,
  but be aware if using shallow copies.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## DeleteImages

### Tags

- accepts parameter: images
- category: image processing

### Description

This routine deletes image arrays.

### Parameters

- ImageSelection

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## DeleteLineSamples

### Tags

- accepts parameter: line samples
- category: line sample processing

### Description

This operation deletes the selected line samples.

### Parameters

- LineSelection

#### LineSelection

##### Description

Select one or more line samples. Selection specifiers can be of three types: positional, metadata-based key@value regex,
and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth line sample (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last line sample.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the line sample composed of the greatest and fewest number of samples. Only one or zero line sample will be
selected; if there are ties, there is no guarantee which line sample will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple line sample based on a threshold count, i.e., where all selected line sample have
more than or fewer than $N$ samples. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all line sample that do not have the greatest number of samples, not the least-numerous line sample (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## DeleteMeshes

### Tags

- accepts parameter: surface meshes
- category: mesh processing

### Description

This routine deletes surface meshes from memory. It is most useful when working with positional operations in stages.

### Parameters

- MeshSelection

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## DeletePoints

### Tags

- accepts parameter: point clouds
- category: point cloud processing

### Description

This routine deletes point clouds from memory. It is most useful when working with positional operations in stages.

### Parameters

- PointSelection

#### PointSelection

##### Description

Select one or more point clouds. Note that point clouds can hold a variety of data with varying attributes, but each
point cloud is meant to represent a single logically cohesive collection of points. Be aware that it is possible to mix
logically unrelated points together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## DeleteTables

### Tags

- accepts parameter: tables
- category: table processing

### Description

This routine deletes tables.

### Parameters

- TableSelection

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## DetectGrid3D

### Tags

- accepts parameter: point clouds
- category: acquires futex
- category: file export
- category: image processing
- category: point cloud processing

### Description

This routine fits a 3D grid to a point cloud using a Procrustes analysis with point-to-model correspondence estimated
via an iterative closest point approach. A RANSAC-powered loop is used to (1) randomly select a subset of the grid for
coarse iterative closest point grid fitting, and then (2) use the coarse fit results as a guess for the whole point
cloud in a refinement stage.

### Notes

- Traditional Procrustes analysis requires a priori point-to-point correspondence knowledge. Because this operation fits
  a model (with infinite extent), point-to-point correspondence is not known and the model is effectively an infinite
  continuum of potential points. To overcome this problem, correspondence is estimated by projecting each point in the
  point cloud onto every grid line and selecting the closest projected point. The point cloud point and the project
  point are then treated as corresponding points. Using this phony correspondence, the Procrustes problem is solved and
  the grid is reoriented. This is performed iteratively. However **there is no guarantee the procedure will converge**
  and furthermore, even if it does converge, **there is no guarantee that the grid will be appropriately fit**. The best
  results will occur when the grid is already closely aligned with the point cloud (i.e., when the first guess is very
  close to a solution). If this cannot be guaranteed, it may be advantageous to have a nearly continuous point cloud to
  avoid gaps in which the iteration can get stuck in a local minimum. For this reason, RANSAC is applied to continuously
  reboot the fitting procedure. All but the best fit are discarded.

- A two-stage RANSAC inner-loop iterative closest point fitting procedure is used. Coarse grid fitting is first
  performed with a limited subset of the whole point cloud. This is followed with a refinment stage in which the enire
  point cloud is fitted using an initial guess carried forward from the coarse fitting stage. This guess is expected to
  be reasonably close to the true grid in cases where the coarse fitting procedure was not tainted by outliers, but is
  only derived from a small portion of the point cloud. (Thus RANSAC is used to perform this coarse-fine iterative
  procedure multiple times to provide resilience to poor-quality coarse fits.) CoarseICPMaxLoops is the maximum number
  of iterative-closest point loop iterations performed during the coarse grid fitting stage (on a subset of the point
  cloud), and FineICPMaxLoops is the maximum number of iterative-closest point loop iterations performed during the
  refinement stage (using the whole point cloud). Note that, depending on the noise level and number of points
  considered (i.e., whether the RANSACDist parameter is sufficiently small to avoid spatial wrapping of corresponding
  points into adjacent grid cells, but sufficiently large to enclose at least one whole grid cell), the coarse phase
  should converge within a few iterations. However, on each loop a single point is selected as the grid's rotation
  centre. This means that a few extra iterations should always be used in case outliers are selected as rotation
  centres. Additionally, if the point cloud is dense or there are lots of outliers present, increase CoarseICPMaxLoops
  to ensure there is a reasonable chance of selecting legitimate rotation points. On the other hand, be aware that the
  coarse-fine iterative procedure is performed afresh for every RANSAC loop, and RANSAC loops are better able to ensure
  the point cloud is sampled ergodically. It might therefore be more productive to increase the RANSACMaxLoops parameter
  and reduce the number of CoarseICPMaxLoops. FineICPMaxLoops should converge quickly if the coarse fitting stage was
  representative of the true grid. However, as in the coarse stage a rotation centre is nominated in each loop, so it
  will be a good idea to keep a sufficient number of loops to ensure a legitimate and appropriate non-outlier point is
  nominated during this stage. Given the complicated interplay between parameters and stages, it is always best to tune
  using a representative sample of the point cloud you need to fit!

### Parameters

- PointSelection
- GridSeparation
- RANSACDist
- GridSampling
- LineThickness
- RandomSeed
- RANSACMaxLoops
- CoarseICPMaxLoops
- FineICPMaxLoops
- ResultsSummaryFileName
- UserComment

#### PointSelection

##### Description

Select one or more point clouds. Note that point clouds can hold a variety of data with varying attributes, but each
point cloud is meant to represent a single logically cohesive collection of points. Be aware that it is possible to mix
logically unrelated points together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### GridSeparation

##### Description

The separation of the grid (in DICOM units; mm) being fit. This parameter describes how close adjacent grid lines are to
one another. Separation is measured from one grid line centre to the nearest adjacent grid line centre.

##### Default

- ```"10.0"```

##### Examples

- ```"10.0"```
- ```"15.5"```
- ```"25.0"```
- ```"1.23E4"```

#### RANSACDist

##### Description

Every iteration of RANSAC selects a single point from the point cloud. Only the near-vicinity of points are retained for
iterative-closest-point Procrustes solving. This parameter determines the maximum radial distance from the RANSAC point
within which point cloud points will be retained; all points further than this distance away will be pruned for a given
round of RANSAC. This is needed because corresponding points begin to alias to incorrect cell faces when the ICP
procedure begins with a poor guess. Pruning points in a spherical neighbourhood with a diameter 2-4x the GridSeparation
(so a radius 1-2x GridSeparation) will help mitigate aliasing even when the initial guess is poor. However, smaller
windows may increase susceptibility to noise/outliers, and RANSACDist should never be smaller than a grid voxel. If
RANSACDist is not provided, a default of (1.5 * GridSeparation) is used.

##### Default

- ```"nan"```

##### Examples

- ```"7.0"```
- ```"10.0"```
- ```"2.46E4"```

#### GridSampling

##### Description

Specifies how the grid data has been sampled. Use value '1' if only grid cell corners (i.e., '0D' grid intersections)
are sampled. Use value '2' if grid cell edges (i.e., 1D grid lines) are sampled. Use value '3' if grid cell faces (i.e.,
2D planar faces) are sampled.

##### Default

- ```"1"```

##### Examples

- ```"1"```
- ```"2"```
- ```"3"```

#### LineThickness

##### Description

The thickness of grid lines (in DICOM units; mm). If zero, lines are treated simply as lines. If non-zero, grid lines
are treated as hollow cylinders with a diameter of this thickness.

##### Default

- ```"0.0"```

##### Examples

- ```"1.0"```
- ```"1.5"```
- ```"10.0"```
- ```"1.23E4"```

#### RandomSeed

##### Description

A whole number seed value to use for random number generation.

##### Default

- ```"1317"```

##### Examples

- ```"1"```
- ```"2"```
- ```"1113523431"```

#### RANSACMaxLoops

##### Description

The maximum number of iterations of RANSAC. (See operation notes for further details.)

##### Default

- ```"100"```

##### Examples

- ```"100"```
- ```"2000"```
- ```"1E4"```

#### CoarseICPMaxLoops

##### Description

Coarse grid fitting is performed with a limited subset of the whole point cloud. This is followed with a refinment stage
in which the enire point is fitted using an initial guess from the coarse fitting stage. CoarseICPMaxLoops is the
maximum number of iterative-closest point loop iterations performed during the coarse grid fitting stage. (See operation
notes for further details.)

##### Default

- ```"10"```

##### Examples

- ```"10"```
- ```"100"```
- ```"1E4"```

#### FineICPMaxLoops

##### Description

Coarse grid fitting is performed with a limited subset of the whole point cloud. This is followed with a refinment stage
in which the enire point is fitted using an initial guess from the coarse fitting stage. FineICPMaxLoops is the maximum
number of iterative-closest point loop iterations performed during the refinement stage. (See operation notes for
further details.)

##### Default

- ```"20"```

##### Examples

- ```"10"```
- ```"50"```
- ```"100"```

#### ResultsSummaryFileName

##### Description

This file will contain a brief summary of the results. The format is CSV. Leave empty to dump to generate a unique
temporary file. If an existing file is present, rows will be appended without writing a header.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```


----------------------------------------------------

## DetectShapes3D

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation attempts to detect shapes in image volumes.

### Parameters

- ImageSelection

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## DrawGeometry

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This operation draws shapes and patterns on images. Drawing is confined to one or more ROIs.

### Parameters

- ImageSelection
- VoxelValue
- Overwrite
- Channel
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- ContourOverlap
- Inclusivity
- Shapes

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### VoxelValue

##### Description

The value to give voxels which are coincident with a point from the point cloud.

##### Default

- ```"1.0"```

##### Examples

- ```"-1.0"```
- ```"0.0"```
- ```"1.23"```
- ```"nan"```
- ```"inf"```

#### Overwrite

##### Description

Whether to overwrite voxels interior or exterior to the specified ROI(s).

##### Default

- ```"interior"```

##### Supported Options

- ```"interior"```
- ```"exterior"```

#### Channel

##### Description

The image channel to use. Zero-based.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"2"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. The option 'honour_opposite_orientations' makes overlapping contours with opposite
orientation cancel. Otherwise, orientation is ignored. The latter is useful for Boolean structures where contour
orientation is significant for interior contours (holes). The option 'overlapping_contours_cancel' ignores orientation
and cancels all contour overlap.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### Shapes

##### Description

This parameter is used to specify the shapes and patterns to consider. Currently grids, wireframecubes, and solidspheres
are available. Grids have four configurable parameters: two orientation unit vectors, line thickness, and line
separation. A grid intersecting at the image array's centre, aligned with (1.0,0.0,0.0) and (0.0,1.0,0.0), with line
thickness (i.e., diameter) 3.0 (DICOM units; mm), and separation 15.0 can be specified as 'grid(1.0,0.0,0.0,
0.0,1.0,0.0, 3.0, 15.0)'. Unit vectors will be Gram-Schmidt orthogonalized. Note that currently the grid *must*
intersect the image array's centre. Cubes have the same number of configurable parameters, but only a single cube of the
grid is drawn. The wireframecube is centred at the image centre, rather than intersecting it. Solid spheres have two
configurable parameters: a centre vector and a radius. A solid sphere at (1.0,2.0,3.0) with radius 15.0 (all DICOM
units; mm) can be specified as 'solidsphere(1.0,2.0,3.0, 15.0)'. Grid, wireframecube, and solidsphere shapes only
overwrite voxels that intersect the geometry (i.e., the surface if hollow or the internal volume if solid) permitting
easier composition of multiple shapes or custom backgrounds.

##### Default

- ```"grid(-0.0941083,0.995562,0, 0.992667,0.0938347,0.0762047, 3.0, 15.0)"```

##### Examples

- ```"grid(1.0,0.0,0.0, 0.0,1.0,0.0, 3.0, 15.0)"```
- ```"wireframecube(1.0,0.0,0.0, 0.0,1.0,0.0, 3.0, 15.0)"```
- ```"solidsphere(0.0,0.0,0.0, 15.0)"```


----------------------------------------------------

## DroverDebug

### Tags

- category: meta

### Description

This operation reports basic information on the state of the main Drover class. It can be used to report on the state of
the data, which can be useful for debugging.

### Parameters

- IncludeMetadata
- Verbosity

#### IncludeMetadata

##### Description

Whether to include metadata in the output. This data can significantly increase the size of the output.

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```

#### Verbosity

##### Description

Controls the amount of information printed.

##### Default

- ```"verbose"```

##### Supported Options

- ```"verbose"```
- ```"medium"```
- ```"quiet"```


----------------------------------------------------

## DumpAllOrderedImageMetadataToFile

### Tags

- category: meta
- category: needs refresh

### Description

Dump exactly what order the data will be in for the following analysis.

### Parameters

No registered options.

----------------------------------------------------

## DumpAnEncompassedPoint

### Tags

- category: meta
- category: needs refresh

### Description

This operation estimates the number of spatially-overlapping images. It finds an arbitrary point within an arbitrary
image, and then finds all other images which encompass the point.

### Parameters

No registered options.

----------------------------------------------------

## DumpFilesPartitionedByTime

### Tags

- category: meta
- category: needs refresh

### Description

This operation prints PACS filenames along with the associated time. It is more focused than the metadata dumpers above.
This data can be used for many things, such as image viewers which are not DICOM-aware or deformable registration on
time series data.

### Parameters

No registered options.

----------------------------------------------------

## DumpImageMeshes

### Tags

- accepts parameter: images
- category: file export
- category: image processing
- category: mesh processing

### Description

This operation exports images as a 3D surface mesh model (structured ASCII Wavefront OBJ) that can be manipulated in
various ways (e.g., stereographic projection). Note that the mesh will be a 3D depiction of the image(s) as they
naturally are -- meshes will always be rectangular. A companion material library file (MTL) assigns colours to each ROI
based on the voxel intensity.

### Notes

- Each image is processed separately. Each mesh effectively produces a 2D relief map embedded into a 3D model that can
  be easily rendered to produce various effects (e.g., perspective, stereoscopy, extrusion, surface smoothing, etc.).

### Parameters

- ImageSelection
- OutBase
- HistogramBins
- MagnitudeAmplification
- Normalize

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### OutBase

##### Description

A base filename (or full path) in which to (over)write image mesh and material library files. File formats are Wavefront
Object (obj) and Material Library (mtl). Every image will receive one unique and sequentially-numbered obj and mtl file
using this prefix.

##### Default

- ```"/tmp/dicomautomaton_dumpimagemeshes_"```

##### Examples

- ```"/tmp/image_mesh_"```
- ```"./"```
- ```"../model_"```

#### HistogramBins

##### Description

The number of equal-width bins pixel intensities should be grouped into. Binning is performed in order to more easily
associate material properties with pixels. If pixel intensities were continuous, each pixel would receive its own
material definition. This could result in enormous MTL files and wasted disk space. Binning solves this issue. However,
if images are small or must be differentiated precisely consider using a large number of bins. Otherwise 150-1000 bins
should suffice for display purposes.

##### Default

- ```"255"```

##### Examples

- ```"10"```
- ```"50"```
- ```"100"```
- ```"200"```
- ```"500"```

#### MagnitudeAmplification

##### Description

Pixel magnitudes (i.e., intensities) are scaled according to the image thickness, but a small gap is left between meshes
so that abutting images do not quite intersect (this can cause non-manifold scenarios). However, if stackability is not
a concern then pixel magnitudes can be magnified to exaggerate the relief effect. A value of 1.0 provides no
magnification. A value of 2.0 provides 2x magnification, but note that the base of each pixel is slightly offset from
the top to avoid top-bottom face intersections, even when magnification is 0.0.

##### Default

- ```"1.0"```

##### Examples

- ```"0.75"```
- ```"1.0"```
- ```"2.0"```
- ```"5.0"```
- ```"75.6"```

#### Normalize

##### Description

This parameter controls whether the model will be 'normalized,' which effectively makes the outgoing model more
consistent for all images. Currently this means centring the model at (0,0,0), mapping the row and column directions to
(1,0,0) and (0,1,0) respectively, and scaling the image (respecting the aspect ratio) to fit within a bounding square of
size 100x100 (DICOM units; mm). If normalization is *not* used, the image mesh will inherit the spatial characteristics
of the image it is derived from.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```


----------------------------------------------------

## DumpImageMetadataOccurrencesToFile

### Tags

- accepts parameter: images
- category: file export
- category: image processing

### Description

Dump all the metadata elements, but group like-items together and also print the occurence number.

### Parameters

- ImageSelection
- FileName
- UserComment

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### FileName

##### Description

A filename (or full path) in which to append metadata reported by this routine. The format is tab-separated values
(TSV). Leave empty to dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.tsv"```
- ```"derivative_data.tsv"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data. If left empty, the column will be empty in the output.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```


----------------------------------------------------

## DumpPerROIParams_KineticModel_1C2I_5P

### Tags

- accepts parameter: contours
- category: image processing
- category: modeling
- category: perfusion

### Description

Given a perfusion model, this routine computes parameter estimates for ROIs.

### Parameters

- ROILabelRegex
- ROISelection
- Filename
- Separator

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

A file into which the results should be dumped. If the filename is empty, the results are dumped to the console only.

##### Default

- ```""```

##### Examples

- ```"/tmp/results.txt"```
- ```"/dev/null"```
- ```"~/output.txt"```

#### Separator

##### Description

The token(s) to place between adjacent columns of output. Note: because whitespace is trimmed from user parameters,
whitespace separators other than the default are shortened to an empty string. So non-default whitespace are not
currently supported.

##### Default

- ```" "```

##### Examples

- ```","```
- ```";"```
- ```"_a_long_separator_"```


----------------------------------------------------

## DumpPixelValuesOverTimeForAnEncompassedPoint

### Tags

- category: image processing
- category: needs refresh

### Description

Output the pixel values over time for a generic point. Currently the point is arbitrarily taken to tbe the centre of the
first image. This is useful for quickly and programmatically inspecting trends, but the SFML_Viewer operation is better
for interactive exploration.

### Parameters

No registered options.

----------------------------------------------------

## DumpPlanSummary

### Tags

- category: file export
- category: rtplan processing

### Description

This operation dumps a summary of a radiotherapy plan. This operation can be used to gain insight into a plan from a
high-level overview.

### Parameters

- SummaryFileName
- UserComment

#### SummaryFileName

##### Description

A filename (or full path) in which to append summary data generated by this routine. The format is CSV. Leave empty to
dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data. If left empty, the column will be omitted from the output.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```


----------------------------------------------------

## DumpROIContours

### Tags

- accepts parameter: contours
- category: contour processing
- category: file export
- category: mesh processing

### Description

This operation exports contours in a standard surface mesh format (structured ASCII Wavefront OBJ) in planar polygon
format. A companion material library file (MTL) assigns colours to each ROI to help differentiate them.

### Notes

- Contours that are grouped together into a contour_collection are treated as a logical within the output. For example,
  all contours in a collection will share a common material property (e.g., colour). If more fine-grained grouping is
  required, this routine can be called once for each group which will result in a logical grouping of one ROI per file.

### Parameters

- DumpFileName
- MTLFileName
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### DumpFileName

##### Description

A filename (or full path) in which to (over)write with contour data. File format is Wavefront obj. Leave empty to dump
to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile.obj"```
- ```"localfile.obj"```
- ```"derivative_data.obj"```

#### MTLFileName

##### Description

A filename (or full path) in which to (over)write a Wavefront material library file. This file is used to colour the
contours to help differentiate them. Leave empty to dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/materials.mtl"```
- ```"localfile.mtl"```
- ```"somefile.mtl"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## DumpROIData

### Tags

- category: contour processing

### Description

This operation dumps ROI contour information for debugging and quick inspection purposes.

### Parameters

No registered options.

----------------------------------------------------

## DumpROISNR

### Tags

- accepts parameter: contours
- category: contour processing
- category: file export
- category: image processing

### Description

This operation computes the Signal-to-Noise ratio (SNR) for each ROI. The specific 'SNR' computed is SNR = (mean pixel)
/ (pixel std dev) which is the inverse of the coefficient of variation.

### Notes

- This routine will combine spatially-overlapping images by summing voxel intensities. So if you have a time course it
  may be more sensible to aggregate images in some way (e.g., spatial averaging) prior to calling this routine.

### Parameters

- SNRFileName
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### SNRFileName

##### Description

A filename (or full path) in which to append SNR data generated by this routine. The format is CSV. Leave empty to dump
to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## DumpROISurfaceMeshes

### Tags

- accepts parameter: contours
- category: contour processing
- category: file export
- category: mesh processing

### Description

This operation generates surface meshes from contour volumes. Output is written to file(s) for viewing with an external
viewer (e.g., meshlab).

### Notes

- This routine is currently limited. Many parameters can only be modified via recompilation. This will be addressed in a
  future version.

### Parameters

- OutBase
- ROILabelRegex
- ROISelection
- NormalizedROILabelRegex
- GridRows
- GridColumns
- ContourOverlap
- Inclusivity

#### OutBase

##### Description

The prefix of the filename that surface mesh files will be saved as. If no name is given, unique names will be chosen
automatically.

##### Default

- ```""```

##### Examples

- ```"/tmp/dicomautomaton_dumproisurfacemesh"```
- ```"../somedir/output"```
- ```"/path/to/some/mesh"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### GridRows

##### Description

Controls the spatial resolution of the grid used to approximate the ROI(s). Specifically, the number of rows. Note that
the number of slices is fixed by the contour separation. A larger number will result in a more accurate mesh, but will
also result longer runtimes and higher mesh complexity. Setting this parameter too high will result in excessive runtime
and memory usage, so consider post-processing (i.e., subdivision) if a smooth mesh is needed.

##### Default

- ```"256"```

##### Examples

- ```"64"```
- ```"128"```
- ```"256"```
- ```"512"```
- ```"1024"```

#### GridColumns

##### Description

Controls the spatial resolution of the grid used to approximate the ROI(s). (Refer to GridRows for more information.)

##### Default

- ```"256"```

##### Examples

- ```"64"```
- ```"128"```
- ```"256"```
- ```"512"```
- ```"1024"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. The option 'honour_opposite_orientations' makes overlapping contours with opposite
orientation cancel. Otherwise, orientation is ignored. The latter is useful for Boolean structures where contour
orientation is significant for interior contours (holes). The option 'overlapping_contours_cancel' ignores orientation
and cancels all contour overlap.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```


----------------------------------------------------

## DumpRTPlanMetadataOccurrencesToFile

### Tags

- category: file export
- category: rtplan processing

### Description

Dump all the metadata elements, but group like-items together and also print the occurence number.

### Parameters

- RTPlanSelection
- FileName
- UserComment

#### RTPlanSelection

##### Description

Select one or more treatment plans. Note that a single treatment plan may be composed of multiple beams; if delivered
sequentially, they should collectively represent a single logically cohesive plan. Selection specifiers can be of three
types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth treatment plan (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last treatment plan.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the treatment plan composed of the greatest and fewest number of control points. Only one or zero treatment plan
will be selected; if there are ties, there is no guarantee which treatment plan will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple treatment plan based on a threshold count, i.e., where all selected treatment plan
have more than or fewer than $N$ control points. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all treatment plan that do not have the greatest number of control points, not the least-numerous
treatment plan (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### FileName

##### Description

A filename (or full path) in which to append metadata reported by this routine. The format is tab-separated values
(TSV). Leave empty to dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.tsv"```
- ```"derivative_data.tsv"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data. If left empty, the column will be empty in the output.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```


----------------------------------------------------

## DumpVoxelDoseInfo

### Tags

- category: image processing
- category: radiation dose

### Description

This operation locates the minimum and maximum dose voxel values. It is useful for estimating prescription doses.

### Notes

- This implementation makes use of a primitive way of estimating dose. Please verify it works (or re-write using the new
  methods) before using for anything important.

### Parameters

No registered options.

----------------------------------------------------

## EQDXTable

### Tags

- accepts parameter: tables
- category: table processing

### Description

This operation transforms a given fractionated high dose rate radiotherapy dose to an Equivalent Dose with 'x'-Dose per
fraction (EQDx). A table with various $\alpha/\beta$ and variations is generated. Currently, only photon external beam
therapy conversions are supported.

### Notes

- This operation transforms a single scalar dose. For an operation that transforms an image array, consider the
  'BEDConvert' operation.

- The default is an 'EQD2' transformation, with 2 Gy per fraction (i.e., EQDx with $x=2$).

- This operation currently assumes a linear-quadratic BED model that disregards time delays, in particular tissue
  repopulation. Specifically Withers' formula is used: $EQD_{x} = nd(d + \alpha/\beta)/(x + \alpha/\beta)$.

### Parameters

- TargetDosePerFraction
- NumberOfFractions
- Dose
- AlphaBetaRatios
- TableSelection
- TableLabel

#### TargetDosePerFraction

##### Description

The desired dose per fraction 'x' for an EQDx conversion.

Note that the recommended units are Gy. However, the only requirement is to be consistent with the dose parameter's
units and the $\alpha/\beta$. For an 'EQD2' conversion, this value should be 2 Gy and the input dose should also be in
units of Gy. For an 'EQD3.5' conversion, this value should be 3.5 Gy.

##### Default

- ```"2.0"```

##### Examples

- ```"1.8"```
- ```"2.0"```
- ```"5.0"```
- ```"8.0"```

#### NumberOfFractions

##### Description

The number of fractions over which the dose distribution was (or will be) delivered. Decimal fractions are supported to
accommodate multi-pass BED conversions.

##### Default

- ```"35"```

##### Examples

- ```"10"```
- ```"20.5"```
- ```"35"```
- ```"40.123"```

#### Dose

##### Description

The dose to be transformed. It should be a dose that was (or will be) delivered (e.g., a point dose delivered to a
voxel, or a prescription delivered to a PTV).

Note that the recommended units are Gy. However, the only requirement is to be consistent with the 'x' dose (i.e., the
$x$ in EQDx) and the $\alpha/\beta$. For a 70 Gy dose provide the value '70'.

Note that if the dose is a prescription dose, then the result should be considered a virtual dose or even a sort of
'ballpark estimate' since the prescribed tissues will only nominally receive the prescription dose. Also note that the
specified dose need not actually exist; it can be purely virtual to accommodate multiple/compound conversions.

##### Default

- ```"70"```

##### Examples

- ```"5.0"```
- ```"15"```
- ```"22.5"```
- ```"45.0"```
- ```"66"```
- ```"70.001"```

#### AlphaBetaRatios

##### Description

A list of $\alpha/\beta$ to use, where each $\alpha/\beta$ is separated with a ';'. A conversion will be performed
separately for each $\alpha/\beta$.

Note that the recommended units are Gy. However, the only requirement is to be consistent with the 'x' dose (i.e., the
$x$ in EQDx) and the dose parameter's units.

##### Default

- ```"1;2;3;5;6;8;10"```

##### Examples

- ```"2,0"```
- ```"1;2;3"```
- ```"0.1;25"```

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"TableLabel@EQDx"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TableLabel

##### Description

A label to attach to table if and only if a new table is created.

##### Default

- ```"EQDx"```

##### Examples

- ```"unspecified"```
- ```"xyz"```
- ```"sheet A"```


----------------------------------------------------

## EvaluateDoseVolumeStats

### Tags

- category: contour processing
- category: file export
- category: image processing
- category: radiation dose

### Description

This operation evaluates a variety of Dose-Volume statistics. It is geared toward PTV ROIs. Currently the following are
implemented: (1) Dose Homogeneity Index: H = (D_{2%} - D_{98%})/D_{median} | over one or more PTVs, where D_{2%} is the
maximum dose that covers 2% of the volume of the PTV, and D_{98%} is the minimum dose that covers 98% of the volume of
the PTV. (2) Conformity Number: C = V_{T,pres}^{2} / ( V_{T} * V_{pres} ) where V_{T,pres} is the PTV volume receiving
at least 95% of the PTV prescription dose, V_{T} is the volume of the PTV, and V_{pres} is volume of all (tissue) voxels
receiving at least 95% of the PTV prescription dose.

### Notes

- This routine will combine spatially-overlapping images by summing voxel intensities. It will not combine separate
  image_arrays though. If needed, you'll have to perform a meld on them beforehand.

### Parameters

- OutFileName
- PTVPrescriptionDose
- PTVROILabelRegex
- PTVNormalizedROILabelRegex
- BodyROILabelRegex
- BodyNormalizedROILabelRegex
- UserComment

#### OutFileName

##### Description

A filename (or full path) in which to append dose statistic data generated by this routine. The format is CSV. Leave
empty to dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### PTVPrescriptionDose

##### Description

The dose prescribed to the PTV of interest (in Gy).

##### Default

- ```"70"```

##### Examples

- ```"50"```
- ```"66"```
- ```"70"```
- ```"82.5"```

#### PTVROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### PTVNormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### BodyROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### BodyNormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data. If left empty, the column will be omitted from the output.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```


----------------------------------------------------

## EvaluateNTCPModels

### Tags

- accepts parameter: contours
- category: contour processing
- category: file export
- category: image processing
- category: modeling
- category: radiation dose

### Description

This operation evaluates a variety of NTCP models for each provided ROI. The selected ROI should be OARs. Currently the
following are implemented: (1) The LKB model. (2) The 'Fenwick' model for solid tumours (in the lung; for a whole-lung
OAR).

### Notes

- Generally these models require dose in 2 Gy per fraction equivalents ('EQD2'). You must pre-convert the data if the RT
  plan is not already 2 Gy per fraction. There is no easy way to ensure this conversion has taken place or was
  unnecessary.

- This routine will combine spatially-overlapping images by summing voxel intensities. So if you have a time course it
  may be more sensible to aggregate images in some way (e.g., spatial averaging) prior to calling this routine.

- The LKB and mEUD both have their own gEUD 'alpha' parameter, but they are not necessarily shared. Huang et al. 2015
  (doi:10.1038/srep18010) used alpha=1 for the LKB model and alpha=5 for the mEUD model.

### Parameters

- NTCPFileName
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- LKB_TD50
- LKB_M
- LKB_Alpha
- UserComment

#### NTCPFileName

##### Description

A filename (or full path) in which to append NTCP data generated by this routine. The format is CSV. Leave empty to dump
to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### LKB_TD50

##### Description

The dose (in Gray) needed to deliver to the selected OAR that will induce the effect in 50% of cases.

##### Default

- ```"26.8"```

##### Examples

- ```"26.8"```

#### LKB_M

##### Description

No description given...

##### Default

- ```"0.45"```

##### Examples

- ```"0.45"```

#### LKB_Alpha

##### Description

The weighting factor $\alpha$ that controls the relative weighting of volume and dose in the generalized Equivalent
Uniform Dose (gEUD) model. When $\alpha=1$, the gEUD is equivalent to the mean; when $\alpha=0$, the gEUD is equivalent
to the geometric mean. Wu et al. (doi:10.1016/S0360-3016(01)02585-8) claim that for normal tissues, $\alpha$ can be
related to the Lyman-Kutcher-Burman (LKB) model volume parameter 'n' via $\alpha=1/n$. Sovik et al.
(doi:10.1016/j.ejmp.2007.09.001) found that gEUD is not strongly impacted by errors in $\alpha$. Niemierko et al. ('A
generalized concept of equivalent uniform dose. Med Phys 26:1100, 1999) generated maximum likelihood estimates for
'several tumors and normal structures' which ranged from -13.1 for local control of chordoma tumors to +17.7 for
perforation of esophagus. Gay et al. (doi:10.1016/j.ejmp.2007.07.001) table 2 lists estimates based on the work of Emami
(doi:10.1016/0360-3016(91)90171-Y) for normal tissues ranging from 1-31. Brenner et al.
(doi:10.1016/0360-3016(93)90189-3) recommend -7.2 for breast cancer, -10 for melanoma, and -13 for squamous cell
carcinomas. A 2017 presentation by Ontida Apinorasethkul claims the tumour range spans [-40:-1] and the organs at risk
range spans [1:40]. AAPM TG report 166 also provides a listing of recommended values, suggesting -10 for PTV and GTV, +1
for parotid, 20 for spinal cord, and 8-16 for rectum, bladder, brainstem, chiasm, eye, and optic nerve. Burman (1991)
and QUANTEC (2010) also provide estimates.

##### Default

- ```"1.0"```

##### Examples

- ```"1"```
- ```"3"```
- ```"4"```
- ```"20"```
- ```"31"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data. If left empty, the column will be omitted from the output.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```


----------------------------------------------------

## EvaluateParameters

### Tags

- category: control flow
- category: meta
- category: parameter table

### Description

Exposes the global parameter metadata table for query and evaluation.

### Parameters

- Contains

#### Contains

##### Description

Key@value pairs that can be used to check for the presence of specific metadata. Keys are interpretted verbatim, but
values are interpretted as regex.

Note that if the key is absent in the table, the value will never match.

Note to query if a given key is present, regardless of the value, use a regex that matches any input, e.g., 'key@.*'.

##### Default

- ```""```

##### Examples

- ```"Modality@CT"```
- ```"StudyDate@.*2024.*"```
- ```"SomeMetadataKey@.*"```


----------------------------------------------------

## EvaluateTCPModels

### Tags

- accepts parameter: contours
- category: contour processing
- category: file export
- category: image processing
- category: modeling
- category: radiation dose

### Description

This operation evaluates a variety of TCP models for each provided ROI. The selected ROI should be the GTV (according to
the Fenwick model). Currently the following are implemented: (1) The 'Martel' model. (2) Equivalent Uniform Dose (EUD)
TCP. (3) The 'Fenwick' model for solid tumours.

### Notes

- Generally these models require dose in 2Gy/fractions equivalents ('EQD2'). You must pre-convert the data if the RT
  plan is not already 2Gy/fraction. There is no easy way to ensure this conversion has taken place or was unnecessary.

- This routine will combine spatially-overlapping images by summing voxel intensities. So if you have a time course it
  may be more sensible to aggregate images in some way (e.g., spatial averaging) prior to calling this routine.

- The Fenwick and Martel models share the value of D_{50}. There may be a slight difference in some cases. Huang et al.
  2015 (doi:10.1038/srep18010) used both models and used 84.5 Gy for the Martel model while using 84.6 Gy for the
  Fenwick model. (The paper also reported using a Fenwick 'm' of 0.329 whereas the original report by Fenwick reported
  0.392, so I don't think this should be taken as strong evidence of the equality of D_{50}. However, the difference
  seems relatively insignificant.)

### Parameters

- TCPFileName
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Gamma50
- Dose50
- EUD_Gamma50
- EUD_TCD50
- EUD_Alpha
- Fenwick_C
- Fenwick_M
- Fenwick_Vref
- UserComment

#### TCPFileName

##### Description

A filename (or full path) in which to append TCP data generated by this routine. The format is CSV. Leave empty to dump
to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Gamma50

##### Description

The unitless 'normalized dose-response gradient' or normalized slope of the logistic dose-response model at the
half-maximum point (e.g., D_50). Informally, this parameter controls the steepness of the dose-response curve. (For more
specific information, consult a standard reference such as 'Basic Clinical Radiobiology' 4th Edition by Joiner et al.,
sections 5.3-5.5.) This parameter is empirically fit and not universal. Late endpoints for normal tissues have gamma_50
around 2-6 whereas gamma_50 nominally varies around 1.5-2.5 for local control of squamous cell carcinomas of the head
and neck.

##### Default

- ```"2.3"```

##### Examples

- ```"1.5"```
- ```"2"```
- ```"2.5"```
- ```"6"```

#### Dose50

##### Description

The dose (in Gray) needed to achieve 50% probability of local tumour control according to an empirical logistic
dose-response model (e.g., D_50). Informally, this parameter 'shifts' the model along the dose axis. (For more specific
information, consult a standard reference such as 'Basic Clinical Radiobiology' 4th Edition by Joiner et al., sections
5.1-5.3.) This parameter is empirically fit and not universal. In 'Quantifying the position and steepness of radiation
dose-response curves' by Bentzen and Tucker in 1994, D_50 of around 60-65 Gy are reported for local control of head and
neck cancers (pyriform sinus carcinoma and neck nodes with max diameter <= 3cm). Martel et al. report 84.5 Gy in lung.

##### Default

- ```"65"```

##### Examples

- ```"37.9"```
- ```"52"```
- ```"60"```
- ```"65"```
- ```"84.5"```

#### EUD_Gamma50

##### Description

The unitless 'normalized dose-response gradient' or normalized slope of the gEUD TCP model. It is defined only for the
generalized Equivalent Uniform Dose (gEUD) model. This is sometimes referred to as the change in TCP for a unit change
in dose straddled at the TCD_50 dose. It is a counterpart to the Martel model's 'Gamma_50' parameter, but is not quite
the same. Okunieff et al. (doi:10.1016/0360-3016(94)00475-Z) computed Gamma50 for tumours in human subjects across
multiple institutions; they found a median of 0.8 for gross disease and a median of 1.5 for microscopic disease. The
inter-quartile range was [0.7:1.8] and [0.7:2.2] respectively. (Refer to table 3 for site-specific values.)
Additionally, Gay et al. (doi:10.1016/j.ejmp.2007.07.001) claim that a value of 4.0 for late effects a value of 2.0 for
tumors in 'are reasonable initial estimates in [our] experience.' Their table 2 lists (NTCP) estimates based on the work
of Emami (doi:10.1016/0360-3016(91)90171-Y).

##### Default

- ```"0.8"```

##### Examples

- ```"0.8"```
- ```"1.5"```

#### EUD_TCD50

##### Description

The uniform dose (in Gray) needed to deliver to the tumour to achieve 50% probability of local control. It is defined
only for the generalized Equivalent Uniform Dose (gEUD) model. It is a counterpart to the Martel model's 'Dose_50'
parameter, but is not quite the same (n.b., TCD_50 is a uniform dose whereas D_50 is more like a per voxel TCP-weighted
mean.) Okunieff et al. (doi:10.1016/0360-3016(94)00475-Z) computed TCD50 for tumours in human subjects across multiple
institutions; they found a median of 51.9 Gy for gross disease and a median of 37.9 Gy for microscopic disease. The
inter-quartile range was [38.4:62.8] and [27.0:49.1] respectively. (Refer to table 3 for site-specific values.) Gay et
al. (doi:10.1016/j.ejmp.2007.07.001) table 2 lists (NTCP) estimates based on the work of Emami
(doi:10.1016/0360-3016(91)90171-Y) ranging from 18-68 Gy.

##### Default

- ```"51.9"```

##### Examples

- ```"51.9"```
- ```"37.9"```

#### EUD_Alpha

##### Description

The weighting factor $\alpha$ that controls the relative weighting of volume and dose in the generalized Equivalent
Uniform Dose (gEUD) model. When $\alpha=1$, the gEUD is equivalent to the mean; when $\alpha=0$, the gEUD is equivalent
to the geometric mean. Wu et al. (doi:10.1016/S0360-3016(01)02585-8) claim that for normal tissues, $\alpha$ can be
related to the Lyman-Kutcher-Burman (LKB) model volume parameter 'n' via $\alpha=1/n$. Sovik et al.
(doi:10.1016/j.ejmp.2007.09.001) found that gEUD is not strongly impacted by error in $\alpha$. Niemierko et al. ('A
generalized concept of equivalent uniform dose. Med Phys 26:1100, 1999) generated maximum likelihood estimates for
'several tumors and normal structures' which ranged from -13.1 for local control of chordoma tumors to +17.7 for
perforation of esophagus. Gay et al. (doi:10.1016/j.ejmp.2007.07.001) table 2 lists estimates based on the work of Emami
(doi:10.1016/0360-3016(91)90171-Y) for normal tissues ranging from 1-31. Brenner et al.
(doi:10.1016/0360-3016(93)90189-3) recommend -7.2 for breast cancer, -10 for melanoma, and -13 for squamous cell
carcinomas. A 2017 presentation by Ontida Apinorasethkul claims the tumour range spans [-40:-1] and the organs at risk
range spans [1:40]. AAPM TG report 166 also provides a listing of recommended values, suggesting -10 for PTV and GTV, +1
for parotid, 20 for spinal cord, and 8-16 for rectum, bladder, brainstem, chiasm, eye, and optic nerve. Burman (1991)
and QUANTEC (2010) also provide estimates.

##### Default

- ```"-13.0"```

##### Examples

- ```"-40"```
- ```"-13.0"```
- ```"-10"```
- ```"-7.2"```
- ```"0.3"```
- ```"1"```
- ```"3"```
- ```"4"```
- ```"20"```
- ```"40"```

#### Fenwick_C

##### Description

This parameter describes the degree that superlinear doses are required to control large tumours. In other words, as
tumour volume grows, a disproportionate amount of additional dose is required to maintain the same level of control. The
Fenwick model is semi-empirical, so this number must be fitted or used from values reported in the literature. Fenwick
et al. 2008 (doi:10.1016/j.clon.2008.12.011) provide values: 9.58 for local progression free survival at 30 months for
NSCLC tumours and 5.00 for head-and-neck tumours.

##### Default

- ```"9.58"```

##### Examples

- ```"9.58"```
- ```"5.00"```

#### Fenwick_M

##### Description

This parameter describes the dose-response steepness in the Fenwick model. Fenwick et al. 2008
(doi:10.1016/j.clon.2008.12.011) provide values: 0.392 for local progression free survival at 30 months for NSCLC
tumours and 0.280 for head-and-neck tumours.

##### Default

- ```"0.392"```

##### Examples

- ```"0.392"```
- ```"0.280"```

#### Fenwick_Vref

##### Description

This parameter is the volume (in DICOM units; usually mm^3) of a reference tumour (i.e., GTV; primary tumour and
involved nodes) which the D_{50} are estimated using. In other words, this is a 'nominal' tumour volume. Fenwick et al.
2008 (doi:10.1016/j.clon.2008.12.011) recommend 148'410 mm^3 (i.e., a sphere of diameter 6.6 cm). However, an
appropriate value depends on the nature of the tumour.

##### Default

- ```"148410.0"```

##### Examples

- ```"148410.0"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data. If left empty, the column will be omitted from the output.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```


----------------------------------------------------

## ExecuteShell

### Tags

- category: meta

### Description

This operation executes the given command in a system shell.

### Parameters

- Command
- Result
- Return

#### Command

##### Description

The command(s) to execute using the system shell.

##### Default

- ```""```

##### Examples

- ```"echo example"```
- ```"echo 'another example'"```
- ```"for i in 1 2 3 ; do echo "loop iteration $i" ; done"```
- ```"for %i in (1 2 3) do echo "loop iteration %i""```

#### Result

##### Description

The name of the variable in which to store the shell's stdout. The result will be stored in the global parameter table;
the variable name corresponds to the 'key' and the stdout will be stored as the 'value.'

If no variable name is provided, the stdout will be ignored.

##### Default

- ```""```

##### Examples

- ```"result"```
- ```"stdout"```
- ```"x"```

#### Return

##### Description

The name of the variable in which to store the shell's return value (if available). The result will be stored in the
global parameter table; the variable name corresponds to the 'key' and the return value will be stored as the 'value.'

If no variable name is provided, the return value will not be recorded. However, this operation will still evaluate to
'true' only when the shell reports that the command succeeds.

##### Default

- ```""```

##### Examples

- ```"ret"```
- ```"return_value"```


----------------------------------------------------

## ExplodeImages

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation takes an image array containing multiple images and 'explodes' it, creating one new image array for each
individual image.

### Notes

- The original image array is removed and each image is appended as a separate image array.

### Parameters

- ImageSelection

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"first"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## ExportContours

### Tags

- accepts parameter: contours
- category: contour processing
- category: file export

### Description

This operation writes contour collections to a file in a simplified text format. Contour collections exported this way
should round-trip, including metadata.

### Notes

- This operation does *not* export in DICOM format. Rather, it instead uses a custom plaintext format.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- FilenameBase

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### FilenameBase

##### Description

The base filename that contours will be written to. The file format is a simplified custom text format. Metadata is
included, but will be base64 encoded if any non-printable characters are detected. If no filename is given, the default
will be used. A '_', a sequentially-increasing number, and the '.dat' file suffix are appended after the base filename.

##### Default

- ```"/tmp/dcma_exportcontours"```

##### Examples

- ```"contours"```
- ```"../somedir/data"```
- ```"/path/to/some/selected_roi_contours"```


----------------------------------------------------

## ExportDrover

### Tags

- category: RPC
- category: file export
- category: meta

### Description

This operation serializes the current Drover to a file. It uses Apache Thrift for serialization.

### Notes

- RPC functionality is currently alpha-quality code, and much is expected to change.

### Parameters

- Filename

#### Filename

##### Description

The filename to write to.

##### Default

- ```"out.ts_dcma"```

##### Examples

- ```"out.ts_dcma"```
- ```"/tmp/out.ts_dcma"```


----------------------------------------------------

## ExportFITSImages

### Tags

- accepts parameter: images
- category: file export
- category: image processing

### Description

This operation writes image arrays to FITS-formatted image files.

### Notes

- FITS images support lossless metadata export, but the metadata is embedded in a non-standard (but compliant) manner.
  Altering images using other software may result in invalidated metadata or (partial) removal of metadata.

### Parameters

- ImageSelection
- FilenameBase

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### FilenameBase

##### Description

The base filename that images will be written to. A sequentially-increasing number and file suffix are appended after
the base filename. Note that the file type is FITS.

##### Default

- ```"/tmp/dcma_exportfitsimages"```

##### Examples

- ```"../somedir/out"```
- ```"/path/to/some/dir/file_prefix"```


----------------------------------------------------

## ExportLineSamples

### Tags

- accepts parameter: line samples
- category: file export
- category: line sample processing

### Description

This operation writes a line sample to a file.

### Parameters

- LineSelection
- FilenameBase

#### LineSelection

##### Description

Select one or more line samples. Selection specifiers can be of three types: positional, metadata-based key@value regex,
and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth line sample (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last line sample.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the line sample composed of the greatest and fewest number of samples. Only one or zero line sample will be
selected; if there are ties, there is no guarantee which line sample will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple line sample based on a threshold count, i.e., where all selected line sample have
more than or fewer than $N$ samples. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all line sample that do not have the greatest number of samples, not the least-numerous line sample (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### FilenameBase

##### Description

The base filename that line samples will be written to. The file format is a 4-column text file that can be readily
plotted. The columns are 'x dx f df' where dx (df) represents the uncertainty in x (f) if available. Metadata is
included, but will be base64 encoded if any non-printable characters are detected. If no name is given, the default will
be used. A '_', a sequentially-increasing number, and the '.dat' file suffix are appended after the base filename.

##### Default

- ```"/tmp/dcma_exportlinesamples"```

##### Examples

- ```"line_sample"```
- ```"../somedir/data"```
- ```"/path/to/some/line_sample_to_plot"```


----------------------------------------------------

## ExportOriginalFiles

### Tags

- accepts parameter: contours
- accepts parameter: images
- accepts parameter: line samples
- accepts parameter: point clouds
- accepts parameter: surface meshes
- accepts parameter: tables
- category: file export

### Description

This operation attempts to copy the original file associated with the selected object(s).

Note that the original file may not be available, or may no longer be accessible. For example, when the working
directory has been modified and relative paths are used, or when network resources are used.

### Notes

- This operation does not modify the selection.

- Selectors for this operation are only considered when you explicitly provide them. The default values are not used by
  this operation.

### Parameters

- RootDirectory
- ROILabelRegex
- ROISelection
- NormalizedROILabelRegex
- ImageSelection
- LineSelection
- MeshSelection
- PointSelection
- TransformSelection
- TableSelection
- RTPlanSelection

#### RootDirectory

##### Description

The root directory in which to copy files.

##### Default

- ```"/tmp/dcma_exportoriginalfiles"```

##### Examples

- ```"/tmp"```
- ```"."```
- ```"$HOME/dcma_exportoriginalfiles/"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### LineSelection

##### Description

Select one or more line samples. Selection specifiers can be of three types: positional, metadata-based key@value regex,
and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth line sample (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last line sample.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the line sample composed of the greatest and fewest number of samples. Only one or zero line sample will be
selected; if there are ties, there is no guarantee which line sample will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple line sample based on a threshold count, i.e., where all selected line sample have
more than or fewer than $N$ samples. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all line sample that do not have the greatest number of samples, not the least-numerous line sample (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### PointSelection

##### Description

Select one or more point clouds. Note that point clouds can hold a variety of data with varying attributes, but each
point cloud is meant to represent a single logically cohesive collection of points. Be aware that it is possible to mix
logically unrelated points together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TransformSelection

##### Description

Select one or more transform objects (aka 'warp' objects). Selection specifiers can be of three types: positional,
metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth transformation (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last transformation.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the transformation composed of the greatest and fewest number of sub-objects. Only one or zero transformation
will be selected; if there are ties, there is no guarantee which transformation will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple transformation based on a threshold count, i.e., where all selected transformation
have more than or fewer than $N$ sub-objects. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all transformation that do not have the greatest number of sub-objects, not the least-numerous
transformation (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### RTPlanSelection

##### Description

Select one or more treatment plans. Note that a single treatment plan may be composed of multiple beams; if delivered
sequentially, they should collectively represent a single logically cohesive plan. Selection specifiers can be of three
types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth treatment plan (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last treatment plan.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the treatment plan composed of the greatest and fewest number of control points. Only one or zero treatment plan
will be selected; if there are ties, there is no guarantee which treatment plan will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple treatment plan based on a threshold count, i.e., where all selected treatment plan
have more than or fewer than $N$ control points. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all treatment plan that do not have the greatest number of control points, not the least-numerous
treatment plan (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## ExportPointClouds

### Tags

- accepts parameter: point clouds
- category: file export
- category: point cloud processing

### Description

This operation writes point clouds to file.

### Parameters

- PointSelection
- FilenameBase

#### PointSelection

##### Description

Select one or more point clouds. Note that point clouds can hold a variety of data with varying attributes, but each
point cloud is meant to represent a single logically cohesive collection of points. Be aware that it is possible to mix
logically unrelated points together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### FilenameBase

##### Description

The base filename that line samples will be written to. The file format is 'XYZ' -- a 3-column text file containing
vector coordinates of the points. Metadata is excluded. A '_', a sequentially-increasing number, and the '.xyz' file
suffix are appended after the base filename.

##### Default

- ```"/tmp/dcma_exportpointclouds"```

##### Examples

- ```"point_cloud"```
- ```"../somedir/data"```
- ```"/path/to/some/points"```


----------------------------------------------------

## ExportSNCImages

### Tags

- accepts parameter: images
- category: file export
- category: image processing

### Description

This operation writes image arrays to ASCII 'SNC' formatted files.

### Notes

- Support for this format is ad-hoc. Metadata export is not supported.

### Parameters

- ImageSelection
- FilenameBase

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### FilenameBase

##### Description

The base filename that images will be written to. A sequentially-increasing number and file suffix are appended after
the base filename. Note that the file type is ASCII SNC.

##### Default

- ```"/tmp/dcma_exportsncimages"```

##### Examples

- ```"../somedir/out"```
- ```"/path/to/some/dir/file_prefix"```


----------------------------------------------------

## ExportSurfaceMeshes

### Tags

- accepts parameter: surface meshes
- category: file export
- category: mesh processing

### Description

This operation writes one or more surface meshs to file in the 'Stanford' Polygon File format.

### Notes

- Support for metadata in PLY files is fully supported. Surface mesh metadata will be encoded in specially-marked
  comments and base64 encoded if non-printable characters are present. Metadata will be recovered when PLY files are
  loaded in DICOMautomaton. Note that other software may disregard these comments.

### Parameters

- MeshSelection
- Filename
- Variant

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

The filename (or full path name) to which the surface mesh data should be written. Existing files will not be
overwritten. If an invalid or missing file extension is provided, one will automatically be added. If an empty filename
is given, a unique name will be chosen automatically. If multiple meshes are selected, each will be written to a
separate file; the name of each will be derived from the user-provided filename (or default) by appending a sequentially
increasing counter between the file's stem name and extension. Files will be formatted in Stanford Polygon File ('PLY')
format.

##### Default

- ```""```

##### Examples

- ```"surface_mesh.ply"```
- ```"../somedir/mesh.ply"```
- ```"/path/to/some/surface_mesh.ply"```

#### Variant

##### Description

Controls whether files are written in the binary or ASCII PLY file format variants. Binary files will generally be
smaller, and therefore faster to write, but may be less portable. ASCII format is better suited for archival purposes,
and may be more widely supported. ASCII is generally recommended unless performance or storage will be problematic.

##### Default

- ```"ascii"```

##### Supported Options

- ```"ascii"```
- ```"binary"```


----------------------------------------------------

## ExportSurfaceMeshesOBJ

### Tags

- accepts parameter: surface meshes
- category: file export
- category: mesh processing

### Description

This operation writes one or more surface meshes to file in Wavefront Object ('OBJ') format.

### Notes

- Support for metadata in OBJ files is currently limited. Metadata will generally be lost.

- OBJ files can refer to MTL 'sidecar' files for information about materials and various properties. MTL files are not
  supported at this time.

### Parameters

- MeshSelection
- Filename

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

The filename (or full path name) to which the surface mesh data should be written. Existing files will not be
overwritten. If an invalid or missing file extension is provided, one will automatically be added. If an empty filename
is given, a unique name will be chosen automatically. If multiple meshes are selected, each will be written to a
separate file; the name of each will be derived from the user-provided filename (or default) by appending a sequentially
increasing counter between the file's stem name and extension. Files will be formatted in ASCII Wavefront Object ('OBJ')
format.

##### Default

- ```""```

##### Examples

- ```"surface_mesh.obj"```
- ```"../somedir/mesh.obj"```
- ```"/path/to/some/surface_mesh.obj"```


----------------------------------------------------

## ExportSurfaceMeshesOFF

### Tags

- accepts parameter: surface meshes
- category: file export
- category: mesh processing

### Description

This operation writes one or more surface meshes to file in Object File Format ('OFF').

### Notes

- Support for metadata in OFF files is currently limited. Metadata will generally be lost.

- OFF files can contain many different types of geometry, and some software may not support the specific subset used by
  DICOMautomaton. For example, vertex normals may not be supported, and their presence can cause some OFF file loaders
  to reject valid OFF files. For the best portability, consider more common formats like PLY or OBJ.

### Parameters

- MeshSelection
- Filename

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

The filename (or full path name) to which the surface mesh data should be written. Existing files will not be
overwritten. If an invalid or missing file extension is provided, one will automatically be added. If an empty filename
is given, a unique name will be chosen automatically. If multiple meshes are selected, each will be written to a
separate file; the name of each will be derived from the user-provided filename (or default) by appending a sequentially
increasing counter between the file's stem name and extension. Files will be formatted in Object File Format ('OFF').

##### Default

- ```""```

##### Examples

- ```"surface_mesh.off"```
- ```"../somedir/mesh.off"```
- ```"/path/to/some/surface_mesh.off"```


----------------------------------------------------

## ExportSurfaceMeshesPLY

### Tags

- accepts parameter: surface meshes
- category: file export
- category: mesh processing

### Description

This operation writes one or more surface meshs to file in the 'Stanford' Polygon File format.

### Notes

- Support for metadata in PLY files is fully supported. Surface mesh metadata will be encoded in specially-marked
  comments and base64 encoded if non-printable characters are present. Metadata will be recovered when PLY files are
  loaded in DICOMautomaton. Note that other software may disregard these comments.

### Parameters

- MeshSelection
- Filename
- Variant

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

The filename (or full path name) to which the surface mesh data should be written. Existing files will not be
overwritten. If an invalid or missing file extension is provided, one will automatically be added. If an empty filename
is given, a unique name will be chosen automatically. If multiple meshes are selected, each will be written to a
separate file; the name of each will be derived from the user-provided filename (or default) by appending a sequentially
increasing counter between the file's stem name and extension. Files will be formatted in Stanford Polygon File ('PLY')
format.

##### Default

- ```""```

##### Examples

- ```"surface_mesh.ply"```
- ```"../somedir/mesh.ply"```
- ```"/path/to/some/surface_mesh.ply"```

#### Variant

##### Description

Controls whether files are written in the binary or ASCII PLY file format variants. Binary files will generally be
smaller, and therefore faster to write, but may be less portable. ASCII format is better suited for archival purposes,
and may be more widely supported. ASCII is generally recommended unless performance or storage will be problematic.

##### Default

- ```"ascii"```

##### Supported Options

- ```"ascii"```
- ```"binary"```


----------------------------------------------------

## ExportSurfaceMeshesSTL

### Tags

- accepts parameter: surface meshes
- category: file export
- category: mesh processing

### Description

This operation writes one or more surface meshes to file in the (3D Systems) Stereolithography format.

### Notes

- Support for metadata in STL files is currently limited. Metadata will generally be lost.

- The STL format is generally meant to be sent to hardware with limited processing power or memory, and is pre-processed
  so that individual faces can be easily streamed. This pre-processing destroys information about the mesh, for example
  face adjacency. This information can be hard or impossible to fully recover. If you need to later process, or
  re-process a surface mesh, avoid the STL file format if possible. Alternatives supported by DICOMautomaton include
  PLY, OBJ, and OFF formats.

### Parameters

- MeshSelection
- Filename
- Variant

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

The filename (or full path name) to which the surface mesh data should be written. Existing files will not be
overwritten. If an invalid or missing file extension is provided, one will automatically be added. If an empty filename
is given, a unique name will be chosen automatically. If multiple meshes are selected, each will be written to a
separate file; the name of each will be derived from the user-provided filename (or default) by appending a sequentially
increasing counter between the file's stem name and extension. Files will be formatted in Stereolithography ('STL')
format.

##### Default

- ```""```

##### Examples

- ```"surface_mesh.stl"```
- ```"../somedir/mesh.stl"```
- ```"/path/to/some/surface_mesh.stl"```

#### Variant

##### Description

Controls whether files are written in the binary or ASCII STL file format variants. Binary files will generally be
smaller, and therefore faster to write, but may be less portable. ASCII format is better suited for archival purposes,
and may be more widely supported. ASCII is generally recommended unless performance or storage will be problematic.

##### Default

- ```"ascii"```

##### Supported Options

- ```"ascii"```
- ```"binary"```


----------------------------------------------------

## ExportTables

### Tags

- accepts parameter: tables
- category: acquires futex
- category: file export
- category: table processing

### Description

This operation exports the selected table(s) into a single CSV formatted file.

### Parameters

- TableSelection
- Filename

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

The exported file's name. The format is CSV. Leave empty to generate a unique temporary file. If an existing file is
present, the contents will be appended. If multiple tables are selected, they will all be appended to the same file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```


----------------------------------------------------

## ExportWarps

### Tags

- category: file export
- category: spatial transform processing

### Description

This operation exports a transform object (e.g., affine matrix, TPS, vector deformation field) to file.

### Notes

- Written files include all available metadata. Unprintable characters are transparently base-64 encoded.

### Parameters

- TransformSelection
- Filename

#### TransformSelection

##### Description

The transformation that will be exported. Select one or more transform objects (aka 'warp' objects). Selection
specifiers can be of three types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth transformation (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last transformation.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the transformation composed of the greatest and fewest number of sub-objects. Only one or zero transformation
will be selected; if there are ties, there is no guarantee which transformation will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple transformation based on a threshold count, i.e., where all selected transformation
have more than or fewer than $N$ sub-objects. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all transformation that do not have the greatest number of sub-objects, not the least-numerous
transformation (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```

#### Filename

##### Description

The filename (or full path name) to which the transformation should be written. Existing files will be overwritten. If
no name is given, a unique name will be chosen automatically.

##### Default

- ```""```

##### Examples

- ```"transformation.trans"```
- ```"affine.trans"```
- ```"/path/to/some/mapping.trans"```


----------------------------------------------------

## ExtractAlphaBeta

### Tags

- accepts parameter: contours
- category: image processing
- category: radiation dose

### Description

This operation compares two images arrays: either a biologically-equivalent dose ($BED_{\alpha/\beta}$) transformed
array or an equivalent dose in $d$ dose per fraction ($EQD_{x}$) array and a 'reference' untransformed array. The
$\alpha/\beta$ used for each voxel are extracted by comparing corresponding voxels. Each voxel is overwritten with the
value of $\alpha/\beta$ needed to accomplish the given transform. This routine is best used to inspect a given
transformation (e.g., for QA purposes).

### Notes

- Images are overwritten, but ReferenceImages are not. Multiple Images may be specified, but only one ReferenceImages
  may be specified.

- The reference image array must be rectilinear. (This is a requirement specific to this implementation, a less
  restrictive implementation could overcome the issue.)

- For the fastest and most accurate results, test and reference image arrays should spatially align. However, alignment
  is **not** necessary. If test and reference image arrays are aligned, image adjacency can be precomputed and the
  analysis will be faster. If not, image adjacency must be evaluated for each image slice. If this also fails, it will
  be evaluated for every voxel.

- This operation will make use of interpolation if corresponding voxels do not exactly overlap.

### Parameters

- TransformedImageSelection
- ReferenceImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Model
- Channel
- TestImgLowerThreshold
- TestImgUpperThreshold
- NumberOfFractions
- NominalDosePerFraction

#### TransformedImageSelection

##### Description

The transformed image array where voxel intensities represent BED or EQDd. Select one or more image arrays. Note that
image arrays can hold anything, but will typically represent a single contiguous 3D volume (i.e., a volumetric CT scan)
or '4D' time-series. Be aware that it is possible to mix logically unrelated images together. Selection specifiers can
be of three types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"first"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ReferenceImageSelection

##### Description

The un-transformed image array where voxel intensities represent (non-BED) dose. Select one or more image arrays. Note
that image arrays can hold anything, but will typically represent a single contiguous 3D volume (i.e., a volumetric CT
scan) or '4D' time-series. Be aware that it is possible to mix logically unrelated images together. Selection specifiers
can be of three types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Model

##### Description

The model of BED or EQDx transformation to assume. Currently, only 'eqdx-lq-simple' is available. The 'eqdx-lq-simple'
model does not take into account elapsed time or any cell repopulation effects.

##### Default

- ```"eqdx-lq-simple"```

##### Supported Options

- ```"eqdx-lq-simple"```

#### Channel

##### Description

The channel to compare (zero-based). Setting to -1 will compare each channel separately. Note that both test images and
reference images must share this specifier.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```

#### TestImgLowerThreshold

##### Description

Pixel lower threshold for the test images. Only voxels with values above this threshold (inclusive) will be altered.

##### Default

- ```"-inf"```

##### Examples

- ```"-inf"```
- ```"0.0"```
- ```"200"```

#### TestImgUpperThreshold

##### Description

Pixel upper threshold for the test images. Only voxels with values below this threshold (inclusive) will be altered.

##### Default

- ```"inf"```

##### Examples

- ```"inf"```
- ```"1.23"```
- ```"1000"```

#### NumberOfFractions

##### Description

Number of fractions assumed in the BED or EQDd transformation.

##### Default

- ```"35"```

##### Examples

- ```"1"```
- ```"5"```
- ```"35"```

#### NominalDosePerFraction

##### Description

The nominal dose per fraction (in DICOM units; Gy) assumed by an EQDx transformation. This parameter is the 'x' in
'EQDx'; for EQD2 transformations, this parameter must be 2 Gy.

##### Default

- ```"2.0"```

##### Examples

- ```"1.8"```
- ```"2.0"```
- ```"8.0"```


----------------------------------------------------

## ExtractImageHistograms

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: contour processing
- category: image processing
- category: line sample processing

### Description

This operation extracts histograms (e.g., dose-volume -- DVH, or pixel intensity-volume) for the selected image(s) and
ROI(s). Results are stored as line samples for later analysis or export.

### Notes

- This routine generates differential histograms with unscaled abscissae and ordinate axes. It also generates cumulative
  histograms with unscaled abscissae and *both* unscaled and peak-normalized-to-one ordinates. Unscaled abscissa are
  reported in DICOM units (typically HU or Gy), unscaled ordinates are reported in volumetric DICOM units (mm^3^), and
  normalized ordinates are reported as a fraction of the given ROI's total volume.

- Non-finite voxels are excluded from analysis and do not contribute to the volume. If exact volume is required, ensure
  all voxels are finite prior to invoking this routine.

- This routine can handle contour partitions where the physical layout (i.e., storage order) differs from the logical
  layout. See the 'grouping' options for available configuration.

- This routine will correctly handle non-overlapping voxels with varying volumes (i.e., rectilinear image arrays). It
  will *not* correctly handle overlapping voxels (i.e., each overlapping voxel will be counted without regard for
  overlap). If necessary, resample image arrays to be rectilinear.

### Parameters

- ImageSelection
- Channel
- ROILabelRegex
- ROISelection
- NormalizedROILabelRegex
- ContourOverlap
- Inclusivity
- Grouping
- GroupLabel
- Lower
- Upper
- dDose
- BinCount
- UserComment

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Channel

##### Description

The image channel to use. Zero-based. Use '-1' to operate on all available channels.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. The option 'honour_opposite_orientations' makes overlapping contours with opposite
orientation cancel. Otherwise, orientation is ignored. The latter is useful for Boolean structures where contour
orientation is significant for interior contours (holes). The option 'overlapping_contours_cancel' ignores orientation
and cancels all contour overlap.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### Grouping

##### Description

This routine partitions individual contours using their ROI labels. This parameter controls whether contours with
different names should be treated as though they belong to distinct logical groups ('separate') or whether *all*
contours should be treated as though they belong to a single logical group ('combined').

The 'separate' option works best for exploratory analysis, extracting histograms for many OARs at once, or when you know
the 'physical' grouping of contours by label reflects a consistent logical grouping.

The 'combined' option works best when the physical and logical groupings are inconsistent. For example, when you need a
combined histograms from multiple contours or organs, or when similar structures should be combined (e.g., spinal cord +
canal; or distinct left + right lateral organs that should be paired, e.g.. 'combined parotids'). Note that when the
'combined' option is used, the 'GroupLabel' parameter *must* also be provided. Also note that 'grouped' can be used as a
synonym for 'combined'.

##### Default

- ```"separate"```

##### Supported Options

- ```"separate"```
- ```"combined"```
- ```"grouped"```

#### GroupLabel

##### Description

If the 'Grouping' parameter is set to 'combined', the value of the 'GroupLabel' parameter will be used as the
histogram's ROILabel in lieu of any consitituent ROILabels. Note that this parameter *must* be provided when the
'Grouping' parameter is set to'combined'.

##### Default

- ```""```

##### Examples

- ```"combination"```
- ```"multiple_rois"```
- ```"logical_oar"```
- ```"both_oars"```

#### Lower

##### Description

Disregard all voxel values lower than this value. This parameter can be used to filter out spurious values. All voxels
with infinite or NaN intensities are excluded regardless of this parameter. Note that disregarded values will not
contribute any volume.

##### Default

- ```"-inf"```

##### Examples

- ```"-inf"```
- ```"-100.0"```
- ```"0.0"```
- ```"1.2"```
- ```"5.0E23"```

#### Upper

##### Description

Disregard all voxel values greater than this value. This parameter can be used to filter out spurious values. All voxels
with infinite or NaN intensities are excluded regardless of this parameter. Note that disregarded values will not
contribute any volume.

##### Default

- ```"inf"```

##### Examples

- ```"-100.0"```
- ```"0.0"```
- ```"1.2"```
- ```"5.0E23"```
- ```"inf"```

#### dDose

##### Description

The (fixed) bin width, in units of dose (DICOM units; nominally Gy). Note that this is the *maximum* bin width, in
practice bins may be smaller to account for slop (i.e., excess caused by the extrema being separated by a non-integer
number of bins of width $dDose$).

Note that one of either 'dDose' or 'BinCount' must be provided.

##### Default

- ```"0.1"```

##### Examples

- ```"0.0001"```
- ```"0.001"```
- ```"0.01"```
- ```"5.0"```
- ```"10"```
- ```"50"```

#### BinCount

##### Description

The number of bins to use in the histogram. The bin width depends on the data range.

Note that one of either 'dDose' or 'BinCount' must be provided.

##### Default

- ```"1000"```

##### Examples

- ```"10"```
- ```"1000"```
- ```"10000"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data. If left empty, the column will be omitted from the output.

##### Default

- ```""```

##### Examples

- ```"Using XYZ"```
- ```"Patient treatment plan C"```


----------------------------------------------------

## ExtractPointsWarp

### Tags

- category: image processing
- category: spatial transform processing

### Description

This operation uses two point clouds (one 'moving' and the other 'stationary' or 'reference') to find a transformation
('warp') that will map the moving point set to the stationary point set. The resulting transformation encapsulates a
'registration' between the two point sets -- however the transformation is generic and can be later be used to move
(i.e., 'warp', 'deform') other objects, including the 'moving' point set.

### Notes

- The 'moving' point cloud is *not* warped by this operation -- this operation merely identifies a suitable
  transformation. Separation of the identification and application of a warp allows the warp to more easily re-used and
  applied to multiple objects.

- The output of this operation is a transformation that can later be applied, in principle, to point clouds, surface
  meshes, images, arbitrary vector fields, and any other objects in $R^{3}$.

- There are multiple algorithms implemented. Some do *not* provide bijective mappings, meaning that swapping the inputs
  will result in an altogether different registration (even after inverting it).

### Parameters

- MovingPointSelection
- ReferencePointSelection
- Method
- TPSLambda
- TPSKernelDimension
- TPSSolver
- TPSRPMLambdaStart
- TPSRPMZetaStart
- TPSRPMDoubleSidedOutliers
- TPSRPMKernelDimension
- TPSRPMTStart
- TPSRPMTEnd
- TPSRPMTStep
- TPSRPMStepsPerT
- TPSRPMSinkhornMaxSteps
- TPSRPMSinkhornTolerance
- TPSRPMSeedWithCentroidShift
- TPSRPMSolver
- TPSRPMHardConstraints
- TPSRPMPermitMovingOutliers
- TPSRPMPermitStationaryOutliers
- MaxIterations
- RelativeTolerance

#### MovingPointSelection

##### Description

The point cloud that will serve as input to the warp function. Select one or more point clouds. Note that point clouds
can hold a variety of data with varying attributes, but each point cloud is meant to represent a single logically
cohesive collection of points. Be aware that it is possible to mix logically unrelated points together. Selection
specifiers can be of three types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ReferencePointSelection

##### Description

The stationary point cloud to use as a reference for the moving point cloud. Select one or more point clouds. Note that
point clouds can hold a variety of data with varying attributes, but each point cloud is meant to represent a single
logically cohesive collection of points. Be aware that it is possible to mix logically unrelated points together.
Selection specifiers can be of three types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified. Note that this point cloud is not modified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Method

##### Description

The alignment algorithm to use. The following alignment options are available: 'centroid', 'PCA', 'exhaustive_icp',
'TPS', and 'TPS-RPM'. The 'centroid' option finds a rotationless translation the aligns the centroid (i.e., the centre
of mass if every point has the same 'mass') of the moving point cloud with that of the stationary point cloud. It is
susceptible to noise and outliers, and can only be reliably used when the point cloud has complete rotational symmetry
(i.e., a sphere). On the other hand, 'centroid' alignment should never fail, can handle a large number of points, and
can be used in cases of 2D and 1D degeneracy. centroid alignment is frequently used as a pre-processing step for more
advanced algorithms. The 'PCA' option finds an Affine transformation by performing centroid alignment, performing
principle component analysis (PCA) separately on the reference and moving point clouds, computing third-order point
distribution moments along each principle axis to establish a consistent orientation, and then rotates the moving point
cloud so the principle axes of the stationary and moving point clouds coincide. The 'PCA' method may be suitable when:
(1) both clouds are not contaminated with extra noise points (but some Gaussian noise in the form of point 'jitter'
should be tolerated) and (2) the clouds are not perfectly spherical (i.e., so they have valid principle components).
However, note that the 'PCA' method is susceptible to outliers and can not scale a point cloud. The 'PCA' method will
generally fail when the distribution of points shifts across the centroid (i.e., comparing reference and moving point
clouds) since the orientation of the components will be inverted, however 2D degeneracy is handled in a 3D-consistent
way, and 1D degeneracy is handled in a 1D-consistent way (i.e, the components orthogonal to the common line will be
completely ambiguous, so spurious rotations will result). The 'exhaustive_icp' option finds an Affine transformation by
first performing PCA-based alignment and then iteratively alternating between (1) estimating point-point correspondence
and (1) solving for a least-squares optimal transformation given this correspondence estimate. 'ICP' stands for
'iterative closest point.' Each iteration uses the previous transformation *only* to estimate correspondence; a
least-squares optimal linear transform is estimated afresh each iteration. The 'exhaustive_icp' method is most suitable
when both point clouds consist of approximately 50k points or less. Beyond this, ICP will still work but runtime scales
badly. ICP is susceptible to outliers and will not scale a point cloud. It can be used for 2D and 1D degenerate
problems, but is not guaranteed to find the 'correct' orientation of degenerate or symmetrical point clouds. The 'TPS'
or Thin-Plate Spline algorithm provides non-rigid (i.e., 'deformable') registration between corresponding point sets.
The moving and stationary point sets must have the same number of points, and the $n$^th^ moving point is taken to
correspond to the $n$^th^ stationary point. The 'TPS' method does not scale well due in part to inversion of a large
(NxN) matrix and is therefore most suitable when both point clouds consist of approximately 10-20k points or less.
Beyond this, expect slow calculations. The TPS method is not robust to outliers, however a regularization parameter can
be used to control the smoothness of the warp. (Setting to zero will cause the warp function to exactly interpolate
every pair, except due to floating point inaccuracies.) Also note that the TPS method can only, in general, be used for
interpolation. Extrapolation beyond the points clouds will almost certainly result in wildly inconsistent and unstable
transformations. Consult Bookstein 1989 (doi:10.1109/34.24792) for an overview. The 'TPS-RPM' or Thin-Plate Spline
Robust Point-Matching algorithm provides non-rigid (i.e., 'deformable') registration. It combines a soft-assign
technique, deterministic annealing, and thin-plate splines to iteratively solve for correspondence and spatial warp. The
'TPS-RPM' method is (somewhat) robust to outliers in both moving and stationary point sets, but it suffers from
numerical instabilities when one or more inputs are degenerate or symmetric in such a way that many potential solutions
have the same least-square cost. The 'TPS-RPM' method does not scale well due in part to inversion of a large (NxM)
matrix and is therefore most suitable when both point clouds consist of approximately 1-5k points or less. Beyond this,
expect slow calculations. Also note that the underlying TPS method can only, in general, be used for interpolation.
Extrapolation beyond the extent of the corresponding parts of the points clouds will almost certainly result in wildly
inconsistent and unstable transformations. Consult Chui and Rangarajan 2000 (original algorithm;
doi:10.1109/CVPR.2000.854733) and Yang 2011 (clarification and more robust solution; doi:10.1016/j.patrec.2011.01.015)
for more details.

##### Default

- ```"centroid"```

##### Supported Options

- ```"centroid"```
- ```"pca"```
- ```"exhaustive_icp"```
- ```"tps"```
- ```"tps_rpm"```

#### TPSLambda

##### Description

Regularization parameter for the TPS method. Controls the smoothness of the fitted thin plate spline function. Setting
to zero will ensure that all points are interpolated exactly (barring numerical imprecision). Setting higher will allow
the spline to 'relax' and smooth out. The specific value to use is heavily dependent on the problem domain and the
amount of noise and outliers in the data. It relates to the spacing between points. Note that this parameter is used
with the TPS method, but *not* in the TPS-RPM method.

##### Default

- ```"0.0"```

##### Examples

- ```"1E-4"```
- ```"0.1"```
- ```"10.0"```

#### TPSKernelDimension

##### Description

Dimensionality of the spline function kernel. The kernel dimensionality *should* match the dimensionality of the points
(i.e., 3), but doesn't need to. 2 seems to work best, even with points in 3D. Note that this parameter may affect how
the transformation extrapolates.

##### Default

- ```"2"```

##### Examples

- ```"2"```
- ```"3"```

#### TPSSolver

##### Description

The method used to solve the system of linear equtions that defines the thin plate spline solution. The pseudoinverse
will likely be able to provide a solution when the system is degenerate, but it might not be reasonable or even
sensible. The LDLT method scales better.

##### Default

- ```"LDLT"```

##### Supported Options

- ```"LDLT"```
- ```"PseudoInverse"```

#### TPSRPMLambdaStart

##### Description

Regularization parameter for the TPS-RPM method. Controls the smoothness of the fitted thin plate spline function.
Setting to zero will ensure that all points are interpolated exactly (barring numerical imprecision). Setting higher
will allow the spline to 'relax' and smooth out. The specific value to use is heavily dependent on the problem domain
and the amount of noise and outliers in the data. It relates to the spacing between points. It follows the same
annealing schedule as the system temperature does. Note that this parameter is used with the TPS-RPM method, but *not*
in the TPS method.

##### Default

- ```"0.0"```

##### Examples

- ```"0.0"```
- ```"1E-4"```
- ```"0.1"```
- ```"10.0"```

#### TPSRPMZetaStart

##### Description

Regularization parameter for the TPS-RPM method. Controls the likelihood of points being treated as outliers. Higher
values will bias points towards *not* being considered outliers. The specific value to use is heavily dependent on the
problem domain and the amount of noise and outliers in the data. It relates to the spacing between points. It follows
the same annealing schedule as the system temperature does. Note that this parameter is used with the TPS-RPM method,
but *not* in the TPS method.

##### Default

- ```"0.0"```

##### Examples

- ```"0.0"```
- ```"1E-4"```
- ```"0.1"```
- ```"10.0"```

#### TPSRPMDoubleSidedOutliers

##### Description

Controls whether the extensions for 'double sided outlier handling' as described by Yang et al. (2011;
doi:10.1016/j.patrec.2011.01.015) are used. These extensions can improve resilience to outliers, especially in the
moving set. Yang et al. also mention that the inclusion of an extra entropy term in the cost function can help reduce
jitter during the annealing process, which may result in fewer folds or twists for narrow point clouds. However, the
resulting algorithm is overall less numerically stable and has a strong dependence on the kernel dimension. Enabling
this parameter adjusts the interpretation of the lambda regularization parameter, so some fine-tuning may be required.
Note that this parameter is used with the TPS-RPM method, but *not* in the TPS method.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```

#### TPSRPMKernelDimension

##### Description

Dimensionality of the spline function kernel. The kernel dimensionality *should* match the dimensionality of the points
(i.e., 3), but doesn't need to. 2 seems to work best, even with points in 3D. Note that this parameter may affect how
the transformation extrapolates. Note that this parameter is used with the TPS-RPM method, but *not* in the TPS method.

##### Default

- ```"2"```

##### Supported Options

- ```"2"```
- ```"3"```

#### TPSRPMTStart

##### Description

The deterministic annealing starting temperature. This parameter is a scaling factor that modifies the temperature
determined via an automatic method. Larger numbers grant the system more freedom to find large-scale deformation; small
values *limit* the freedom to find large-scale deformations. Note that this parameter is used with the TPS-RPM method,
but *not* in the TPS method.

##### Default

- ```"1.05"```

##### Examples

- ```"1.5"```
- ```"1.05"```
- ```"0.8"```
- ```"0.5"```

#### TPSRPMTEnd

##### Description

The deterministic annealing ending temperature. Higher numbers will result in a coarser, but faster registration. This
parameter is a scaling factor that modifies the temperature determined via an automatic method. Larger numbers limit the
freedom of the system to find fine-detail deformations; small values may result in overfitting and folding deformations.
Note that this parameter is used with the TPS-RPM method, but *not* in the TPS method.

##### Default

- ```"0.01"```

##### Examples

- ```"1.0"```
- ```"0.1"```
- ```"0.01"```

#### TPSRPMTStep

##### Description

The deterministic annealing ending temperature. Higher numbers will result in slower annealing. This parameter is a
multiplicative factor, so if set to 0.95 temperature adjustments will be $T^{\prime} = 0.95 T$. Note that this parameter
is used with the TPS-RPM method, but *not* in the TPS method.

##### Default

- ```"0.93"```

##### Examples

- ```"0.99"```
- ```"0.93"```
- ```"0.9"```

#### TPSRPMStepsPerT

##### Description

Deterministic annealing parameter controlling the number of correspondence-transformation update iterations performed at
each temperature. Lower numbers will result in faster, but possibly less accurate registrations. Note that this
parameter is used with the TPS-RPM method, but *not* in the TPS method.

##### Default

- ```"5"```

##### Examples

- ```"1"```
- ```"5"```
- ```"10"```

#### TPSRPMSinkhornMaxSteps

##### Description

Parameter controlling the number of iterations performed during the Sinkhorn softassign correspondence estimation
procedure. Note that this is the worst-case number of iterations since the Sinkhorn procedure completes when tolerance
is reached. Setting this number to the maximum number of iterations acceptable given your speed requirements should
result in satisfactory results. Note that use of forced correspondence *may* require a higher number of steps. Note that
this parameter is used with the TPS-RPM method, but *not* in the TPS method.

##### Default

- ```"5000"```

##### Examples

- ```"500"```
- ```"5000"```
- ```"50000"```
- ```"500000"```

#### TPSRPMSinkhornTolerance

##### Description

Parameter controlling the permissable deviation from the ideal softassign correspondence normalization conditions (i.e.,
that each row and each column sum to one). If tolerance is reached then the Sinkhorn procedure is completed early.
However, if the maximum number of iterations is reached and the tolerance has not been achieved then the algorithm
terminates due to failure. If registration quality is flexible, setting a higher number can significantly speed up the
computation. Note that this parameter is used with the TPS-RPM method, but *not* in the TPS method.

##### Default

- ```"0.01"```

##### Examples

- ```"1E-4"```
- ```"0.001"```
- ```"0.01"```

#### TPSRPMSeedWithCentroidShift

##### Description

Controls whether a centroid-based registration is used to seed the registration. Typically this is not needed, since
high temperatures give the system enough freedom to find large-scale deformations (include centroid alignment). However,
if the initial alignment is intentional, and point cloud centroids do not align, then seeding the registration will be
detrimental. Seeding might be useful if the starting temperature is set low (which will limit large-scale deformations
like centroid alignment). Note that this parameter is used with the TPS-RPM method, but *not* in the TPS method.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```

#### TPSRPMSolver

##### Description

The method used to solve the system of linear equtions that defines the thin plate spline solution. The pseudoinverse
will likely be able to provide a solution when the system is degenerate, but it might not be reasonable or even
sensible. The LDLT method scales better. Note that this parameter is used with the TPS-RPM method, but *not* in the TPS
method.

##### Default

- ```"LDLT"```

##### Supported Options

- ```"LDLT"```
- ```"PseudoInverse"```

#### TPSRPMHardConstraints

##### Description

Forced correspondence between pairs of points (one in the moving set, one in the stationary set) specified as
comma-separated pairs of indices into the moving and stationary point sets. Indices are zero-based. Forced
correspondences are taken to be exclusive, meaning that no other points will correspond with either points. Forced
correspondence also begets outlier rejection, so ensure the points are not tainted by noise or are outliers. Note that
points can be forced to be treated as outliers by indicating a non-existent index in the opposite set, such as -1. Use
of forced correspondence may cause the Sinkhorn method to converge slowly or possibly fail to converge at all.
Increasing the number of Sinkhorn iterations may be required. Marking points as outliers has ramifications within the
algorithm that can lead to numerical instabilities (especially in the moving point set). If possible, it is best to
remove known outlier points *prior* to attempting registration. Note that this parameter is used with the TPS-RPM
method, but *not* in the TPS method.

##### Default

- ```""```

##### Examples

- ```"0,10"```
- ```"23,45, 24,46, 0,100, -1,50, 20,-1"```

#### TPSRPMPermitMovingOutliers

##### Description

If enabled, this option permits the TPS-RPM algorithm to automatically detect and eschew outliers in the moving point
set. A major strength of the TPS-RPM algorithm is that it can handle outliers, however there are legitimate cases where
outliers are known *not* to be present, but the point-to-point correspondence is *not* known. Note that outlier
detection cannot be used when one or more points are forced to be outliers. Similar to forced correspondence (i.e., hard
constraints), disabling outlier detection can modify the Sinkhorn algorithm convergence. Additionally, Sinkhorn
normalization is likely to fail when outliers in the larger point cloud are disallowed. Note that this parameter is used
with the TPS-RPM method, but *not* in the TPS method.

##### Default

- ```"true"```

##### Examples

- ```"true"```
- ```"false"```

#### TPSRPMPermitStationaryOutliers

##### Description

If enabled, this option permits the TPS-RPM algorithm to automatically detect and eschew outliers in the stationary
point set. A major strength of the TPS-RPM algorithm is that it can handle outliers, however there are legitimate cases
where outliers are known *not* to be present, but the point-to-point correspondence is *not* known. Note that outlier
detection cannot be used when one or more points are forced to be outliers. Similar to forced correspondence (i.e., hard
constraints), disabling outlier detection can modify the Sinkhorn algorithm convergence. Additionally, Sinkhorn
normalization is likely to fail when outliers in the larger point cloud are disallowed. Note that this parameter is used
with the TPS-RPM method, but *not* in the TPS method.

##### Default

- ```"true"```

##### Examples

- ```"true"```
- ```"false"```

#### MaxIterations

##### Description

If the method is iterative, only permit this many iterations to occur. Note that this parameter will not have any effect
on non-iterative methods.

##### Default

- ```"100"```

##### Examples

- ```"5"```
- ```"20"```
- ```"100"```
- ```"1000"```

#### RelativeTolerance

##### Description

If the method is iterative, terminate the loop when the cost function changes between successive iterations by this
amount or less. The magnitude of the cost function will generally depend on the number of points (in both point clouds),
the scale (i.e., 'width') of the point clouds, the amount of noise and outlier points, and any method-specific
parameters that impact the cost function (if applicable); use of this tolerance parameter may be impacted by these
characteristics. Verifying that a given tolerance is of appropriate magnitude is recommended. Relative tolerance checks
can be disabled by setting to non-finite or negative value. Note that this parameter will only have effect on iterative
methods that are not controlled by, e.g., an annealing schedule.

##### Default

- ```"nan"```

##### Examples

- ```"-1"```
- ```"1E-2"```
- ```"1E-3"```
- ```"1E-5"```


----------------------------------------------------

## ExtractRadiomicFeatures

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: acquires futex
- category: file export
- category: image processing

### Description

This operation extracts radiomic features from the selected images. Features are implemented as per specification in the
Image Biomarker Standardisation Initiative (IBSI) or pyradiomics documentation if the IBSI specification is unclear or
ambiguous.

### Notes

- This routine is meant to be processed by an external analysis.

- If this routine is slow, simplifying ROI contours may help speed surface-mesh-based feature extraction. Often removing
  the highest-frequency components of the contour will help, such as edges that conform tightly to individual voxels.

### Parameters

- UserComment
- FeaturesFileName
- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```

#### FeaturesFileName

##### Description

Features will be appended to this file. The format is CSV. Leave empty to dump to generate a unique temporary file. If
an existing file is present, rows will be appended without writing a header.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## FVPicketFence

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing
- category: meta

### Description

This operation performs a picket fence QA test using an RTIMAGE file.

### Notes

- This is a 'simplified' version of the full picket fence analysis program that uses defaults that are expected to be
  reasonable across a wide range of scenarios.

### Parameters

- ROILabel
- ImageSelection
- EncircleMethod
- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Channel
- Replacement
- Replace
- NeighbourCount
- AgreementCount
- MaxDistance
- ImageSelection
- DICOMMargin
- RTIMAGE
- ImageSelection
- RowsL
- RowsH
- ColumnsL
- ColumnsH
- DICOMMargin
- ImageSelection
- MLCModel
- MLCROILabel
- JunctionROILabel
- PeakROILabel
- MinimumJunctionSeparation
- ThresholdDistance
- LeafGapsFileName
- ResultsSummaryFileName
- UserComment
- InteractivePlots
- ScaleFactor
- ImageFileName
- ColourMapRegex
- WindowLow
- WindowHigh

#### ROILabel

##### Description

A label to attach to the ROI contours.

##### Default

- ```"entire_image"```

##### Examples

- ```"everything"```
- ```"whole_images"```
- ```"unspecified"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### EncircleMethod

##### Description

The method used to generate the ROI contours. Options include 'whole' and 'FOV'.

The default option, 'whole', makes contours that encircle all voxels. Contours are set slightly inside the outer
boundary so they can be easily visualized by overlaying on an image. All voxel centres will be within the ROI contours.

Option 'FOV' uses image metadata (if available) to only encircle image voxels which are within the scanned field of
view. In practice, this will be a large circle centred on the middle of an image.

##### Default

- ```"whole"```

##### Examples

- ```"whole"```
- ```"FOV"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```"entire_image"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Channel

##### Description

The channel to operated on (zero-based). Negative values will cause all channels to be operated on.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```

#### Replacement

##### Description

Controls how replacements are generated. 'Mean' and 'median' replacement strategies replace the voxel value with the
mean and median, respectively, from the surrounding neighbourhood. 'Conservative' refers to the so-called conservative
filter that suppresses isolated peaks; for every voxel considered, the voxel intensity is clamped to the local
neighbourhood's extrema. This filter works best for removing spurious peak and trough voxels and performs no averaging.
A numeric value can also be supplied, which will replace all isolated or well-connected voxels.

##### Default

- ```"conservative"```

##### Examples

- ```"mean"```
- ```"median"```
- ```"conservative"```
- ```"0.0"```
- ```"-1.23"```
- ```"1E6"```
- ```"nan"```

#### Replace

##### Description

Controls whether isolated or well-connected voxels are retained.

##### Default

- ```"isolated"```

##### Supported Options

- ```"isolated"```
- ```"well-connected"```

#### NeighbourCount

##### Description

Controls the number of neighbours being considered. For purposes of speed, this option is limited to specific levels of
neighbour adjacency.

##### Default

- ```"isolated"```

##### Examples

- ```"1"```
- ```"2"```
- ```"3"```

#### AgreementCount

##### Description

Controls the number of neighbours that must be in agreement for a voxel to be considered 'well-connected.'

##### Default

- ```"6"```

##### Examples

- ```"1"```
- ```"2"```
- ```"25"```

#### MaxDistance

##### Description

The maximum distance (inclusive, in DICOM units: mm) within which neighbouring voxels will be evaluated. For spherical
neighbourhoods, this distance refers to the radius. For cubic neighbourhoods, this distance refers to 'box radius' or
the distance from the cube centre to the nearest point on each bounding face. Voxels separated by more than this
distance will not be evaluated together.

##### Default

- ```"2.0"```

##### Examples

- ```"0.5"```
- ```"2.0"```
- ```"15.0"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### DICOMMargin

##### Description

The amount of margin (in the DICOM coordinate system) to spare from cropping.

##### Default

- ```"0.0"```

##### Examples

- ```"0.1"```
- ```"2.0"```
- ```"-0.5"```
- ```"20.0"```

#### RTIMAGE

##### Description

If true, attempt to crop the image using information embedded in an RTIMAGE. This option cannot be used with the other
options.

##### Default

- ```"true"```

##### Examples

- ```"true"```
- ```"false"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### RowsL

##### Description

The number of rows to remove, starting with the first row. Can be absolute (px), percentage (%), or distance in terms of
the DICOM coordinate system. Note the DICOM coordinate system can be flipped, so the first row can be either on the top
or bottom of the image.

##### Default

- ```"5px"```

##### Examples

- ```"0px"```
- ```"10px"```
- ```"100px"```
- ```"15%"```
- ```"15.75%"```
- ```"123.45"```

#### RowsH

##### Description

The number of rows to remove, starting with the last row. Can be absolute (px), percentage (%), or distance in terms of
the DICOM coordinate system. Note the DICOM coordinate system can be flipped, so the first row can be either on the top
or bottom of the image.

##### Default

- ```"5px"```

##### Examples

- ```"0px"```
- ```"10px"```
- ```"100px"```
- ```"15%"```
- ```"15.75%"```
- ```"123.45"```

#### ColumnsL

##### Description

The number of columns to remove, starting with the first column. Can be absolute (px), percentage (%), or distance in
terms of the DICOM coordinate system. Note the DICOM coordinate system can be flipped, so the first column can be either
on the top or bottom of the image.

##### Default

- ```"5px"```

##### Examples

- ```"0px"```
- ```"10px"```
- ```"100px"```
- ```"15%"```
- ```"15.75%"```
- ```"123.45"```

#### ColumnsH

##### Description

The number of columns to remove, starting with the last column. Can be absolute (px), percentage (%), or distance in
terms of the DICOM coordinate system. Note the DICOM coordinate system can be flipped, so the first column can be either
on the top or bottom of the image.

##### Default

- ```"5px"```

##### Examples

- ```"0px"```
- ```"10px"```
- ```"100px"```
- ```"15%"```
- ```"15.75%"```
- ```"123.45"```

#### DICOMMargin

##### Description

The amount of margin (in the DICOM coordinate system) to spare from cropping.

##### Default

- ```"0.0"```

##### Examples

- ```"0.1"```
- ```"2.0"```
- ```"-0.5"```
- ```"20.0"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### MLCModel

##### Description

The MLC design geometry to use. 'VarianMillenniumMLC80' has 40 leafs in each bank; leaves are 10mm wide at isocentre;
and the maximum static field size is 40cm x 40cm. 'VarianMillenniumMLC120' has 60 leafs in each bank; the 40 central
leaves are 5mm wide at isocentre; the 20 peripheral leaves are 10mm wide; and the maximum static field size is 40cm x
40cm. 'VarianHD120' has 60 leafs in each bank; the 32 central leaves are 2.5mm wide at isocentre; the 28 peripheral
leaves are 5mm wide; and the maximum static field size is 40cm x 22cm.

##### Default

- ```"VarianMillenniumMLC120"```

##### Supported Options

- ```"VarianMillenniumMLC80"```
- ```"VarianMillenniumMLC120"```
- ```"VarianHD120"```

#### MLCROILabel

##### Description

An ROI imitating the MLC axes of leaf pairs is created. This is the label to apply to it. Note that the leaves are
modeled with thin contour rectangles of virtually zero area. Also note that the outline colour is significant and
denotes leaf pair pass/fail.

##### Default

- ```"Leaves"```

##### Examples

- ```"MLC_leaves"```
- ```"MLC"```
- ```"approx_leaf_axes"```

#### JunctionROILabel

##### Description

An ROI imitating the junction is created. This is the label to apply to it. Note that the junctions are modeled with
thin contour rectangles of virtually zero area.

##### Default

- ```"Junction"```

##### Examples

- ```"Junction"```
- ```"Picket_Fence_Junction"```

#### PeakROILabel

##### Description

ROIs encircling the leaf profile peaks are created. This is the label to apply to it. Note that the peaks are modeled
with small squares.

##### Default

- ```"Peak"```

##### Examples

- ```"Peak"```
- ```"Picket_Fence_Peak"```

#### MinimumJunctionSeparation

##### Description

The minimum distance between junctions on the SAD isoplane in DICOM units (mm). This number is used to de-duplicate
automatically detected junctions. Analysis results should not be sensitive to the specific value.

##### Default

- ```"10.0"```

##### Examples

- ```"5.0"```
- ```"10.0"```
- ```"15.0"```
- ```"25.0"```

#### ThresholdDistance

##### Description

The threshold distance in DICOM units (mm) above which MLC separations are considered to 'fail'. Each leaf pair is
evaluated separately. Pass/fail status is also indicated by setting the leaf axis contour colour (blue for pass, red for
fail).

##### Default

- ```"0.5"```

##### Examples

- ```"0.5"```
- ```"1.0"```
- ```"2.0"```

#### LeafGapsFileName

##### Description

This file will contain gap and nominal-vs-actual offset distances for each leaf pair. The format is CSV. Leave empty to
dump to generate a unique temporary file. If an existing file is present, rows will be appended without writing a
header.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### ResultsSummaryFileName

##### Description

This file will contain a brief summary of the results. The format is CSV. Leave empty to dump to generate a unique
temporary file. If an existing file is present, rows will be appended without writing a header.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```

#### InteractivePlots

##### Description

Whether to interactively show plots showing detected edges.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```

#### ScaleFactor

##### Description

This factor is applied to the image width and height to magnify (larger than 1) or shrink (less than 1) the image. This
factor only affects the output image size. Note that aspect ratio is retained, but rounding for non-integer factors may
lead to small (1-2 pixel) discrepancies.

##### Default

- ```"1.5"```

##### Examples

- ```"0.5"```
- ```"1.0"```
- ```"2.0"```
- ```"5.23"```

#### ImageFileName

##### Description

The file name to use for the image. If blank, a filename will be generated sequentially.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/an_image.png"```
- ```"afile.png"```

#### ColourMapRegex

##### Description

The colour mapping to apply to the image if there is a single channel. The default will match the first available, and
if there is no matching map found, the first available will be selected.

##### Default

- ```".*"```

##### Supported Options

- ```"Viridis"```
- ```"Magma"```
- ```"Plasma"```
- ```"Inferno"```
- ```"Jet"```
- ```"MorelandBlueRed"```
- ```"MorelandBlackBody"```
- ```"MorelandExtendedBlackBody"```
- ```"KRC"```
- ```"ExtendedKRC"```
- ```"Kovesi_LinKRYW_5-100_c64"```
- ```"Kovesi_LinKRYW_0-100_c71"```
- ```"Kovesi_Cyclic_cet-c2"```
- ```"LANLOliveGreentoBlue"```
- ```"YgorIncandescent"```
- ```"LinearRamp"```

#### WindowLow

##### Description

If provided, this parameter will override any existing window and level. All pixels with the intensity value or lower
will be assigned the lowest possible colour according to the colour map. Not providing a valid number will disable
window overrides.

##### Default

- ```""```

##### Examples

- ```""```
- ```"-1.23"```
- ```"0"```
- ```"1E4"```

#### WindowHigh

##### Description

If provided, this parameter will override any existing window and level. All pixels with the intensity value or higher
will be assigned the highest possible colour according to the colour map. Not providing a valid number will disable
window overrides.

##### Default

- ```""```

##### Examples

- ```""```
- ```"1.23"```
- ```"0"```
- ```"10.3E4"```


----------------------------------------------------

## False

### Tags

- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that does not complete successfully. It has no side effects.

### Aliases

- Throw
- Break

### Parameters

No registered options.

----------------------------------------------------

## FindFiles

### Tags

- category: meta

### Description

Search a directory for files and/or subdirectories without loading them. Children operations will be invoked once for
each file or directory.

### Notes

- The search is halted when a child operation returns false.

- The return value is 'false' if a child operation fails or returns false, otherwise the return value is true.

### Parameters

- Key
- RootDir
- Recurse
- Target

#### Key

##### Description

Children operations will be invoked once per located file or subdirectory. The path will be saved temporarily in the
global parameter table using this argument as the key.

Note that any existing key will be reset after this operation runs.

##### Default

- ```"path"```

##### Examples

- ```"path"```
- ```"file"```
- ```"dir"```
- ```"x"```

#### RootDir

##### Description

The root directory to search. Note that backslashes might be interpretted as esccape characters.

##### Default

- ```""```

##### Examples

- ```"/tmp/"```
- ```"$HOME"```
- ```"/path/to/root/dir"```

#### Recurse

##### Description

Controls whether the search should recurse into directories. If false, only the root directory is searched.

##### Default

- ```"true"```

##### Supported Options

- ```"true"```
- ```"false"```

#### Target

##### Description

Controls whether files, directories, or both should be located.

##### Default

- ```"files"```

##### Supported Options

- ```"files"```
- ```"directories"```
- ```"files+directories"```


----------------------------------------------------

## For

### Tags

- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that invokes children operations multiple times.

### Notes

- If this operation has no children, this operation will evaluate to a no-op.

### Parameters

- Key
- EachOf
- Begin
- End
- Increment
- Inclusivity

#### Key

##### Description

If a non-empty value is provided, the value or number associated with each loop is stored in the global parameter table
using this key. If the key already exists in the global parameter table, it is temporarily stored during the loop and
restored afterward.

Note: altering the value of the key stored in global parameter table in one iteration will not impact other iterations
of the loop.

##### Default

- ```"i"```

##### Examples

- ```"i"```
- ```"j"```
- ```"k"```
- ```"x"```
- ```"val"```
- ```"abc"```
- ```"123"```

#### EachOf

##### Description

Loop over the provided comma-separated list, invoking children operations once for every item in the order provided. The
item in each loop is optionally inserted into the global parameter table.

Note that this option is used for 'discrete' loop mode and cannot be combined when any 'counter' loop mode parameters
are provided.

##### Default

- ```""```

##### Examples

- ```"a,b,c,d,e,f"```
- ```"1,2,3,4,5"```
- ```"InstanceCreationDate,StudyData,SeriesDate,AcquisitionDate,ContentDate"```
- ```"x,123,Modality"```

#### Begin

##### Description

'Counter' loop mode parameter. This is the value which the counter will first start with. The counter is incremented
until the end value is reached. Children operations are invoked once per counter value. The counter value in each loop
is optionally inserted into the global parameter table.

Note that this option is used for 'counter' loop mode and cannot be combined when any 'discrete' loop mode parameters
are provided.

##### Default

- ```""```

##### Examples

- ```"0"```
- ```"1"```
- ```"-10"```
- ```"100.23"```

#### End

##### Description

'Counter' loop mode parameter. This value controls when the loop terminates. Note that whether this parameter is treated
inclusively (i.e., '<=') or exclusively (i.e., '<'); is controlled by the Inclusivity parameter; the default is to be
inclusive.

Note that this option is used for 'counter' loop mode and cannot be combined when any 'discrete' loop mode parameters
are provided.

##### Default

- ```""```

##### Examples

- ```"100"```
- ```"3"```
- ```"-5"```
- ```"200.23"```

#### Increment

##### Description

'Counter' loop mode parameter. Controls the step size. The counter value in each loop is optionally inserted into the
global parameter table.

Note that this option is used for 'counter' loop mode and cannot be combined when any 'discrete' loop mode parameters
are provided.

##### Default

- ```""```

##### Examples

- ```"1"```
- ```"2"```
- ```"-10"```
- ```"1.23"```

#### Inclusivity

##### Description

'Counter' loop mode parameter. Controls whether the end value is treated inclusively (i.e., '<=') or exclusively (i.e.,
'<'). The default is to be inclusive.

Note that this option is only used for 'counter' loop mode.

##### Default

- ```"inclusive"```

##### Supported Options

- ```"inclusive"```
- ```"exclusive"```


----------------------------------------------------

## ForEachDistinct

### Tags

- category: meta

### Description

This operation is a control flow meta-operation that partitions all available data and invokes all child operations once
for each distinct partition.

### Notes

- If this operation has no children, this operation will evaluate to a no-op.

- This operation will only partition homogeneous objects, i.e., composite objects in which all sub-objects share the
  same set of metadata (e.g., image arrays, since each image carries its own metadata). This guarantees there will be no
  side-effects due to the partitioning. For this reason, this operation is most commonly used on high-level metadata
  tags that are expected to be uniform across sub-objects. See the GroupImages operation to permanently partition
  heterogeneous image arrays.

- Each invocation is performed sequentially, and all modifications are carried forward for each grouping. However,
  partitions are generated before any child operations are invoked, so newly-added elements (e.g., new Image_Arrays)
  created by one invocation will not participate in subsequent invocations. The order of the de-partitioned data is
  stable, though additional elements added will follow the partition they were generated from (and will thus not
  necessarily be placed at the last position).

- This operation will most often be used to process data group-wise rather than as a whole.

### Parameters

- KeysCommon
- IncludeNA

#### KeysCommon

##### Description

Metadata keys to use for exact-match groupings on all data types. For each partition that is produced, every element
will share the same key-value pair. This is generally useful for non-numeric (or integer, date, etc.) key-values. A
';'-delimited list can be specified to group on multiple criteria simultaneously. An empty string disables
metadata-based grouping.

##### Default

- ```""```

##### Examples

- ```"FrameOfReferenceUID"```
- ```"BodyPartExamined;StudyDate"```
- ```"SeriesInstanceUID"```
- ```"StationName"```

#### IncludeNA

##### Description

Whether to perform the loop body for the 'N/A' (i.e., non-matching) group if non-empty.

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```


----------------------------------------------------

## ForEachRTPlan

### Tags

- category: meta
- category: rtplan processing

### Description

This operation is a control flow meta-operation that creates a 'view' of all available data such that each grouping
contains a single treatment plan and any supplementary data it references (e.g., CT images, RTDOSE images, RTSTRUCT
contours, etc.).

### Notes

- If this operation has no children, it will evaluate to a no-op.

- The same supplementary data may appear in multiple groupings (e.g., if multiple plans reference the same images).

- This operation will only partition homogeneous objects, i.e., composite objects in which all sub-objects share the
  same set of metadata (e.g., image arrays, since each image carries its own metadata). See the GroupImages operation to
  permanently partition heterogeneous image arrays.

- Each invocation is performed sequentially, and all modifications are carried forward for each grouping. Groups are
  generated on-the-fly, so newly-added elements (e.g., new images) created by one invocation are available to
  participate in subsequent invocations.

- The order of all elements, whether included in a plan's group or not, will potentially be re-ordered after this
  operation.

### Parameters

- RTPlanSelection
- IncludeNA

#### RTPlanSelection

##### Description

Select one or more treatment plans. Note that a single treatment plan may be composed of multiple beams; if delivered
sequentially, they should collectively represent a single logically cohesive plan. Selection specifiers can be of three
types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth treatment plan (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last treatment plan.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the treatment plan composed of the greatest and fewest number of control points. Only one or zero treatment plan
will be selected; if there are ties, there is no guarantee which treatment plan will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple treatment plan based on a threshold count, i.e., where all selected treatment plan
have more than or fewer than $N$ control points. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all treatment plan that do not have the greatest number of control points, not the least-numerous
treatment plan (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### IncludeNA

##### Description

Whether to perform the loop body for the 'N/A' (i.e., non-matching) group if non-empty.

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```


----------------------------------------------------

## Fork

### Tags

- category: meta

### Description

This operation is a control flow meta-operation that causes child operations to be executed in a POSIX fork. The main
process returns immediately after forking, while the fork executes the children operations.

### Aliases

- Spawn

### Notes

- The return value of the main process describes whether the fork was successful, not whether the children operations
  succeeded. Since the forked process is detached, the return value of the children operations are ignored; however,
  execution will otherwise continue normally, terminating if an operation fails.

- The forked process is detached from the main process, so any state changes in the fork are contained to the fork only.

- Child operations are performed in order, and all side-effects are carried forward in the fork. In particular, all
  selectors in child operations are evaluated lazily, at the moment when the child operation is invoked.

- Windows does not provide fork(), so threads are used to (approximately) emulate fork() on Windows. However, this is
  not a true fork. Note that signals, file descriptors, and almost all other state will be shared. Copy-on-write is used
  for fork(), but thread-emulated forking requires an up-front copy of all application state, so it will be considerably
  slower than a true fork(). Also, thread-emulated fork does not create a new process, so when the parent process
  terminates normally any thread-emulated "forks" will likely be terminated as well.

### Parameters

No registered options.

----------------------------------------------------

## GenerateCalibrationCurve

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: contour processing
- category: file export
- category: image processing

### Description

This operation uses two overlapping images volumes to generate a calibration curve mapping from the first image volume
to the second. Only the region within the specified ROI(s) is considered.

### Notes

- ROI(s) are interpretted relative to the mapped-to ('reference' or 'fixed') image. The reason for this is that
  typically the reference images are associated with contours (e.g., planning data) and the mapped-from images do not
  (e.g., CBCTs that have been registered).

- This routine can handle overlapping or duplicate contours.

### Parameters

- Channel
- ImageSelection
- RefImageSelection
- ContourOverlap
- Inclusivity
- CalibCurveFileName
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### Channel

##### Description

The image channel to use. Zero-based. Use '-1' to operate on all available channels.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified. Note that these images are the 'mapped-from' or
'moving' images.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### RefImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified. Note that these images are the 'mapped-to' or 'fixed'
images.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. The option 'honour_opposite_orientations' makes overlapping contours with opposite
orientation cancel. Otherwise, orientation is ignored. The latter is useful for Boolean structures where contour
orientation is significant for interior contours (holes). The option 'overlapping_contours_cancel' ignores orientation
and cancels all contour overlap.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### CalibCurveFileName

##### Description

The file to which a calibration curve will be written to. The format is line-based with 4 numbers per line: (original
pixel value) (uncertainty) (new pixel value) (uncertainty). Uncertainties refer to the prior number and may be uniformly
zero if unknown. Lines beginning with '#' are comments. The curve is meant to be interpolated. (Later attempts to
extrapolate may result in failure.)

##### Default

- ```""```

##### Examples

- ```"./calib.dat"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## GenerateMapTiles

### Tags

- accepts parameter: contours
- category: geospatial
- category: image processing

### Description

This operation generates an image (representing a geospatial map) from one or more contours (representing geospatial
traces). It can be used to help visualize or analyze tracks and terrain.

### Notes

- This operation can use a local cache or download tiles from a remote server into a local cache. Maintenance of the
  cache is left to the user; for one-off invocations, it is recommended to delete the cache as soon as possible to avoid
  stale data.

- This operation is known to fail when contours traverse the 180 degrees longitude line.

### Parameters

- Zoom
- ProviderURL
- LayerName
- TileCacheDirectory
- MaxMemory
- TileWidth
- TileHeight
- Simulate
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### Zoom

##### Description

Web Mercator projection zoom parameter. This factor represents an exponent; the resolution of the map doubles with each
additional zoom factor. Increasing the zoom by one results in four times as many tiles needed to cover the same
geographical area.

The specific zoom required will depend on the required level of detail, but as a rough guide use 1-5 for countries, 5-10
for intracountry states/provinces, 10-15 for cites/municipalities, and 15-19 for parks/trails.

##### Default

- ```"10"```

##### Examples

- ```"1"```
- ```"5"```
- ```"10"```
- ```"12"```
- ```"14"```
- ```"16"```

#### ProviderURL

##### Description

The prototype URL endpoint used to request map tile images.

This prototype URL assumes a typical format for web Mercator map tile servers. (This operation is specifically designed
to be compatible with OpenStreetMap tile servers, but other servers similarly following the osgeo.org Tile Map Server
Specification are likely to be compatible.)

Variables within the prototype URL will be replaced for individual tiles. The following metadata are currently
recognized: $TILEX (the web Mercator tile coordinate for longitude), $TILEY (the web Mercator tile coordinate for
latitude), and $ZOOM (the web Mercator zoom factor).

Downloads can be disabled by providing an invalid URL, e.g., '/dev/null'.

##### Default

- ```"https://tile.openstreetmap.org/${ZOOM}/${TILEX}/${TILEY}.png"```

##### Examples

- ```"/dev/null"```
- ```"https://tile.openstreetmap.org/${ZOOM}/${TILEX}/${TILEY}.png"```
- ```"http://tile.thunderforest.com/cycle/${ZOOM}/${TILEX}/${TILEY}.png?apikey=abc123xyz"```
- ```"https://maptiles.p.rapidapi.com/local/osm/v1/${ZOOM}/${TILEX}/${TILEY}.png?rapidapi-key=abc123xyz"```

#### LayerName

##### Description

The name or ID associated with a given tile set.

This name is predominantly used for caching purposes. Each distinct provider should have a corresponding distinct
LayerName, otherwise tiles from multiple layers will be mixed.

##### Default

- ```"OSM"```

##### Examples

- ```"OSM"```

#### TileCacheDirectory

##### Description

The top-level directory wherein tiles are, or can be, cached.

The cache structure follows a common hierarchical organization:
'${TileCacheDirectory}/${LayerName}/${zoom}/${x_tile_number}/${y_tile_number}.png'

Note: filenames with backslashes ('\') will need to escape the backslash character, which is interpretted as an escape
character when parsing operation parameters. Backslashes can also be replaced with forwardslahses ('/') in some cases.

##### Default

- ```"/tmp/dcma_generatemaptile_cache"```

##### Examples

- ```"/tmp"```
- ```"."```
- ```"$HOME/.cache/dcma_map_tiles/"```

#### MaxMemory

##### Description

Abort when the map would exceed this amount of memory (in bytes). Negative values amount to no limit.

##### Default

- ```"2147483648"```

##### Examples

- ```"524288000"```
- ```"1073741824"```
- ```"2147483648"```
- ```"-1"```

#### TileWidth

##### Description

The width, in pixels, of each tile image. Either 256 or 512 is typical.

##### Default

- ```"256"```

##### Examples

- ```"256"```
- ```"512"```

#### TileHeight

##### Description

The height, in pixels, of each tile image. Either 256 or 512 is typical.

##### Default

- ```"256"```

##### Examples

- ```"256"```
- ```"512"```

#### Simulate

##### Description

Controls whether an image is generated. If 'true', then images are downloaded and loaded, but not amalgamated into a
single image. This option is useful to download tiles or verify integrity of tiles in the cache without requiring a
(possibly) large block of memory to store the final amalgamated image.

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## GenerateMeshes

### Tags

- category: generator
- category: mesh processing

### Description

This operation contructs surface meshes using constructive solid geometry (CSG) with signed distance functions (SDFs).

### Parameters

- Objects
- MeshLabel
- Resolution

#### Objects

##### Description

This parameter is used to specify a hierarchial tree of CSG-SDF objects. It can include shape primitives and operations
over these shapes.

##### Default

- ```""```

##### Examples

- ```"sphere(2.34);"```
- ```"aa_box(1.0, 2.0, 3.0);"```
- ```"join(){ sphere(1.5); aa_box(1.0, 2.0, 3.0); }"```

#### MeshLabel

##### Description

A label to attach to the surface mesh.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"shape"```
- ```"sphere and box"```

#### Resolution

##### Description

The (minimal) spatial resolution to apply along x, y, and z axes. Can be specified as a list of three numbers.

##### Default

- ```"1.0, 1.0, 1.0"```

##### Examples

- ```"1.0, 1.0, 1.0"```
- ```"0.1, 0.1, 1.0"```
- ```"0.12, 3.45, 6.78"```


----------------------------------------------------

## GenerateSurfaceMask

### Tags

- accepts parameter: contours
- category: generator
- category: image processing
- category: mesh processing
- category: needs refresh

### Description

This operation generates a surface image mask, which contains information about whether each voxel is within, on, or
outside the selected ROI(s).

### Parameters

- BackgroundVal
- InteriorVal
- SurfaceVal
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### BackgroundVal

##### Description

The value to give to voxels neither inside nor on the surface of the ROI(s).

##### Default

- ```"0.0"```

##### Examples

- ```"0.0"```
- ```"-1.0"```
- ```"1.23"```
- ```"2.34E26"```

#### InteriorVal

##### Description

The value to give to voxels within the volume of the ROI(s) but not on the surface.

##### Default

- ```"1.0"```

##### Examples

- ```"0.0"```
- ```"-1.0"```
- ```"1.23"```
- ```"2.34E26"```

#### SurfaceVal

##### Description

The value to give to voxels on the surface/boundary of ROI(s).

##### Default

- ```"2.0"```

##### Examples

- ```"0.0"```
- ```"-1.0"```
- ```"1.23"```
- ```"2.34E26"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## GenerateSyntheticImages

### Tags

- category: generator
- category: image processing

### Description

This operation generates a synthetic, regular bitmap image array. It can be used for testing how images are quantified
or transformed.

### Parameters

- NumberOfImages
- NumberOfRows
- NumberOfColumns
- NumberOfChannels
- SliceThickness
- SpacingBetweenSlices
- VoxelWidth
- VoxelHeight
- ImageAnchor
- ImagePosition
- ImageOrientationColumn
- ImageOrientationRow
- InstanceNumber
- AcquisitionNumber
- VoxelValue
- StipleValue
- Metadata

#### NumberOfImages

##### Description

The number of images to create.

##### Default

- ```"100"```

##### Examples

- ```"1"```
- ```"100"```
- ```"1000"```

#### NumberOfRows

##### Description

The number of rows each image should contain.

##### Default

- ```"256"```

##### Examples

- ```"1"```
- ```"100"```
- ```"1000"```

#### NumberOfColumns

##### Description

The number of columns each image should contain.

##### Default

- ```"256"```

##### Examples

- ```"1"```
- ```"100"```
- ```"1000"```

#### NumberOfChannels

##### Description

The number of channels each image should contain.

##### Default

- ```"1"```

##### Examples

- ```"1"```
- ```"10"```
- ```"100"```

#### SliceThickness

##### Description

Image slices will be have this thickness (in DICOM units: mm). For most purposes, SliceThickness should be equal to
SpacingBetweenSlices. If SpacingBetweenSlices is smaller than SliceThickness, images will overlap. If
SpacingBetweenSlices is larger than SliceThickness, there will be a gap between images.

##### Default

- ```"1.0"```

##### Examples

- ```"0.1"```
- ```"0.5"```
- ```"1.0"```
- ```"10.0"```

#### SpacingBetweenSlices

##### Description

Image slice centres will be separated by this distance (in DICOM units: mm). For most purposes, SpacingBetweenSlices
should be equal to SliceThickness. If SpacingBetweenSlices is smaller than SliceThickness, images will overlap. If
SpacingBetweenSlices is larger than SliceThickness, there will be a gap between images.

##### Default

- ```"1.0"```

##### Examples

- ```"0.1"```
- ```"0.5"```
- ```"1.0"```
- ```"10.0"```

#### VoxelWidth

##### Description

Voxels will have this (in-plane) width (in DICOM units: mm). This means that the centre of two voxels that are in the
same row but adjacent columns will be separated by VoxelWidth. Each voxel will have dimensions: VoxelWidth x VoxelHeight
x SliceThickness.

##### Default

- ```"1.0"```

##### Examples

- ```"0.1"```
- ```"0.5"```
- ```"1.0"```
- ```"10.0"```

#### VoxelHeight

##### Description

Voxels will have this (in-plane) height (in DICOM units: mm). This means that the centre of two voxels that are in the
same column but adjacent rows will be separated by VoxelHeight. Each voxel will have dimensions: VoxelWidth x
VoxelHeight x SliceThickness.

##### Default

- ```"1.0"```

##### Examples

- ```"0.1"```
- ```"0.5"```
- ```"1.0"```
- ```"10.0"```

#### ImageAnchor

##### Description

A point in 3D space which denotes the origin (in DICOM units: mm). All other vectors are taken to be relative to this
point. Under most circumstance the anchor should be (0,0,0). Specify coordinates separated by commas.

##### Default

- ```"0.0, 0.0, 0.0"```

##### Examples

- ```"0.0, 0.0, 0.0"```
- ```"0.0,0.0,0.0"```
- ```"1.0, -2.3, 45.6"```

#### ImagePosition

##### Description

The centre of the row=0, column=0 voxel in the first image (in DICOM units: mm). Specify coordinates separated by
commas.

##### Default

- ```"0.0, 0.0, 0.0"```

##### Examples

- ```"0.0, 0.0, 0.0"```
- ```"100.0,100.0,100.0"```
- ```"1.0, -2.3, 45.6"```

#### ImageOrientationColumn

##### Description

The orientation unit vector that is aligned with image columns. Care should be taken to ensure ImageOrientationRow and
ImageOrientationColumn are orthogonal. (A Gram-Schmidt orthogonalization procedure ensures they are, but the image
orientation may not match the expected orientation.) Note that the magnitude will also be scaled to unit length for
convenience. Specify coordinates separated by commas.

##### Default

- ```"1.0, 0.0, 0.0"```

##### Examples

- ```"1.0, 0.0, 0.0"```
- ```"1.0, 1.0, 0.0"```
- ```"0.0, 0.0, -1.0"```

#### ImageOrientationRow

##### Description

The orientation unit vector that is aligned with image rows. Care should be taken to ensure ImageOrientationRow and
ImageOrientationColumn are orthogonal. (A Gram-Schmidt orthogonalization procedure ensures they are, but the image
orientation may not match the expected orientation.) Note that the magnitude will also be scaled to unit length for
convenience. Specify coordinates separated by commas.

##### Default

- ```"0.0, 1.0, 0.0"```

##### Examples

- ```"0.0, 1.0, 0.0"```
- ```"0.0, 1.0, 1.0"```
- ```"-1.0, 0.0, 0.0"```

#### InstanceNumber

##### Description

A number affixed to the first image, and then incremented and affixed for each subsequent image.

##### Default

- ```"1"```

##### Examples

- ```"1"```
- ```"100"```
- ```"1234"```

#### AcquisitionNumber

##### Description

A number affixed to all images, meant to indicate membership in a single acquisition.

##### Default

- ```"1"```

##### Examples

- ```"1"```
- ```"100"```
- ```"1234"```

#### VoxelValue

##### Description

The value that is assigned to all voxels, or possibly every other voxel. Note that if StipleValue is given a finite
value, only half the voxels will be assigned a value of VoxelValue and the other half will be assigned a value of
StipleValue. This produces a checkerboard pattern.

##### Default

- ```"0.0"```

##### Examples

- ```"0.0"```
- ```"1.0E4"```
- ```"-1234"```
- ```"nan"```

#### StipleValue

##### Description

The value that is assigned to every other voxel. If StipleValue is given a finite value, half of all voxels will be
assigned a value of VoxelValue and the other half will be assigned a value of StipleValue. This produces a checkerboard
pattern.

##### Default

- ```"nan"```

##### Examples

- ```"1.0"```
- ```"-1.0E4"```
- ```"1234"```

#### Metadata

##### Description

A semicolon-separated list of 'key@value' metadata to imbue into each image. This metadata will overwrite any existing
keys with the provided values.

##### Default

- ```""```

##### Examples

- ```"keyA@valueA;keyB@valueB"```


----------------------------------------------------

## GenerateTable

### Tags

- category: generator
- category: table processing

### Description

This operation creates an empty table.

### Parameters

- TableLabel

#### TableLabel

##### Description

A label to attach to the new table.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"xyz"```
- ```"sheet A"```


----------------------------------------------------

## GenerateVirtualDataContourViaThresholdTestV1

### Tags

- category: generator
- category: image processing
- category: virtual phantom

### Description

This operation generates data suitable for testing the ContourViaThreshold operation.

### Parameters

No registered options.

----------------------------------------------------

## GenerateVirtualDataDoseStairsV1

### Tags

- category: image processing
- category: radiation dose
- category: virtual phantom

### Description

This operation generates a dosimetric stairway. It can be used for testing how dosimetric data is transformed.

### Parameters

No registered options.

----------------------------------------------------

## GenerateVirtualDataImageSphereV1

### Tags

- category: generator
- category: image processing
- category: virtual phantom

### Description

This operation generates a bitmap image of a sphere. It can be used for testing how images are quantified or
transformed.

### Parameters

No registered options.

----------------------------------------------------

## GenerateVirtualDataPerfusionV1

### Tags

- category: generator
- category: image processing
- category: perfusion
- category: virtual phantom

### Description

This operation generates data suitable for testing perfusion modeling operations. There are no specific checks in this
code. Another operation performs the actual validation. You might be able to manually verify if the perfusion model
admits a simple solution.

### Parameters

No registered options.

----------------------------------------------------

## GenerateWarp

### Tags

- category: generator
- category: spatial transform processing

### Description

This operation can be used to create a transformation object. The transformation object can later be applied to objects
with spatial extent.

### Parameters

- Transforms
- TransformName
- Metadata

#### Transforms

##### Description

This parameter is used to specify one or more transformations. Current primitives include translation, scaling,
mirroring, and rotation.

Translations have three configurable scalar parameters denoting the translation along x, y, and z in the DICOM
coordinate system. Translating $x=1.0$, $y=-2.0$, and $z=0.3$ can be specified as 'translate(1.0, -2.0, 0.3)'.

The scale (actually 'homothetic') transformation has four configurable scalar parameters denoting the scale centre
3-vector and the magnification factor. Note that the magnification factor can be negative, which will cause the mesh to
be inverted along x, y, and z axes and magnified. Take note that face orientations will also become inverted. Magnifying
by 2.7x about $(1.23, -2.34, 3.45)$ can be specified as 'scale(1.23, -2.34, 3.45, 2.7)'. A standard scale transformation
can be achieved by taking the centre to be the origin.

The mirror transformation has six configurable scalar parameters denoting an oriented plane about which a mirror is
performed. Mirroring in the plane that intersects $(1,2,3)$ and has a normal toward $(1,0,0)$ can be specified as
'mirror(1,2,3, 1,0,0)'.

Rotations around an arbitrary axis line can be accomplished. The rotation transformation has seven configurable scalar
parameters denoting the rotation centre 3-vector, the rotation axis 3-vector, and the rotation angle in radians. A
rotation of pi radians around the axis line parallel to vector $(1.0, 0.0, 0.0)$ that intersects the point $(4.0, 5.0,
6.0)$ can be specified as 'rotate(4.0, 5.0, 6.0, 1.0, 0.0, 0.0, 3.141592653)'.

A transformation can be composed of one or more primitive transformations applied sequentially. Primitives can be
separated by a ';' and are evaluated from left to right.

##### Default

- ```"translate(0.0, 0.0, 0.0)"```

##### Examples

- ```"translate(1.0, -2.0, 0.3)"```
- ```"scale(1.23, -2.34, 3.45, 2.7)"```
- ```"mirror(0,0,0, 1,0,0)"```
- ```"rotate(4.0, 5.0, 6.0,  1.0, 0.0, 0.0,  3.141592653)"```
- ```"translate(1,0,0) ; scale(0,0,0, 5) ; translate(-1,0,0)"```

#### TransformName

##### Description

A name or label to attach to the transformation.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"offset"```
- ```"expansion"```
- ```"rotation_around_xyz"```
- ```"move_to_origin"```

#### Metadata

##### Description

A semicolon-separated list of 'key@value' metadata to imbue into the transform. This metadata will overwrite any
existing keys with the provided values.

##### Default

- ```""```

##### Examples

- ```"keyA@valueA;keyB@valueB"```


----------------------------------------------------

## GiveWholeImageArrayABoneWindowLevel

### Tags

- category: image processing
- category: needs refresh

### Description

This operation runs the images in an image array through a uniform window-and-leveler instead of per-slice
window-and-level or no window-and-level at all. Data is modified and no copy is made!

### Parameters

No registered options.

----------------------------------------------------

## GiveWholeImageArrayAHeadAndNeckWindowLevel

### Tags

- category: image processing
- category: needs refresh

### Description

This operation runs the images in an image array through a uniform window-and-leveler instead of per-slice
window-and-level or no window-and-level at all. Data is modified and no copy is made!

### Parameters

No registered options.

----------------------------------------------------

## GiveWholeImageArrayAThoraxWindowLevel

### Tags

- category: image processing
- category: needs refresh

### Description

This operation runs the images in an image array through a uniform window-and-leveler instead of per-slice
window-and-level or no window-and-level at all. Data is modified and no copy is made!

### Parameters

No registered options.

----------------------------------------------------

## GiveWholeImageArrayAnAbdominalWindowLevel

### Tags

- category: image processing
- category: needs refresh

### Description

This operation runs the images in an image array through a uniform window-and-leveler instead of per-slice
window-and-level or no window-and-level at all. Data is modified and no copy is made!

### Parameters

No registered options.

----------------------------------------------------

## GiveWholeImageArrayAnAlphaBetaWindowLevel

### Tags

- category: image processing
- category: needs refresh

### Description

This operation runs the images in an image array through a uniform window-and-leveler instead of per-slice
window-and-level or no window-and-level at all. Data is modified and no copy is made!

### Parameters

No registered options.

----------------------------------------------------

## GridBasedRayCastDoseAccumulate

### Tags

- accepts parameter: contours
- category: file export
- category: image processing
- category: radiation dose
- category: simulation

### Description

This operation performs a ray casting to estimate the surface dose of an ROI.

### Parameters

- DoseMapFileName
- DoseLengthMapFileName
- LengthMapFileName
- NormalizedReferenceROILabelRegex
- NormalizedROILabelRegex
- ReferenceROILabelRegex
- ROILabelRegex
- SmallestFeature
- RaydL
- GridRows
- GridColumns
- SourceDetectorRows
- SourceDetectorColumns
- NumberOfImages

#### DoseMapFileName

##### Description

A filename (or full path) for the dose image map. Note that this file is approximate, and may not be accurate. There is
more information available when you use the length and dose*length maps instead. However, this file is useful for
viewing and eyeballing tuning settings. The format is FITS. Leave empty to dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/dose.fits"```
- ```"localfile.fits"```
- ```"derivative_data.fits"```

#### DoseLengthMapFileName

##### Description

A filename (or full path) for the (dose)*(length traveled through the ROI peel) image map. The format is FITS. Leave
empty to dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/doselength.fits"```
- ```"localfile.fits"```
- ```"derivative_data.fits"```

#### LengthMapFileName

##### Description

A filename (or full path) for the (length traveled through the ROI peel) image map. The format is FITS. Leave empty to
dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/surfacelength.fits"```
- ```"localfile.fits"```
- ```"derivative_data.fits"```

#### NormalizedReferenceROILabelRegex

##### Description

A regex matching reference ROI labels/names to consider. The default will match all available ROIs, which is
non-sensical. The reference ROI is used to orient the cleaving plane to trim the grid surface mask.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Prostate.*"```
- ```"Left Kidney"```
- ```"Gross Liver"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ReferenceROILabelRegex

##### Description

A regex matching reference ROI labels/names to consider. The default will match all available ROIs, which is
non-sensical. The reference ROI is used to orient the cleaving plane to trim the grid surface mask.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*[pP]rostate.*"```
- ```"body"```
- ```"Gross_Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### SmallestFeature

##### Description

A length giving an estimate of the smallest feature you want to resolve. Quantity is in the DICOM coordinate system.

##### Default

- ```"0.5"```

##### Examples

- ```"1.0"```
- ```"2.0"```
- ```"0.5"```
- ```"5.0"```

#### RaydL

##### Description

The distance to move a ray each iteration. Should be << img_thickness and << cylinder_radius. Making too large will
invalidate results, causing rays to pass through the surface without registering any dose accumulation. Making too small
will cause the run-time to grow and may eventually lead to truncation or round-off errors. Quantity is in the DICOM
coordinate system.

##### Default

- ```"0.1"```

##### Examples

- ```"0.1"```
- ```"0.05"```
- ```"0.01"```
- ```"0.005"```

#### GridRows

##### Description

The number of rows in the surface mask grid images.

##### Default

- ```"512"```

##### Examples

- ```"10"```
- ```"50"```
- ```"128"```
- ```"1024"```

#### GridColumns

##### Description

The number of columns in the surface mask grid images.

##### Default

- ```"512"```

##### Examples

- ```"10"```
- ```"50"```
- ```"128"```
- ```"1024"```

#### SourceDetectorRows

##### Description

The number of rows in the resulting images. Setting too fine relative to the surface mask grid or dose grid is futile.

##### Default

- ```"1024"```

##### Examples

- ```"10"```
- ```"50"```
- ```"128"```
- ```"1024"```

#### SourceDetectorColumns

##### Description

The number of columns in the resulting images. Setting too fine relative to the surface mask grid or dose grid is
futile.

##### Default

- ```"1024"```

##### Examples

- ```"10"```
- ```"50"```
- ```"128"```
- ```"1024"```

#### NumberOfImages

##### Description

The number of images used for grid-based surface detection. Leave negative for computation of a reasonable value; set to
something specific to force an override.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"10"```
- ```"50"```
- ```"100"```


----------------------------------------------------

## GroupImages

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation will group individual image slices into partitions (Image_Arrays) based on the values of the specified
metadata tags. DICOMautomaton operations are usually performed on containers rather than individual images, and grouping
can express connections between images. For example a group could contain the scans belonging to a whole study, one of
the series in a study, individual image volumes within a single series (e.g., a 3D volume in a temporal perfusion scan),
or individual slices. A group could also contain all the slices that intersect a given plane, or were taken on a
specified StationName.

### Aliases

- PartitionImages

### Notes

- Images are moved, not copied.

- This operation can be used to 'ungroup' images by selecting a shared common key (e.g., FrameOfReferenceUID or
  Modality).

- Image order within a group is retained (i.e., stable grouping), but groups are appended to the back of the Image_Array
  list according to the default sort for the group's key-value value.

- Images that do not contain the specified metadata will be grouped into a special N/A group at the end. Use strict mode
  to abort grouping if any image is missing any tag.

### Parameters

- ImageSelection
- KeysCommon
- Strict
- AutoSelectKeysCommon
- Enforce

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### KeysCommon

##### Description

Image metadata keys to use for exact-match groupings. For each group that is produced, every image will share the same
key-value pair. This is generally useful for non-numeric (or integer, date, etc.) key-values. A ';'-delimited list can
be specified to group on multiple criteria simultaneously. An empty string disables metadata-based grouping.

##### Default

- ```""```

##### Examples

- ```"SeriesNumber"```
- ```"BodyPartExamined;StudyDate"```
- ```"SeriesInstanceUID"```
- ```"StationName"```

#### Strict

##### Description

Require all images to have all tags present, and abort otherwise. Using this option, if the operation succeeds there
will be no N/A partition.

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```

#### AutoSelectKeysCommon

##### Description

Attempt to automatically select the single image metadata key that partitions images into approximately evenly-sized
partitions. Currently, some basic and broad assumptions are used to filter candidate keys. The criteria will not work in
all cases, but might help identify candidates. This option cannot be enabled when providing the KeysCommon parameter.

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```

#### Enforce

##### Description

Other specialized grouping operations that involve custom logic. Currently, only 'no-overlap' is available, but it has
two variants. Both partition based on the spatial extent of images; in each non-overlapping partition, no two images
will spatially overlap. 'No-overlap-as-is' will effectively insert partitions without altering the order. A partition is
inserted when an image is found to overlap with an image already within the partition. For this grouping to be useful,
images must be sorted so that partitions can be inserted without any necessary reordering. An example of when this
grouping is useful is CT shuttling in which the ordering of images alternate between increasing and decreasing
SliceNumber. Note that, depending on the ordering, some partitions may therefore be incomplete. 'No-overlap-adjust' will
rearrange images so that the first partition is always complete. This is achieved by building a queue of
spatially-overlapping images and greedily stealing one of each kind when constructing partitions. An example of when
this grouping is useful are 4DCTs which have been acquired for all phases while the couch remains at a single
SliceNumber; the images are ordered on disk in the acquisition order (i.e., alike SliceNumbers are bunched together) but
the logical analysis order is that each contiguous volume should represent a single phase. An empty string disables
logic-based grouping.

##### Default

- ```""```

##### Supported Options

- ```"no-overlap-as-is"```
- ```"no-overlap-adjust"```


----------------------------------------------------

## GrowContours

### Tags

- accepts parameter: contours
- category: contour processing

### Description

This routine will grow (or shrink) 2D contours in their plane by the specified amount. Growth is accomplish by
translating vertices away from the interior by the specified amount. The direction is chosen to be the direction
opposite of the in-plane normal produced by averaging the line segments connecting the contours.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- Distance

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### Distance

##### Description

The distance to translate contour vertices. (The direction is outward.)

##### Default

- ```"0.00354165798657632"```

##### Examples

- ```"1E-5"```
- ```"0.321"```
- ```"1.1"```
- ```"15.3"```


----------------------------------------------------

## HighlightROIs

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: contour processing
- category: image processing

### Description

This operation overwrites voxel data inside and/or outside of ROI(s) to create an image representation of a set of
contours. It can handle overlapping or duplicate contours.

### Aliases

- ConvertContoursToImages

### Notes

- The 'receding_squares' implementation uses a simplistic one-pass approach that only considers only the immediate left
  and immediate up neighbours to determine the necessary intensity of the (*this) voxel. The intensity is
  over-specified, so in general will result in the exact intensity needed to exactly reproduce the original contours.
  Slight differences can arise do to averaging and numerical imprecision, especially if the input comes from a marching
  algorithm (common!) which can result in geometrical alignment and degenerate voxel inclusions. The 'receding_squares'
  implementation was developed with the expectations that: (1) the entire image will be overwritten, (2) contours are
  accurate and selective, so that ContourOverlap should be either 'honour_opposite_orientations' or
  'overlapping_contours_cancel', and that (3) the contour detail and image grid resolution are sufficiently matched that
  it is uncommon for multiple contours to pass between adjacent voxels. For expectation (2), using
  'overlapping_contours_cancel' produces the best results, since all contours will be recreated as much as possible.
  Expectation (3) could significantly impact round-trip contour accuracy, so consider using high-resolution images and,
  if possible, avoid pathological contours (e.g., multiple colinear contours separated by small distances).

- The 'receding_squares' method works best when all values (interior and exterior) can be overwritten. This affords the
  most control and gives the most accurate results. If some values cannot be overwritten, the algorithm will try to
  account for the loss of freedom, but may be too constrained. If this is necessary, consider providing a large voxel
  value range.

- Inclusivity option does not apply to the 'receding_squares' method.

- Neither 'receding_squares' nor 'binary' methods require InteriorVal and ExteriorVal to be ordered.

### Parameters

- Channel
- ImageSelection
- ContourOverlap
- Inclusivity
- Method
- ExteriorVal
- InteriorVal
- ExteriorOverwrite
- InteriorOverwrite
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### Channel

##### Description

The image channel to use. Zero-based. Use '-1' to operate on all available channels.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. This will effectively honour only the outermost contour regardless of orientation,
but provides the most predictable and consistent results. The option 'honour_opposite_orientations' makes overlapping
contours with opposite orientation cancel. Otherwise, orientation is ignored. This is useful for Boolean structures
where contour orientation is significant for interior contours (holes). If contours do not have consistent overlap
(e.g., if contours intersect) the results can be unpredictable and hard to interpret. The option
'overlapping_contours_cancel' ignores orientation and alternately cancerls all overlapping contours. Again, if the
contours do not have consistent overlap (e.g., if contours intersect) the results can be unpredictable and hard to
interpret.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### Method

##### Description

Controls the type of image mask that is generated. The default, 'binary', exclusively overwrites voxels with the
InteriorValue or ExteriorValue. Another method is 'receding_squares' which creates a mask which, if processed with the
marching-squares algorithm, will (mostly) recreate the original contours. The 'receding_squares' can be considered the
inverse of the marching-squares algorithm. Note that the 'receding_squares' implementation is not optimized for speed.

##### Default

- ```"binary"```

##### Supported Options

- ```"binary"```
- ```"receding_squares"```

#### ExteriorVal

##### Description

The value to give to voxels outside the specified ROI(s). For the 'binary' method, note that this value will be ignored
if exterior overwrites are disabled. For the 'receding_squares' method this value is used to define the threshold needed
to recover the original contours (mean of InteriorVal and ExteriorVal).

##### Default

- ```"0.0"```

##### Examples

- ```"0.0"```
- ```"-1.0"```
- ```"1.23"```
- ```"2.34E26"```

#### InteriorVal

##### Description

The value to give to voxels within the specified ROI(s). For the 'binary' method, note that this value will be ignored
if interior overwrites are disabled. For the 'receding_squares' method this value is used to define the threshold needed
to recover the original contours (mean of InteriorVal and ExteriorVal).

##### Default

- ```"1.0"```

##### Examples

- ```"0.0"```
- ```"-1.0"```
- ```"1.23"```
- ```"2.34E26"```

#### ExteriorOverwrite

##### Description

Whether to overwrite voxels exterior to the specified ROI(s).

##### Default

- ```"true"```

##### Supported Options

- ```"true"```
- ```"false"```

#### InteriorOverwrite

##### Description

Whether to overwrite voxels interior to the specified ROI(s).

##### Default

- ```"true"```

##### Supported Options

- ```"true"```
- ```"false"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## IfElse

### Tags

- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that performs an 'if-then' or 'if-then-else' by evaluating child
operations. If the first child operation (the conditional) completes without throwing an exception, then the second
operation is performed. Otherwise the third operation ('else statement'), if present, is performed. Side effects from
all evaluated operations are possible.

### Aliases

- If
- IfThenElse
- ElseIf

### Notes

- Child operations are performed in order, and all side-effects are carried forward. In particular, all selectors in
  child operations are evaluated lazily, at the moment when the child operation is invoked.

- A single operation is required for each of the condition, 'then' path, and 'else' path. Multiple operations can be
  wrapped (i.e., combined together) to make a single child operation.

- Some operations may succeed without directly signalling failure. For example, an operation that loops over all
  selected images may not throw if zero images are selected. This operation works best with other control flow
  meta-operations.

### Parameters

No registered options.

----------------------------------------------------

## Ignore

### Tags

- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that ignores the return value of all child operations.

### Aliases

- Always
- Force

### Notes

- Child operations are performed in order, and all side-effects are carried forward. In particular, all selectors in
  child operations are evaluated lazily, at the moment when the child operation is invoked.

- This operation ' will always succeed, even if no children are present. This operation works well with idempotent or
  non-critical children operations.

### Parameters

No registered options.

----------------------------------------------------

## ImageRoutineTests

### Tags

- category: image processing
- category: needs refresh

### Description

This operation performs a series of sub-operations that are generally useful when inspecting an image.

### Parameters

No registered options.

----------------------------------------------------

## ImportDrover

### Tags

- category: RPC
- category: file import
- category: meta

### Description

This operation deserializes a Drover object from a file. It uses Apache Thrift for serialization.

### Notes

- RPC functionality is currently alpha-quality code, and much is expected to change.

### Parameters

- Filename

#### Filename

##### Description

The filename to read from.

##### Default

- ```"in.ts_dcma"```

##### Examples

- ```"in.ts_dcma"```
- ```"/tmp/in.ts_dcma"```


----------------------------------------------------

## ImprintImages

### Tags

- accepts parameter: images
- accepts parameter: point clouds
- category: image processing
- category: needs refresh
- category: point cloud processing

### Description

This operation creates imprints of point clouds on the selected images. Images are modified where the points are
coindicident.

### Parameters

- ImageSelection
- PointSelection
- VoxelValue
- Channel

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### PointSelection

##### Description

Select one or more point clouds. Note that point clouds can hold a variety of data with varying attributes, but each
point cloud is meant to represent a single logically cohesive collection of points. Be aware that it is possible to mix
logically unrelated points together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### VoxelValue

##### Description

The value to give voxels which are coincident with a point from the point cloud. Note that point cloud attributes, if
present, may override this value.

##### Default

- ```"1.0"```

##### Examples

- ```"-1.0"```
- ```"0.0"```
- ```"1.23"```
- ```"nan"```
- ```"inf"```

#### Channel

##### Description

The image channel to use. Zero-based.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"2"```


----------------------------------------------------

## InterpolateSlices

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation interpolates the slices of an image array using a reference image array, effectively performing trilinear
interpolation. This operation is meant to prepare image arrays to be compared or operated on in a per-voxel manner.

### Notes

- No images are overwritten by this operation. The outgoing images will inherit (interpolated) voxel values from the
  selected images and image geometry from the reference images.

- If all images (selected and reference, altogether) are detected to be rectilinear, this operation will avoid in-plane
  interpolation and will thus be much faster. There is no **need** for rectilinearity, however without it sections of
  the image that cannot reasonably be interpolated (via plane-orthogonal projection onto the reference images) will be
  invalid and marked with NaNs. Non-rectilearity which amounts to a differing number of rows or columns will merely be
  slower to interpolate.

### Parameters

- ImageSelection
- ReferenceImageSelection
- Channel

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ReferenceImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Channel

##### Description

The channel to compare (zero-based). A negative value will result in all channels being interpolated, otherwise
unspecified channels are merely default initialized. Note that both test images and reference images will share this
specifier.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```


----------------------------------------------------

## InvokeStandardScript

### Tags

- category: file import
- category: meta
- category: scripting

### Description

This operation invokes a built-in DICOMautomaton script.

### Notes

- Scripts may require configuration via parameter table entries in order to function correctly. Refer to the scripts
  themselves for documentation.

### Parameters

- Script

#### Script

##### Description

The name of the script to invoke.

##### Default

- ```""```

##### Supported Options

- ```"QA/de-EQD2"```
- ```"QA/point-dose EQD2"```
- ```"debugging/script comments"```
- ```"debugging/script functions"```
- ```"debugging/script functions disallowed names"```
- ```"debugging/script quotes"```
- ```"debugging/script variables"```
- ```"debugging/script variables disallowed names"```
- ```"examples/CleanContours"```
- ```"examples/GenerateMeshes"```
- ```"examples/ModelIVIM"```
- ```"examples/ROIImageHistogramStatistics"```
- ```"examples/TransferContours"```
- ```"examples/TransferContours2"```
- ```"examples/ValidateRTPlan"```
- ```"images/DICOM image partition"```
- ```"images/assign time in seconds"```
- ```"images/isolate most numerous array"```
- ```"images/make new image array"```
- ```"images/reorder images via instance number"```
- ```"images/reorder images via position"```
- ```"plumbing/copy existing contours"```
- ```"plumbing/dilate erode margin"```
- ```"plumbing/export contours DICOM RTSTRUCT"```
- ```"plumbing/export images DICOM CT"```
- ```"plumbing/export images DICOM MR"```
- ```"plumbing/export images DICOM RTDOSE"```
- ```"plumbing/export original images"```
- ```"plumbing/extract contours from mask"```
- ```"plumbing/iterate polyominoes"```
- ```"tables/make new table"```
- ```"tutorials/tutorial 1 scripting basics"```
- ```"tutorials/tutorial 2 Boolean operations"```
- ```"usage/ConvertParametersToTable"```
- ```"usage/Isolate"```
- ```"usage/MapTableToParameters"```
- ```"usage/Polyominoes"```


----------------------------------------------------

## Isolate

### Tags

- accepts parameter: contours
- accepts parameter: images
- accepts parameter: line samples
- accepts parameter: point clouds
- accepts parameter: surface meshes
- accepts parameter: tables
- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that selects only the specified objects (e.g., image arrays, surface
meshes, etc.) and forwards them to a virtual Drover object where they are isolated from the objects that were not
selected. This creates a 'view' of the Drover object containing only the selected objects. Children operations will
operate on this isolated view where the unselected objects are hidden.

This operation is useful for implementing complicated filters. For example, selecting the third and seventh image arrays
will present a view with *only* those two image arrays (in the first and second positions). Children operations can then
address (only) those image arrays in the first and second place, rather than third and seventh place. When the children
operations conclude, these image arrays would be returned to the third and seventh position in the original Drover.

### Notes

- This operation itself produces no side-effects. It does not alter the selected objects. However, children operations
  may alter the selected objects and/or create side-effects.

- The order of objects in the original Drover is retained when this operation concludes. Objects deleted within the
  isolated view are also deleted from the original Drover object. Objects created within the isolated view are inserted
  at the end of the original Drover object.

- Selectors for this operation are only considered when you explicitly provide them. By default, this operation will
  provide an empty view.

### Parameters

- ROILabelRegex
- ROISelection
- NormalizedROILabelRegex
- ImageSelection
- LineSelection
- MeshSelection
- PointSelection
- TransformSelection
- TableSelection
- RTPlanSelection

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### LineSelection

##### Description

Select one or more line samples. Selection specifiers can be of three types: positional, metadata-based key@value regex,
and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth line sample (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last line sample.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the line sample composed of the greatest and fewest number of samples. Only one or zero line sample will be
selected; if there are ties, there is no guarantee which line sample will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple line sample based on a threshold count, i.e., where all selected line sample have
more than or fewer than $N$ samples. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all line sample that do not have the greatest number of samples, not the least-numerous line sample (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### PointSelection

##### Description

Select one or more point clouds. Note that point clouds can hold a variety of data with varying attributes, but each
point cloud is meant to represent a single logically cohesive collection of points. Be aware that it is possible to mix
logically unrelated points together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TransformSelection

##### Description

Select one or more transform objects (aka 'warp' objects). Selection specifiers can be of three types: positional,
metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth transformation (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last transformation.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the transformation composed of the greatest and fewest number of sub-objects. Only one or zero transformation
will be selected; if there are ties, there is no guarantee which transformation will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple transformation based on a threshold count, i.e., where all selected transformation
have more than or fewer than $N$ sub-objects. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all transformation that do not have the greatest number of sub-objects, not the least-numerous
transformation (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### RTPlanSelection

##### Description

Select one or more treatment plans. Note that a single treatment plan may be composed of multiple beams; if delivered
sequentially, they should collectively represent a single logically cohesive plan. Selection specifiers can be of three
types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth treatment plan (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last treatment plan.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the treatment plan composed of the greatest and fewest number of control points. Only one or zero treatment plan
will be selected; if there are ties, there is no guarantee which treatment plan will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple treatment plan based on a threshold count, i.e., where all selected treatment plan
have more than or fewer than $N$ control points. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all treatment plan that do not have the greatest number of control points, not the least-numerous
treatment plan (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## IsolatedVoxelFilter

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This routine applies a filter that discriminates between well-connected and isolated voxels. Isolated voxels can either
be filtered out or retained. This operation considers the 3D neighbourhood surrounding a voxel.

### Notes

- The provided image collection must be rectilinear.

- If the neighbourhood involves voxels that do not exist, they are treated as NaNs in the same way that voxels with the
  NaN value are treated.

### Parameters

- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Channel
- Replacement
- Replace
- NeighbourCount
- AgreementCount
- MaxDistance

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Channel

##### Description

The channel to operated on (zero-based). Negative values will cause all channels to be operated on.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```

#### Replacement

##### Description

Controls how replacements are generated. 'Mean' and 'median' replacement strategies replace the voxel value with the
mean and median, respectively, from the surrounding neighbourhood. 'Conservative' refers to the so-called conservative
filter that suppresses isolated peaks; for every voxel considered, the voxel intensity is clamped to the local
neighbourhood's extrema. This filter works best for removing spurious peak and trough voxels and performs no averaging.
A numeric value can also be supplied, which will replace all isolated or well-connected voxels.

##### Default

- ```"mean"```

##### Examples

- ```"mean"```
- ```"median"```
- ```"conservative"```
- ```"0.0"```
- ```"-1.23"```
- ```"1E6"```
- ```"nan"```

#### Replace

##### Description

Controls whether isolated or well-connected voxels are retained.

##### Default

- ```"isolated"```

##### Supported Options

- ```"isolated"```
- ```"well-connected"```

#### NeighbourCount

##### Description

Controls the number of neighbours being considered. For purposes of speed, this option is limited to specific levels of
neighbour adjacency.

##### Default

- ```"isolated"```

##### Examples

- ```"1"```
- ```"2"```
- ```"3"```

#### AgreementCount

##### Description

Controls the number of neighbours that must be in agreement for a voxel to be considered 'well-connected.'

##### Default

- ```"6"```

##### Examples

- ```"1"```
- ```"2"```
- ```"25"```

#### MaxDistance

##### Description

The maximum distance (inclusive, in DICOM units: mm) within which neighbouring voxels will be evaluated. For spherical
neighbourhoods, this distance refers to the radius. For cubic neighbourhoods, this distance refers to 'box radius' or
the distance from the cube centre to the nearest point on each bounding face. Voxels separated by more than this
distance will not be evaluated together.

##### Default

- ```"2.0"```

##### Examples

- ```"0.5"```
- ```"2.0"```
- ```"15.0"```


----------------------------------------------------

## LoadFiles

### Tags

- category: file import
- category: meta

### Description

This operation loads files on-the-fly.

### Notes

- This operation requires all files provided to it to exist and be accessible. Inaccessible files are not silently
  ignored and will cause this operation to fail.

### Parameters

- FileName

#### FileName

##### Description

This file will be parsed and loaded. All file types supported by the DICOMautomaton system can be loaded in this way.
Currently this includes serialized Drover class files, DICOM files, FITS image files, and XYZ point cloud files.

##### Default

- ```""```

##### Examples

- ```"/tmp/image.dcm"```
- ```"rois.dcm"```
- ```"dose.dcm"```
- ```"image.fits"```
- ```"point_cloud.xyz"```


----------------------------------------------------

## LoadFilesInteractively

### Tags

- category: file import
- category: interactive
- category: meta

### Description

This operation lets the user interactively select one or more files and then attempts to load them.

### Notes

- This operation requires all files provided to it to exist and be accessible. Inaccessible files are not silently
  ignored and will cause this operation to fail.

### Parameters

- Instruction

#### Instruction

##### Description

An instruction provided to the user, if possible. In most cases this will be the title of a GUI dialog box.

##### Default

- ```"Please select one or more files to load"```

##### Examples

- ```"Select files"```
- ```"Select XYZ files to load"```


----------------------------------------------------

## LogScale

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation log-scales pixels for all available image arrays. This functionality is often desired for viewing
purposes, to make the pixel level changes appear more linear. Be weary of using for anything quantitative!

### Parameters

- ImageSelection

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## MakeMeshesManifold

### Tags

- accepts parameter: surface meshes
- category: mesh processing

### Description

This operation attempts to make non-manifold surface meshes into manifold meshes. This operation is needed for
operations requiring meshes to represent polyhedra.

### Notes

- This routine will invalidate any imbued special attributes from the original mesh.

- It may not be possible to accomplish manifold-ness.

- Mesh features (vertices, faces, edges) may disappear in this routine.

### Parameters

- MeshLabel
- MeshSelection

#### MeshLabel

##### Description

A label to attach to the new manifold mesh.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"body"```
- ```"air"```
- ```"bone"```
- ```"invalid"```
- ```"above_zero"```
- ```"below_5.3"```

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## MapTableToParameters

### Tags

- accepts parameter: tables
- category: parameter table
- category: table processing

### Description

Process the rows of a table, one-at-a-time, by mapping them to the global parameter table and invoking children
operations.

### Aliases

- ConvertTableToParameters

### Parameters

- ColumnNumberKeyPrefix
- RowNumberKey
- TableSelection
- SkipHeaderRows

#### ColumnNumberKeyPrefix

##### Description

Used to map columns to the global parameter table. This string will prefix the parameter table keys; an identifier will
be appended for each column.

For example, if the prefix key is '_column_' then the first column will have the key '_column_0', the second will have
the key '_column_1', the 23rd will have key '_column_22', etc.. The value corresponding to each key will be taken from
the cells of the table; if a cell is empty the column will not be mapped.

Note that any metadata keys that inadvertently match the mapping will be stowed while children operations are being
invoked, and reset afterward. All other metadata, including metadata added by children, are unaffected.

Also note that cells can be deleted by deleting the key-value pair, and new cells can be added by inserting a new
key-value pair.

##### Default

- ```"_column_"```

##### Examples

- ```"c_"```
- ```"mapped_column_number"```
- ```"xyz"```

#### RowNumberKey

##### Description

Optionally used to inform children operations which row number is being processed.

Note that any metadata keys that inadvertently match the mapping will be stowed while children operations are being
invoked, and reset afterward. All other metadata, including metadata added by children, are unaffected.

##### Default

- ```"_row_"```

##### Examples

- ```"key"```
- ```"mapped_row_number"```
- ```"xyz"```

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### SkipHeaderRows

##### Description

Controls the number of non-empty rows at the top that are assumed to contain a header and are skipped.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"2"```
- ```"3"```


----------------------------------------------------

## MaskParameters

### Tags

- category: meta
- category: parameter table

### Description

This operation is a meta-operation that temporarily alters the global parameter table. Child operations are executed
with the adjusted parameter table, which affects what key-values appear.

### Aliases

- MaskMetadata

### Notes

- The parameter table is a shared object that all operations have access to. This operation creates a snapshot of the
  parameter table, optionally modifies the copy, invokes children operations, and then resets the original parameter
  table.

### Parameters

- Method

#### Method

##### Description

Controls how the parameter table is merged after invoking children operations.

'reset' causes the temporary copy to be discarded and the original, unmodified parameter table to be reinstated.

'retain' causes the temporary copy to permanently take the place of the original parameter table.

'transaction' causes the temporary copy to permanently take the place of the original parameter table, but *only* if all
children operations complete successfully. If the children operations fail or return false, the original, unmodified
parameter table will be reinstated. This method is helpful to ensure a multi-part operation is either completed fully,
or has no impact.

##### Default

- ```"reset"```

##### Supported Options

- ```"reset"```
- ```"retain"```
- ```"transaction"```


----------------------------------------------------

## MaskVerbosity

### Tags

- category: meta

### Description

This operation is a meta-operation that temporarily alters the global log verbosity level. Child operations are executed
with the adjusted verbosity level, which affects what log messages, and thus notifications, are suppressed.

### Aliases

- MaskWarnings
- MaskLogs
- MaskNotifications
- SilenceWarnings
- SilenceLogs
- SilenceVerbosity
- SilenceNotifications

### Notes

- The log is a global object, accessible by all threads in the process. Adjusting the log verbosity in one thread will
  also impact all other threads, so it is best to avoid multiple concurrent calls where logs may be written. (Note:
  recursively calling this operation, i.e., calling this operation as a child of itself, is ok.)

### Parameters

- Verbosity
- Permanent

#### Verbosity

##### Description

Controls whether to 'increase' or 'decrease' verbosity.

##### Default

- ```"decrease"```

##### Supported Options

- ```"decrease"```
- ```"increase"```

#### Permanent

##### Description

Controls whether the original verbosity levels are reset after invoking children operations. If false, the effect is
temporary and applied only to children operations. If true, the effect is permanent and applies to all subsequent
operations.

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```


----------------------------------------------------

## MaxMinPixels

### Tags

- category: image processing

### Description

This operation replaces pixels with the pixel-wise difference (max)-(min).

### Parameters

No registered options.

----------------------------------------------------

## MeldDose

### Tags

- category: image processing
- category: radiation dose

### Description

This operation melds all available dose image data. At a high level, dose melding sums overlapping pixel values for
multi-part dose arrays. For more information about what this specifically entails, refer to the appropriate subroutine.

### Parameters

No registered options.

----------------------------------------------------

## MinkowskiSum3D

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: contour processing
- category: image processing
- category: mesh processing

### Description

This operation computes a Minkowski sum or symmetric difference of a 3D surface mesh generated from the selected ROIs
with a sphere. The effect is that a margin is added or subtracted to the ROIs, causing them to 'grow' outward or
'shrink' inward. Exact and inexact routines can be used.

### Parameters

- ROILabelRegex
- ROISelection
- NormalizedROILabelRegex
- ImageSelection
- Operation
- Distance

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified. Note that the selected images are used to sample the
new contours on. Image planes need not match the original since a full 3D mesh surface is generated.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Operation

##### Description

The specific operation to perform. Available options are: 'dilate_exact_surface', 'dilate_exact_vertex',
'dilate_inexact_isotropic', 'erode_inexact_isotropic', and 'shell_inexact_isotropic'.

##### Default

- ```"dilate_inexact_isotropic"```

##### Supported Options

- ```"dilate_exact_surface"```
- ```"dilate_exact_vertex"```
- ```"dilate_inexact_isotropic"```
- ```"erode_inexact_isotropic"```
- ```"shell_inexact_isotropic"```

#### Distance

##### Description

For dilation and erosion operations, this parameter controls the distance the surface should travel. For shell
operations, this parameter controls the resultant thickness of the shell. In all cases DICOM units are assumed.

##### Default

- ```"1.0"```

##### Examples

- ```"0.5"```
- ```"1.0"```
- ```"2.0"```
- ```"3.0"```
- ```"5.0"```


----------------------------------------------------

## ModelIVIM

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: diffusion
- category: image processing
- category: modeling
- category: perfusion

### Description

This operation fits an Intra-voxel Incoherent Motion (IVIM) model to a series of diffusion-weighted MR images.

### Notes

- Images are overwritten, but their geometry is used to define the final map. ReferenceImages are used for modeling, but
  are treated as read-only. ReferenceImages should correspond to unique b-values, one b-value per ReferenceImages array.

- The reference image array must be rectilinear. (This is a requirement specific to this implementation, a less
  restrictive implementation could overcome the issue.)

- For the fastest and most accurate results, test and reference image arrays should spatially align. However, alignment
  is **not** necessary. If test and reference image arrays are aligned, image adjacency can be precomputed and the
  analysis will be faster. If not, image adjacency must be evaluated for each image slice. If this also fails, it will
  be evaluated for every voxel.

- This operation will make use of interpolation if corresponding voxels do not exactly overlap.

### Parameters

- ImageSelection
- ReferenceImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Model
- Channel
- TestImgLowerThreshold
- TestImgUpperThreshold

#### ImageSelection

##### Description

The transformed image array where voxel intensities represent the Apparent Diffusion Coefficient (ADC). Select one or
more image arrays. Note that image arrays can hold anything, but will typically represent a single contiguous 3D volume
(i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically unrelated images
together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"first"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ReferenceImageSelection

##### Description

The 3D image arrays where each 3D volume corresponds to a single b-value. Select one or more image arrays. Note that
image arrays can hold anything, but will typically represent a single contiguous 3D volume (i.e., a volumetric CT scan)
or '4D' time-series. Be aware that it is possible to mix logically unrelated images together. Selection specifiers can
be of three types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"!first"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Model

##### Description

The model that will be fitted. Currently, 'adc-simple' , 'adc-ls' , 'auc-simple', 'biexp', and 'kurtosis' are available.

The 'adc-simple' is a simplistic diffusion model that ignores perfusion. It models only free diffusion using only the
minimum and maximum b-values. An analytical estimate of ADC (i.e., the apparent diffusion coefficient) is generated.

The 'adc-ls' model, like 'adc-simple', is a simplistic model that ignores perfusion. It fits a linearized least-squares
model that uses all available b-value images. Like 'adc-simple', this model only estimates ADC.

The 'auc-simple' model is a simplistic, nonparametric model that integrates the area under the intensity-vs-b-value
curve. Note that no model fitting is performed; the voxel intensity-b-value product is summed directly. No extrapolation
is performed.

The 'biexp' model uses a segmented fitting approach along with Marquardt's method to fit a biexponential model, which
estimates the pseudodiffusion fraction, the diffusion coefficient, and the pseudodiffusion coefficient for each voxel.

The 'kurtosis' model returns three parameters corresponding to a biexponential diffusion model with a kurtosis
adjustment and a noise floor parameter added in quadrature (pseudodiffusion fraction, diffusion, and pseudodiffusion
coefficient for each voxel).

##### Default

- ```"adc-simple"```

##### Supported Options

- ```"adc-simple"```
- ```"adc-ls"```
- ```"auc-simple"```
- ```"biexp"```
- ```"kurtosis"```

#### Channel

##### Description

The channel to compare (zero-based). Setting to -1 will compare each channel separately. Note that both test images and
reference images must share this specifier.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```

#### TestImgLowerThreshold

##### Description

Pixel lower threshold for the test images. Only voxels with values above this threshold (inclusive) will be altered.

##### Default

- ```"-inf"```

##### Examples

- ```"-inf"```
- ```"0.0"```
- ```"200"```

#### TestImgUpperThreshold

##### Description

Pixel upper threshold for the test images. Only voxels with values below this threshold (inclusive) will be altered.

##### Default

- ```"inf"```

##### Examples

- ```"inf"```
- ```"1.23"```
- ```"1000"```


----------------------------------------------------

## ModifyContourMetadata

### Tags

- accepts parameter: contours
- category: contour processing
- category: metadata

### Description

This operation injects metadata into contours.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- KeyValues

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### KeyValues

##### Description

Key-value pairs in the form of 'key1@value1;key2@value2' that will be injected into the selected images. Existing
metadata will be overwritten. Both keys and values are case-sensitive. Note that a semi-colon separates key-value pairs,
not a colon. Note that quotation marks are not stripped internally, but may have to be provided for the shell to
properly interpret the argument.

##### Default

- ```""```

##### Examples

- ```"Description@'some description'"```
- ```"'Description@some description'"```
- ```"MinimumSeparation@1.23"```
- ```"'Description@some description;MinimumSeparation@1.23'"```


----------------------------------------------------

## ModifyImageMetadata

### Tags

- accepts parameter: images
- category: image processing
- category: meta

### Description

This operation injects metadata into images. It can also modify image spatial characteristics, which are distinct from
metadata.

### Parameters

- ImageSelection
- KeyValues
- SliceThickness
- VoxelWidth
- VoxelHeight
- ImageAnchor
- ImagePosition
- ImageOrientationColumn
- ImageOrientationRow

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### KeyValues

##### Description

Key-value pairs in the form of 'key1@value1;key2@value2' that will be injected into the selected objects. Values can use
macros that refer to other metadata keys using the '$' character. If macros refer to non-existent metadata elements,
then the replacement is literal. Dates, times, and datetimes can be converted to seconds (since the Unix epoch) using
the 'to_seconds()' function.

Existing conflicting metadata will be overwritten. Both keys and values are case-sensitive. Note that a semi-colon
separates key-value pairs, not a colon. Note that quotation marks are not stripped internally, but may have to be
provided on the command line for shells to properly interpret the argument. Also note that updating spatial metadata
will not result in the object characteristics being altered -- use the specific parameters provided to update spatial
characteristics.

##### Default

- ```""```

##### Examples

- ```"Description@'some description'"```
- ```"'Description@some description'"```
- ```"'Description@Research scan performed on $ContentDate'"```
- ```"'ContentTimeInSeconds@to_seconds($ContentDate-$ContentDate)'"```
- ```"MinimumSeparation@1.23"```
- ```"'Description@some description;MinimumSeparation@1.23'"```

#### SliceThickness

##### Description

Image slices will be have this thickness (in DICOM units: mm). For most purposes, SliceThickness should be equal to
SpacingBetweenSlices. If SpacingBetweenSlices is smaller than SliceThickness, images will overlap. If
SpacingBetweenSlices is larger than SliceThickness, there will be a gap between images. Updating the SliceThickness or
image positioning using this operation will alter the image, but will not update SpacingBetweenSlices. This gives the
user freedom to alter all image planes individually, allowing construction of non-rectilinear image volumes. If
SpacingBetweenSlices is known and consistent, it should be reflected in the image metadata (by the user).

##### Default

- ```"1.0"```

##### Examples

- ```"0.1"```
- ```"0.5"```
- ```"1.0"```
- ```"10.0"```

#### VoxelWidth

##### Description

Voxels will have this (in-plane) width (in DICOM units: mm). This means that the centre of two voxels that are in the
same row but adjacent columns will be separated by VoxelWidth. Each voxel will have dimensions: VoxelWidth x VoxelHeight
x SliceThickness.

##### Default

- ```"1.0"```

##### Examples

- ```"0.1"```
- ```"0.5"```
- ```"1.0"```
- ```"10.0"```

#### VoxelHeight

##### Description

Voxels will have this (in-plane) height (in DICOM units: mm). This means that the centre of two voxels that are in the
same column but adjacent rows will be separated by VoxelHeight. Each voxel will have dimensions: VoxelWidth x
VoxelHeight x SliceThickness.

##### Default

- ```"1.0"```

##### Examples

- ```"0.1"```
- ```"0.5"```
- ```"1.0"```
- ```"10.0"```

#### ImageAnchor

##### Description

A point in 3D space which denotes the origin (in DICOM units: mm). All other vectors are taken to be relative to this
point. Under most circumstance the anchor should be (0,0,0). Specify coordinates separated by commas.

##### Default

- ```"0.0, 0.0, 0.0"```

##### Examples

- ```"0.0, 0.0, 0.0"```
- ```"0.0,0.0,0.0"```
- ```"1.0, -2.3, 45.6"```

#### ImagePosition

##### Description

The centre of the row=0, column=0 voxel in the first image (in DICOM units: mm). Specify coordinates separated by
commas.

##### Default

- ```"0.0, 0.0, 0.0"```

##### Examples

- ```"0.0, 0.0, 0.0"```
- ```"100.0,100.0,100.0"```
- ```"1.0, -2.3, 45.6"```

#### ImageOrientationColumn

##### Description

The orientation unit vector that is aligned with image columns. Care should be taken to ensure ImageOrientationRow and
ImageOrientationColumn are orthogonal. (A Gram-Schmidt orthogonalization procedure ensures they are, but the image
orientation may not match the expected orientation.) Note that the magnitude will also be scaled to unit length for
convenience. Specify coordinates separated by commas.

##### Default

- ```"1.0, 0.0, 0.0"```

##### Examples

- ```"1.0, 0.0, 0.0"```
- ```"1.0, 1.0, 0.0"```
- ```"0.0, 0.0, -1.0"```

#### ImageOrientationRow

##### Description

The orientation unit vector that is aligned with image rows. Care should be taken to ensure ImageOrientationRow and
ImageOrientationColumn are orthogonal. (A Gram-Schmidt orthogonalization procedure ensures they are, but the image
orientation may not match the expected orientation.) Note that the magnitude will also be scaled to unit length for
convenience. Specify coordinates separated by commas.

##### Default

- ```"0.0, 1.0, 0.0"```

##### Examples

- ```"0.0, 1.0, 0.0"```
- ```"0.0, 1.0, 1.0"```
- ```"-1.0, 0.0, 0.0"```


----------------------------------------------------

## ModifyLineSamples

### Tags

- accepts parameter: line samples
- category: line sample processing

### Description

This operation can apply a variety of processing algorithms to line samples, providing functionality that supports
smoothing, normalization, arithmetical operations, and analysis of line samples.

### Parameters

- LineSelection
- Methods

#### LineSelection

##### Description

Select one or more line samples. Selection specifiers can be of three types: positional, metadata-based key@value regex,
and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth line sample (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last line sample.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the line sample composed of the greatest and fewest number of samples. Only one or zero line sample will be
selected; if there are ties, there is no guarantee which line sample will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple line sample based on a threshold count, i.e., where all selected line sample have
more than or fewer than $N$ samples. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all line sample that do not have the greatest number of samples, not the least-numerous line sample (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Methods

##### Description

A list of methods to apply to the selected line samples. Multiple methods can be specified, and are applied sequentially
in the order supplied. Note that some methods accept parameters.

Option 'abscissa-offset' finds the left-most abscissa value from all selected line samples, and subtracts it from each
individual line sample abscissa.

Option 'ordinate-offset' finds the bottom-most ordinate value from all selected line samples, and subtracts it from each
individual line sample ordinate.

Option 'average-coincident-values' ensures there is a single datum with the given abscissa range, across the entire line
sample, averaging adjacent data if necessary.

Option 'purge-redundant-samples' ensures there is a single datum with the given abscissa and ordinate range across the
entire line sample, purging adjacent data if necessary.

Option 'rank-abscissa' replaces the abscissa values with their ordered rank number.

Option 'rank-ordinate' replaces the ordinate values with their ordered rank number.

Option 'swap-abscissa-and-ordinate' swaps the abscissa and ordinate for each individual datum.

Option 'select-abscissa-range' trims all datum that fall outside of the provided abscissa range. The selection is
inclusive, so datum coinciding with one or both endpoints will be retained.

Option 'crossings' locates the places where each line sample crosses the provided ordinate value (using linear
interpolation) and returns a new line sample containing only the crossings.

Option 'peaks' locates the local peaks for each line sample (using linear interpolation) and returns a new line sample
containing only the peaks.

Option 'resample-equal-spacing' resamples each line sample into approximately equally-spaced samples using linear
interpolation. The number of outgoing samples needs to be provided, e.g., 100.

Option 'multiply-scalar' multiplies all ordinates by the provided scalar factor.

Option 'sum-scalar' adds to all ordinates the provided scalar factor.

Option 'absolute-ordinate' replaces the ordinate of each line sample with its absolute value.

Option 'purge-nonfinite' censors all datum with infinite or NaN coordinates.

Option 'histogram' generates a histogram with N equal-width bins. Each bin's height is the sum of the samples that
appear within the bin's domain. This method can also optionally add an outline surrounding the histogram bins for
visualization purposes by supplying a second numerical argument that evaluates to 'true' (e.g., 1).

Option 'moving-average-two-sided-15-sample' computes the "Spencer's" 15-sample moving average, averaging the ordinates.
This is a convolution that effectively acts like a low-pass filter, letting polynomials of order 3 or less through
approximately as-is.

Option 'moving-average-two-sided-23-sample' computes the "Henderson's" 23-sample moving average, averaging the
ordinates. This is a convolution that effectively acts like a low-pass filter, letting polynomials of order 3 or less
through approximately as-is.

Option 'moving-average-two-sided-equal-weighting' computes a $(2N+1)$-sample moving average, averaging the ordinates
with equal weighting. The discrete window size $N$ must be supplied.

Option 'moving-average-two-sided-gaussian-weighting' computes a moving average, averaging the ordinates using gaussian
weighting. The width of the gaussian ($\sigma$) must be supplied. Applying consecutively emulates applying once with a
larger width.

Option 'moving-median-filter-two-sided-equal-weighting' computes a $(2N+1)$-sample moving median filter of the ordinate
values. All ordinates are weighted identically. The discrete window size $N$ must be supplied.

Option 'moving-median-filter-two-sided-gaussian-weighting' computes a $(2N+1)$-sample moving median filter of the
ordinate values, using gaussian weighting to scale ordinates based on their distance. The width of the gaussian
($\sigma$) must be supplied.

Option 'moving-median-filter-two-sided-triangular-weighting' computes a $(2N+1)$-sample moving median filter of the
ordinate values. All ordinates are weighted linearly based on their rank position relative to the averaging point. The
discrete window size $N$ must be supplied.

Option 'moving-variance-two-sided' calculates an unbiased estimate of a population's variance over a window of ($2N+1$)
samples. Endpoint variance estimation uses fewer samples (min = N) and have higher variance. Setting N to be 5 or higher
is recommended. The discrete window size $N$ must be supplied.

Option 'derivative-forward-finite-differences' calculates the discrete derivative using forward finite differences. The
right-side endpoint uses backward finite differences to handle the boundary. Data should be reasonably smooth -- no
interpolation is used.

Option 'derivative-backward-finite-differences' calculates the discrete derivative using backward finite differences.
The left-side endpoint uses forward finite differences to handle the boundary. Data should be reasonably smooth -- no
interpolation is used.

Option 'derivative-backward-centered-differences' calculates the discrete derivative using centered finite differences.
The endpoints use either forward or backward finite differences to handle the boundaries. Data should be reasonably
smooth -- no interpolation is used.

Option 'local-signed-curvature-three-sample' calculates the local signed curvature at each sample using the two
nearest-neighbour samples. Endpoints are discarded. Curvature here is the tangent circle's inverse radius, and the sign
indicates the direction of concavity.

##### Default

- ```""```

##### Examples

- ```"abscissa-offset()"```
- ```"ordinate-offset()"```
- ```"average-coincident-values(0.5)"```
- ```"purge-redundant-samples(0.5, 1.23)"```
- ```"rank-abscissa()"```
- ```"rank-ordinate()"```
- ```"swap-abscissa-and-ordinate()"```
- ```"select-abscissa-range(-1.23, 2.34)"```
- ```"crossings(0.0)"```
- ```"peaks()"```
- ```"resample-equal-spacing(100)"```
- ```"multiply-scalar(1.25)"```
- ```"sum-scalar(-1.23)"```
- ```"absolute-ordinate()"```
- ```"purge-nonfinite()"```
- ```"histogram(100)"```
- ```"histogram(100, 1)"```
- ```"moving-average-two-sided-15-sample()"```
- ```"moving-average-two-sided-23-sample()"```
- ```"moving-average-two-sided-equal-weighting(5)"```
- ```"moving-average-two-sided-gaussian-weighting(1.23)"```
- ```"moving-median-filter-two-sided-equal-weighting(5)"```
- ```"moving-median-filter-two-sided-gaussian-weighting(1.23)"```
- ```"moving-median-filter-two-sided-triangular-weighting(5)"```
- ```"moving-variance-two-sided(5)"```
- ```"derivative-forward-finite-differences()"```
- ```"derivative-backward-finite-differences()"```
- ```"derivative-centered-finite-differences()"```
- ```"local-signed-curvature-three-sample()"```


----------------------------------------------------

## ModifyParameters

### Tags

- category: parameter table

### Description

Define or delete a key-value parameter into/from the global parameter table.

### Parameters

- Actions

#### Actions

##### Description

Three actions are understood: 'define', 'insert', and 'remove'. The 'define' action accepts a key-value pair and injects
it into the global parameter table. Note that this operation will overwrite any existing parameters with the same key.
The 'insert' action behaves like 'define' except it will not overwrite any existing parameters. The 'delete' action
accepts a key and removes it from the global parameter table if it is already present. Otherwise, no action is taken.

##### Default

- ```""```

##### Examples

- ```"define(key_1, value_1)"```
- ```"insert(key_1, value_1); define('key 2', 'value 2\, which has a comma')"```
- ```"remove('key 3')"```


----------------------------------------------------

## NegatePixels

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation negates pixels for the selected image arrays. This functionality is often desired for processing MR
images.

### Parameters

- ImageSelection

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## NoOp

### Tags

- category: control flow
- category: meta

### Description

This operation does nothing. It produces no side-effects.

### Parameters

No registered options.

----------------------------------------------------

## NoneOf

### Tags

- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that performs a 'none-of' Boolean check by evaluating child operations.
The first child operation that succeeds short-circuits the remaining checks and returns false. If no child operation
succeeds, true is returned. Side effects from all evaluated operations are possible.

### Aliases

- Not
- Negate
- Invert

### Notes

- Child operations are performed in order, and all side-effects are carried forward. In particular, all selectors in
  child operations are evaluated lazily, at the moment when the child operation is invoked.

- Some operations may succeed without directly signalling failure. For example, an operation that loops over all
  selected images may not throw if zero images are selected. This operation works well with other control flow
  meta-operations, for example as a conditional in an if-else statement.

### Parameters

No registered options.

----------------------------------------------------

## NormalizeLineSamples

### Tags

- accepts parameter: line samples
- category: line sample processing

### Description

This operation scales line samples according to a user-provided normalization criteria.

### Notes

- Each line sample is independently normalized.

### Parameters

- LineSelection
- Method

#### LineSelection

##### Description

Select one or more line samples. Selection specifiers can be of three types: positional, metadata-based key@value regex,
and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth line sample (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last line sample.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the line sample composed of the greatest and fewest number of samples. Only one or zero line sample will be
selected; if there are ties, there is no guarantee which line sample will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple line sample based on a threshold count, i.e., where all selected line sample have
more than or fewer than $N$ samples. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all line sample that do not have the greatest number of samples, not the least-numerous line sample (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Method

##### Description

The type of normalization to apply. The currently supported options are 'area' and 'peak'. 'Area' ensures that the total
integrated area is equal to one by scaling the ordinate. 'Peak' ensures that the maximum ordinate is one and the minimum
ordinate is zero.

##### Default

- ```"area"```

##### Supported Options

- ```"area"```
- ```"peak"```


----------------------------------------------------

## NormalizePixels

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This routine normalizes voxel intensities by adjusting them so they satisfy a 'normalization' criteria. This operation
is useful as a pre-processing step when performing convolution or thresholding with absolute magnitudes.

### Notes

- This operation considers entire image arrays, not just single images.

- This operation does not *reduce* voxels (i.e., the neighbourhood surrounding is voxel is ignored). This operation
  effectively applies a linear mapping to every scalar voxel value independently. Neighbourhood-based reductions are
  implemented in another operation.

### Parameters

- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Inclusivity
- ContourOverlap
- Channel
- Method

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. The option 'honour_opposite_orientations' makes overlapping contours with opposite
orientation cancel. Otherwise, orientation is ignored. The latter is useful for Boolean structures where contour
orientation is significant for interior contours (holes). The option 'overlapping_contours_cancel' ignores orientation
and cancels all contour overlap.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Channel

##### Description

The channel to operate on (zero-based). Negative values will cause all channels to be operated on.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```

#### Method

##### Description

Controls the specific type of normalization that will be applied.

'Stretch01' will rescale the voxel values so the minima are 0 and the maxima are 1. Likewise, 'stretch11' will rescale
such that the minima are -1 and the maxima are 1.

Clamp will ensure all voxel intensities are within [0:1] by setting those lower than 0 to 0 and those higher than 1 to
1. (Voxels already within [0:1] will not be altered.)

'Sum-to-zero' will shift all voxels so that the sum of all voxel intensities is zero. (This is useful for convolution
kernels.)

'SUVbw' scales PET images in 'Bq/ml' to body-weight SUV. Note that this method will likely fail if images do not have a
PET modality. See <https://doi.org/10.2967/jnmt.119.233353> for additional details.

##### Default

- ```"stretch11"```

##### Supported Options

- ```"clamp"```
- ```"stretch01"```
- ```"stretch11"```
- ```"sum-to-zero"```
- ```"suv-bw"```


----------------------------------------------------

## NotifyUser

### Tags

- category: interactive
- category: meta

### Description

This operation attempts to notify the user using a tray notification.

### Parameters

- Notifications

#### Notifications

##### Description

A list of notifications to send to the user, where each function represents a single notification. Currently only tray
notifications are supported. Accepted syntax is 'tray(urgency, message, duration)' where urgency is 'low', 'medium', or
'high' and duration is in milliseconds. Duration is optional. All notifications will be displayed concurrently. For
example, 'tray("low", "Calculation finished.", 5000)' will send a low-urgency notification that a calculation finished.
It will be displayed for 5 seconds.

##### Default

- ```""```

##### Examples

- ```"tray('low', 'Calculation finished')"```
- ```"tray('medium', 'Minor issue detected', 5000); tray(high, 'Severe error encountered', 10000)"```


----------------------------------------------------

## OptimizeStaticBeams

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: acquires futex
- category: file export
- category: radiation dose
- category: rtplan processing

### Description

This operation takes dose matrices corresponding to single, static RT beams and attempts to optimize beam weighting to
create an optimal plan subject to various criteria.

### Notes

- This routine is a simplisitic routine that attempts to estimate the optimal beam weighting. It should NOT be used for
  clinical purposes, except maybe as a secondary check or a means to guess reasonable beam weights prior to optimization
  within the clinical TPS.

- Because beam weights are (generally) not specified in DICOM RTDOSE files, the beam weights are assumed to all be 1.0.
  If they are not all 1.0, the weights reported here will be relative to whatever the existing weights are.

- If no PTV ROI is available, the BODY contour may suffice. If this is not available, dose outside the body should
  somehow be set to zero to avoid confusing D_{max} metrics. For example, bolus D_{max} can be high, but is ultimately
  irrelevant.

- By default, this routine uses all available images. This may be fixed in a future release. Patches are welcome.

### Parameters

- ImageSelection
- ResultsSummaryFileName
- UserComment
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- MaxVoxelSamples
- NormalizationD
- NormalizationV
- RxDose

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ResultsSummaryFileName

##### Description

This file will contain a brief summary of the results. The format is CSV. Leave empty to dump to generate a unique
temporary file. If an existing file is present, rows will be appended without writing a header.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### MaxVoxelSamples

##### Description

The maximum number of voxels to randomly sample (deterministically) within the PTV. Setting lower will result in faster
calculation, but lower precision. A reasonable setting depends on the size of the target structure; small targets may
suffice with a few hundred voxels, but larger targets probably require several thousand.

##### Default

- ```"1000"```

##### Examples

- ```"200"```
- ```"500"```
- ```"1000"```
- ```"2000"```
- ```"5000"```

#### NormalizationD

##### Description

The isodose value that should envelop a given volume in the PTV ROI. In other words, this parameter is the 'D' parameter
in a DVH constraint of the form $V_{D} \geq V_{min}$. It should be given as a fraction within [0:1] relative to the
prescription dose. For example, 95% isodose should be provided as '0.95'.

##### Default

- ```"0.95"```

##### Examples

- ```"0.90"```
- ```"0.95"```
- ```"0.98"```
- ```"0.99"```
- ```"1.0"```

#### NormalizationV

##### Description

The minimal fractional volume of ROI that should be enclosed within one or more surfaces that demarcate the given
isodose value. In other words, this parameter is the 'Vmin' parameter in a DVH constraint of the form $V_{D} \geq
V_{min}$. It should be given as a fraction within [0:1] relative to the volume of the ROI (typically discretized to the
number of voxels in the ROI). For example, if Vmin = 99%, provide the value '0.99'.

##### Default

- ```"0.99"```

##### Examples

- ```"0.90"```
- ```"0.95"```
- ```"0.98"```
- ```"0.99"```
- ```"1.0"```

#### RxDose

##### Description

The dose prescribed to the ROI that will be optimized. The units depend on the DICOM file, but will likely be Gy.

##### Default

- ```"70.0"```

##### Examples

- ```"48.0"```
- ```"60.0"```
- ```"63.3"```
- ```"70.0"```
- ```"100.0"```


----------------------------------------------------

## OrderImages

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation will order either individual image slices within each image array, or image arrays based on the values of
the specified metadata tags.

### Notes

- Images and image arrays are moved, not copied.

- Image arrays (groupings) are always retained, though the order of images within each array and the order of the arrays
  themselves will change.

- Images that do not contain the specified metadata will be placed at the end. Similarly, image arrays that do not have
  consensus (i.e., the constituent images have heterogeneous metadata) will be placed at the end.

- Image array sorting permits selection of specific image arrays. Only selected arrays will participate in the sort, and
  sorted selection will be reinjected such that the position of all unselected arrays remain unchanged. For example,
  representing unselected arrays as letters (ABC...) and selected arrays as numbers (123...) then sorting 'AB3C12' would
  result in 'AB1C23'. Note that the unselected arrays do not move, even when the selected arrays are reordered.

### Parameters

- ImageSelection
- Variant
- Key
- Unit

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Variant

##### Description

Controls whether images (internal) or image arrays (external) are sorted.

##### Default

- ```"internal"```

##### Supported Options

- ```"internal"```
- ```"external"```

#### Key

##### Description

Metadata key to use for ordering. Values will be sorted according to a 'natural' sorting order, which greedily compares
sub-strings of numbers and characters separately. Note this ordering is expected to be stable, but may not always be on
some systems.

##### Default

- ```""```

##### Examples

- ```"AcquisitionTime"```
- ```"ContentTime"```
- ```"SeriesNumber"```
- ```"SeriesDescription"```

#### Unit

##### Description

Unit vector use for spatial ordering. Images will be sorted according to the position of the corner nearest the (0,0)
voxel along the given unit vector. For image arrays, the 'first' image is used -- which occurs 'first' can be controlled
by first sorting internally.

##### Default

- ```""```

##### Examples

- ```"(0.0, 0.0, 1.0)"```
- ```"(0.0, -1.0, 0.0)"```
- ```"(0.1, -0.2, 0.3)"```


----------------------------------------------------

## PartitionContours

### Tags

- accepts parameter: contours
- category: contour processing

### Description

This operation partitions the selected contours, producing a number of sub-segments that could be re-combined to
re-create the original contours.

### Parameters

- ROILabelRegex
- ROISelection
- NormalizedROILabelRegex
- PlanarOrientation
- SubsegmentRootROILabel
- SubsegMethod
- NestedCleaveOrder
- XPartitions
- YPartitions
- ZPartitions
- ReverseXTraversalOrder
- ReverseYTraversalOrder
- ReverseZTraversalOrder
- FractionalTolerance
- MaxBisects

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### PlanarOrientation

##### Description

A string instructing how to orient the cleaving planes. Currently supported:

1. 'cardinal', which aligns the planes with the cardinal direction axes unit vectors. This method is most consistent,
but does not adapt to the anatomy of the subject. It works best when the subject's contours are defined on axial slices
in HFS position or have otherwise been transferred or transformed to this alignment.

2. 'axis-aligned', which aligns the cleave plane's Z axis with the average contour normal and uses a Gram-Schmidt
process to provide best-guesses for appropriate X and Y unit vectors. This method adapts to the subject's position but
because the contour planes and the cleaving planes are coplanar, it can result in splitting difficulties (e.g.,
degeneracies, numerical precision issues like contours being split into many thin, jagged sub-segments). If using this
method, consider limiting the number of iterations and fractional tolerance to help minimize risk of numerical issues.

3. 'static-oblique', which is the same as 'axis-aligned', but rotates all unit vectors by 22.5 degrees to reduce
coplanarity of the contour plane and the cleaving plane. This sometimes improves sub-segment area consistency, but
results in oblique sub-segments.

##### Default

- ```"axis-aligned"```

##### Supported Options

- ```"cardinal"```
- ```"axis-aligned"```
- ```"static-oblique"```

#### SubsegmentRootROILabel

##### Description

The root ROI label to attach to the sub-segments. The full name will be this root followed by '_' and the number of the
subsegment.

##### Default

- ```"subsegment"```

##### Examples

- ```"subsegment"```
- ```"ss"```
- ```"partition"```

#### SubsegMethod

##### Description

The method to use for sub-segmentation. Nested sub-segmentation should almost always be preferred unless you know what
you're doing. It should be faster too. Compound sub-segmentation is known to cause problems, e.g., with zero-area
sub-segments and spatial dependence in sub-segment volume. Nested cleaving will produce sub-segments of equivalent area
(volume) throughout the entire ROI whereas compound sub-segmentation will not.

##### Default

- ```"nested-cleave"```

##### Supported Options

- ```"nested-cleave"```
- ```"compound-cleave"```

#### NestedCleaveOrder

##### Description

The order in which to apply nested cleaves. This routine requires one of 'ZYX', 'ZXY', 'XYZ', 'XZY', 'YZX', or 'YXZ'.
Cleaves are implemented from left to right using the specified X, Y, and Z selection criteria.

##### Default

- ```"ZXY"```

##### Supported Options

- ```"ZXY"```
- ```"ZYX"```
- ```"XYZ"```
- ```"XZY"```
- ```"YZX"```
- ```"YXZ"```

#### XPartitions

##### Description

The number of partitions to find along the 'X' axis. The total number of sub-segments produced along the 'X' axis will
be (1+XPartitions). A value of zero will disable the partitioning along the 'X' axis.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"3"```
- ```"5"```
- ```"50"```

#### YPartitions

##### Description

The number of partitions to find along the 'Y' axis. The total number of sub-segments produced along the 'Y' axis will
be (1+YPartitions). A value of zero will disable the partitioning along the 'Y' axis.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"3"```
- ```"5"```
- ```"50"```

#### ZPartitions

##### Description

The number of partitions to find along the 'Z' axis. The total number of sub-segments produced along the 'Z' axis will
be (1+ZPartitions). A value of zero will disable the partitioning along the 'Z' axis.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"3"```
- ```"5"```
- ```"50"```

#### ReverseXTraversalOrder

##### Description

Controls the order in which sub-segments are numbered. If set to 'true' the numbering will be reversed along the X axis.
This option is most useful when the 'X' axis intersects mirrored ROIs (e.g., left and right parotid glands).

##### Default

- ```"false"```

##### Examples

- ```"false"```
- ```"true"```

#### ReverseYTraversalOrder

##### Description

Controls the order in which sub-segments are numbered. If set to 'true' the numbering will be reversed along the Y axis.
This option is most useful when the 'Y' axis intersects mirrored ROIs (e.g., left and right parotid glands).

##### Default

- ```"false"```

##### Examples

- ```"false"```
- ```"true"```

#### ReverseZTraversalOrder

##### Description

Controls the order in which sub-segments are numbered. If set to 'true' the numbering will be reversed along the Z axis.
This option is most useful when the 'Z' axis intersects mirrored ROIs (e.g., left and right parotid glands).

##### Default

- ```"false"```

##### Examples

- ```"false"```
- ```"true"```

#### FractionalTolerance

##### Description

The tolerance of X, Y, and Z fractional area bisection criteria (see ZSelection description). This parameter specifies a
stopping condition for the bisection procedure. If it is set too high, sub-segments may be inadequatly rough. If it is
set too low, bisection below the machine precision floor may be attempted, which will result in instabilities. Note that
the number of permitted iterations will control whether this tolerance can possibly be reached; if strict adherence is
required, set the maximum number of iterations to be excessively large.

##### Default

- ```"0.001"```

##### Examples

- ```"1E-2"```
- ```"1E-3"```
- ```"1E-4"```
- ```"1E-5"```

#### MaxBisects

##### Description

The maximum number of iterations the bisection procedure can perform. This parameter specifies a stopping condition for
the bisection procedure. If it is set too low, sub-segments may be inadequatly rough. If it is set too high, bisection
below the machine precision floor may be attempted, which will result in instabilities. Note that the fractional
tolerance will control whether this tolerance can possibly be reached; if an exact number of iterations is required, set
the fractional tolerance to be excessively small.

##### Default

- ```"20"```

##### Examples

- ```"10"```
- ```"20"```
- ```"30"```


----------------------------------------------------

## PerturbPixels

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This operation applies random noise to voxel intensities. It can be used to help fuzz testing or benchmark statistical
analysis.

### Parameters

- Channel
- ImageSelection
- ContourOverlap
- Inclusivity
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Model
- Method
- Seed

#### Channel

##### Description

The image channel to use. Zero-based. Use '-1' to operate on all available channels.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. This will effectively honour only the outermost contour regardless of orientation,
but provides the most predictable and consistent results. The option 'honour_opposite_orientations' makes overlapping
contours with opposite orientation cancel. Otherwise, orientation is ignored. This is useful for Boolean structures
where contour orientation is significant for interior contours (holes). If contours do not have consistent overlap
(e.g., if contours intersect) the results can be unpredictable and hard to interpret. The option
'overlapping_contours_cancel' ignores orientation and alternately cancerls all overlapping contours. Again, if the
contours do not have consistent overlap (e.g., if contours intersect) the results can be unpredictable and hard to
interpret.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Model

##### Description

Controls which type of noise is applied.

'gaussian(centre, std_dev)' applies a Gaussian model centered on 'centre' with the given standard deviation.

'uniform(lower, upper)' applies a uniform noise model where noise values are selected with equal probability inside the
range [lower, upper].

Note that if any parameters have a '%' or 'x' suffix, they are treated as percentages or fractions relative to the
pre-perturbed voxel intensity.

##### Default

- ```"gaussian(0.0, 1.0)"```

##### Examples

- ```"gaussian(0.0, 1.0)"```
- ```"gaussian(0.0, 0.5x)"```
- ```"gaussian(0.0, 50%)"```
- ```"gaussian(2.5, 50%)"```
- ```"gaussian(0.2x, 0.1)"```
- ```"uniform(-1.0, 1.0)"```
- ```"uniform(-1.0x, 1.0x)"```

#### Method

##### Description

Controls how the noise is applied to the voxel intensity.

##### Default

- ```"additive"```

##### Examples

- ```"additive"```
- ```"multiplicative"```

#### Seed

##### Description

The seed value to use for random number generation.

##### Default

- ```"1337"```

##### Examples

- ```"1"```
- ```"1337"```
- ```"1500450271"```


----------------------------------------------------

## PlotLineSamples

### Tags

- accepts parameter: line samples
- category: interactive
- category: line sample processing
- category: needs refresh

### Description

This operation plots the selected line samples.

### Parameters

- LineSelection
- Title
- AbscissaLabel
- OrdinateLabel

#### LineSelection

##### Description

Select one or more line samples. Selection specifiers can be of three types: positional, metadata-based key@value regex,
and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth line sample (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last line sample.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the line sample composed of the greatest and fewest number of samples. Only one or zero line sample will be
selected; if there are ties, there is no guarantee which line sample will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple line sample based on a threshold count, i.e., where all selected line sample have
more than or fewer than $N$ samples. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all line sample that do not have the greatest number of samples, not the least-numerous line sample (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Title

##### Description

The title to display in the plot. Leave empty to disable.

##### Default

- ```""```

##### Examples

- ```"Line Samples"```
- ```"Time Series"```
- ```"DVH for XYZ"```

#### AbscissaLabel

##### Description

The label to attach to the abscissa (i.e., the 'x' or horizontal coordinate). Leave empty to disable.

##### Default

- ```""```

##### Examples

- ```"(arb.)"```
- ```"Time (s)"```
- ```"Distance (mm)"```
- ```"Dose (Gy)"```

#### OrdinateLabel

##### Description

The label to attach to the ordinate (i.e., the 'y' or vertical coordinate). Leave empty to disable.

##### Default

- ```""```

##### Examples

- ```"(arb.)"```
- ```"Intensity (arb.)"```
- ```"Volume (mm^3)"```
- ```"Fraction (arb.)"```


----------------------------------------------------

## PlotPerROITimeCourses

### Tags

- accepts parameter: contours
- category: interactive
- category: line sample processing
- category: needs refresh

### Description

Interactively plot time courses for the specified ROI(s).

### Parameters

- ROILabelRegex
- ROISelection
- NormalizedROILabelRegex

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```


----------------------------------------------------

## PointSeparation

### Tags

- category: file export
- category: point cloud processing

### Description

This operation estimates the minimum and maximum point-to-point separation between two point clouds. It also computes
the longest-nearest (Hausdorff) separation, i.e., the length of the longest lines from points in selection A to the
nearest point in selection B.

### Notes

- This routine scales like $O(N*M)$ where $N$ and $M$ are the number of points in each point cloud. No indexing or
  acceleration is used. Beware that large point clouds will result in slow computations.

- This operation can be used to compare points clouds that are nearly alike. Such comparisons are useful for quantifying
  discrepancies after transformations, reconstructions, simplifications, or any other scenarios where a point cloud must
  be reasonable accurately reproduced.

### Parameters

- PointSelectionA
- PointSelectionB
- FileName
- UserComment

#### PointSelectionA

##### Description

Select one or more point clouds. Note that point clouds can hold a variety of data with varying attributes, but each
point cloud is meant to represent a single logically cohesive collection of points. Be aware that it is possible to mix
logically unrelated points together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"first"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### PointSelectionB

##### Description

Select one or more point clouds. Note that point clouds can hold a variety of data with varying attributes, but each
point cloud is meant to represent a single logically cohesive collection of points. Be aware that it is possible to mix
logically unrelated points together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### FileName

##### Description

A filename (or full path) in which to append separation data generated by this routine. The format is CSV. Leave empty
to dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### UserComment

##### Description

A string that will be inserted into the output file which will simplify merging output with differing parameters, from
different sources, or using sub-selections of the data.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Patient treatment plan C"```


----------------------------------------------------

## PollDirectories

### Tags

- category: meta

### Description

This operation continuously polls ('watches') a directory, waiting for new files. When files are received, they are
loaded and child operations are performed.

### Notes

- This operation can be used to automatically perform an action when data appears in the specified directories. Consider
  this operation a 'trigger' that can initiate further processing.

- Only file names and sizes are used to evaluate when a file was last altered. Filesystem modification times are not
  used, and file contents being altered will not be detected.

- To reduce external dependencies, only rudimentary directory polling methods are used. Polling may therefore be slow
  and/or inefficient, depending on filesystem/OS caching.

- Files will be loaded and processed in batches sequentially, i.e., in 'blocking' mode.

- Before files are processed, they are loaded into the existing Drover object. Similarly after processing, the Drover
  object containing loaded files and processing results are retained. The Drover object can be explicitly cleared after
  processing if needed.

- This operation will stop polling and return false when the first child operation returns false. If files cannot be
  loaded, this operation will also stop polling and return false. Otherwise, this operation will continue polling
  forever. It will never return true.

### Parameters

- Directories
- PollInterval
- SettleDelay
- IgnoreExisting
- GroupBy

#### Directories

##### Description

The directories to poll, separated by semicolons. Files and directories within these directories will be loaded and
processed.

##### Default

- ```"./"```

##### Examples

- ```"/tmp/"```
- ```"/home/user/incoming/;/path/to/another/directory/"```

#### PollInterval

##### Description

The amount of time, in seconds, to wait between polling. Note that the time spent polling (i.e., enumerating directory
contents and metadata) is not included in this time, so the total polling cycle time will be larger than this interval.

##### Default

- ```"5.0"```

##### Examples

- ```"1.0"```
- ```"5"```
- ```"600"```

#### SettleDelay

##### Description

The amount of time, in seconds, that directories need to remain unaltered before processing. When files are copied to
one of the input directories, this amount of time needs to pass before the file will be loaded. If any file is altered
within this time period, the delay timer will reset.

Adding this delay ensures that files still in transit are not loaded early.

##### Default

- ```"60.0"```

##### Examples

- ```"30.0"```
- ```"60"```
- ```"200"```

#### IgnoreExisting

##### Description

Controls whether files present during the first poll should be considered already processed. This option can increase
robustness if irrelevant files are found, but can also result in files being missed if inputs are provided prior to the
first poll.

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```

#### GroupBy

##### Description

Controls how files are grouped together for processing. Currently supported options are 'separate', 'subdirs', and
'altogether'.

Use 'separate' to process files individually, one-at-a-time. This option is most useful for performing checks or
validation of individual files where the logical relations to other files are not important.

Use 'subdirs' to group all files that share a common parent sub-directory or folder. This option will cause all files in
a directory (non-recursively) to be processed together. This option is useful when multiple logically-distinct inputs
are received at the same time, but use a single top-level directory to keep separated.

Use 'altogether' to process all files together as one logical unit, disregarding the directory structure. This option
works best when the directory is expected to receive one set of files at a time, and is robust to the directory
structure (e.g., a set of DICOM files which have been nested in a DICOM tree for optimal filesystem lookup, but not
necessarily grouped logically).

##### Default

- ```"separate"```

##### Supported Options

- ```"separate"```
- ```"subdirs"```
- ```"altogether"```


----------------------------------------------------

## Polyominoes

### Tags

- accepts parameter: images
- category: image processing
- category: simulation

### Description

This operation implements a 2D inventory management survival-horror game using discretized affine transformations on
polyominoes.

### Notes

- This operation will perform a single iteration of a polyomino game. Invoke multiple times to play a complete game.

### Parameters

- ImageSelection
- Channel
- Family
- Action
- Low
- High

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Channel

##### Description

The image channel to operated on (zero-based). Negative values will cause all channels to be operated on.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```

#### Family

##### Description

The family from which to randomly draw new ominoes from.

'0' draws ominoes from all available families.

'1' draws only from the monomino family, which contains only a single, trivial omino.

'2' draws only from the domino family, which contains a single omino.

'3' draws only from the tromino family, which contains two one-sided ominoes.

'4' draws only from the tetromino family, which contains seven one-sided ominoes.

'5' draws only from the pentomino family, which contains eighteen one-sided ominoes.

##### Default

- ```"0"```

##### Supported Options

- ```"0"```
- ```"1"```
- ```"2"```
- ```"3"```
- ```"4"```
- ```"5"```

#### Action

##### Description

Controls how the moving polyomino (if any are present) is manipulated.

The 'none' action causes the moving polyomino to drop down one row, otherwise any number of other actions can be taken
to defer this movement. For consitency with other implementations, the 'none' action should be performed repeatedly
approximately every second. Other actions should be performed in the interim time between the 'none' action.

Note: actions that are not possible are ignored but still defer the 'none' action movement.

##### Default

- ```"none"```

##### Supported Options

- ```"none"```
- ```"rotate-clockwise"```
- ```"rotate-counterclockwise"```
- ```"translate-left"```
- ```"translate-right"```
- ```"translate-down"```
- ```"drop"```

#### Low

##### Description

The voxel value that represents 'inactive' cells. Since cells are either 'active' or 'inactive', the value halfway
between the low and high values is used as the threshold.

##### Default

- ```"0.0"```

##### Examples

- ```"0.0"```
- ```"-1.23"```
- ```"10.0"```

#### High

##### Description

The voxel value that represents 'active' cells. Since cells are either 'active' or 'inactive', the value halfway between
the low and high values is used as the threshold.

##### Default

- ```"1.0"```

##### Examples

- ```"1.5"```
- ```"-0.23"```
- ```"255.0"```


----------------------------------------------------

## PreFilterEnormousCTValues

### Tags

- category: image processing
- category: needs refresh

### Description

This operation runs the data through a per-pixel filter, censoring pixels which are too high to legitimately show up in
a clinical CT. Censored pixels are set to NaN. Data is modified and no copy is made!

### Parameters

No registered options.

----------------------------------------------------

## PresentationImage

### Tags

- category: file export
- category: image processing

### Description

This operation renders an image with any contours in-place and colour mapping using an SFML backend.

### Notes

- By default this operation displays the last available image. This makes it easier to produce a sequence of images by
  inserting this operation into a sequence of operations.

### Parameters

- ScaleFactor
- ImageFileName
- ColourMapRegex
- WindowLow
- WindowHigh

#### ScaleFactor

##### Description

This factor is applied to the image width and height to magnify (larger than 1) or shrink (less than 1) the image. This
factor only affects the output image size. Note that aspect ratio is retained, but rounding for non-integer factors may
lead to small (1-2 pixel) discrepancies.

##### Default

- ```"1.0"```

##### Examples

- ```"0.5"```
- ```"1.0"```
- ```"2.0"```
- ```"5.23"```

#### ImageFileName

##### Description

The file name to use for the image. If blank, a filename will be generated sequentially.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/an_image.png"```
- ```"afile.png"```

#### ColourMapRegex

##### Description

The colour mapping to apply to the image if there is a single channel. The default will match the first available, and
if there is no matching map found, the first available will be selected.

##### Default

- ```".*"```

##### Supported Options

- ```"Viridis"```
- ```"Magma"```
- ```"Plasma"```
- ```"Inferno"```
- ```"Jet"```
- ```"MorelandBlueRed"```
- ```"MorelandBlackBody"```
- ```"MorelandExtendedBlackBody"```
- ```"KRC"```
- ```"ExtendedKRC"```
- ```"Kovesi_LinKRYW_5-100_c64"```
- ```"Kovesi_LinKRYW_0-100_c71"```
- ```"Kovesi_Cyclic_cet-c2"```
- ```"LANLOliveGreentoBlue"```
- ```"YgorIncandescent"```
- ```"LinearRamp"```

#### WindowLow

##### Description

If provided, this parameter will override any existing window and level. All pixels with the intensity value or lower
will be assigned the lowest possible colour according to the colour map. Not providing a valid number will disable
window overrides.

##### Default

- ```""```

##### Examples

- ```""```
- ```"-1.23"```
- ```"0"```
- ```"1E4"```

#### WindowHigh

##### Description

If provided, this parameter will override any existing window and level. All pixels with the intensity value or higher
will be assigned the highest possible colour according to the colour map. Not providing a valid number will disable
window overrides.

##### Default

- ```""```

##### Examples

- ```""```
- ```"1.23"```
- ```"0"```
- ```"10.3E4"```


----------------------------------------------------

## PrintMetadata

### Tags

- category: meta
- category: parameter table

### Description

This operation can be used to print the value corresponding to a key in the global parameter table.

This operation is meant to be used to extract information as part of a pipeline, where stdout can be intercepted.

### Notes

- The output is printed to stdout.

- If the key does not exist, nothing will be emitted.

- This operation will succeed only if there is a key-value present with the specified key.

### Parameters

- Key

#### Key

##### Description

The key selection.

##### Default

- ```"unspecified"```

##### Examples

- ```"ROIName"```
- ```"SliceThickness"```
- ```"xyz"```


----------------------------------------------------

## PromoteMetadata

### Tags

- accepts parameter: contours
- accepts parameter: images
- accepts parameter: line samples
- accepts parameter: point clouds
- accepts parameter: surface meshes
- accepts parameter: tables
- category: metadata
- category: parameter table

### Description

This operation can be used to copy metadata from an object to the global parameter table.

Metadata in the global parameter table is accessible in most operations where metadata can be assigned to objects, so
this operation effectively allows one to copy metadata from one object to another.

### Notes

- Metadata can be copied from any selected object, regardless of the modality or type of object.

- Composite objects can have different metadata for each sub-object. For example, image arrays are composed of multiple
  images, and each image can have it's own metadata (e.g., ImagePosition or SliceNumber). How multiple distinct metadata
  values are handled can be adjusted.

- Selectors for this operation are only considered when you explicitly provide them. By default, this operation will not
  select any objects.

- This operation will succeed only if a metadata key-value is written to the global parameter table. If no objects are
  selected or no metadata is found, the specified key will be removed from the table.

### Parameters

- KeySelection
- NewKey
- DefaultValue
- ValueSeparator
- ROILabelRegex
- ROISelection
- NormalizedROILabelRegex
- ImageSelection
- LineSelection
- MeshSelection
- PointSelection
- TransformSelection
- TableSelection
- RTPlanSelection

#### KeySelection

##### Description

The key to extract from the key-value metadata. The corresponding value will be extracted to the global parameter table.

##### Default

- ```"unspecified"```

##### Examples

- ```"ROIName"```
- ```"SliceThickness"```
- ```"xyz"```

#### NewKey

##### Description

The key to assign the metadata value when it is stored in the global parameter table.

An existing metadata key-value with the given key will be overwritten if the promotion is successful.

Note that any existing key will initially be removed, and only replaced if the promotion is successful.

##### Default

- ```"unspecified"```

##### Examples

- ```"extracted_ROIName"```
- ```"xyz_from_contours"```

#### DefaultValue

##### Description

A value that will be inserted if no items are selected or no metadata is available. Omitting this parameter will disable
promotion when no metadata are available.

Note that insertion of a default value will still result in the operation signalling a failure to promote.

##### Default

- ```"N/A"```

##### Examples

- ```"N/A"```
- ```"(missing)"```
- ```"NIL"```

#### ValueSeparator

##### Description

If multiple distinct metadata values are present, they will be combined together with this separator. Providing an empty
separator will disable concatenation and only one value (the last sorted value) will be promoted.

##### Default

- ```"\"```

##### Examples

- ```"\"```
- ```""```
- ```","```
- ```"	"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### LineSelection

##### Description

Select one or more line samples. Selection specifiers can be of three types: positional, metadata-based key@value regex,
and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth line sample (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last line sample.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the line sample composed of the greatest and fewest number of samples. Only one or zero line sample will be
selected; if there are ties, there is no guarantee which line sample will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple line sample based on a threshold count, i.e., where all selected line sample have
more than or fewer than $N$ samples. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all line sample that do not have the greatest number of samples, not the least-numerous line sample (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### PointSelection

##### Description

Select one or more point clouds. Note that point clouds can hold a variety of data with varying attributes, but each
point cloud is meant to represent a single logically cohesive collection of points. Be aware that it is possible to mix
logically unrelated points together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TransformSelection

##### Description

Select one or more transform objects (aka 'warp' objects). Selection specifiers can be of three types: positional,
metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth transformation (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last transformation.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the transformation composed of the greatest and fewest number of sub-objects. Only one or zero transformation
will be selected; if there are ties, there is no guarantee which transformation will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple transformation based on a threshold count, i.e., where all selected transformation
have more than or fewer than $N$ sub-objects. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all transformation that do not have the greatest number of sub-objects, not the least-numerous
transformation (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### RTPlanSelection

##### Description

Select one or more treatment plans. Note that a single treatment plan may be composed of multiple beams; if delivered
sequentially, they should collectively represent a single logically cohesive plan. Selection specifiers can be of three
types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth treatment plan (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last treatment plan.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the treatment plan composed of the greatest and fewest number of control points. Only one or zero treatment plan
will be selected; if there are ties, there is no guarantee which treatment plan will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple treatment plan based on a threshold count, i.e., where all selected treatment plan
have more than or fewer than $N$ control points. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all treatment plan that do not have the greatest number of control points, not the least-numerous
treatment plan (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## PruneEmptyImageDoseArrays

### Tags

- category: image processing
- category: needs refresh
- category: radiation dose

### Description

This operation deletes Image_Arrays that do not contain any images.

### Parameters

No registered options.

----------------------------------------------------

## PurgeContours

### Tags

- accepts parameter: contours
- category: contour processing

### Description

This routine purges (deletes) individual contours if they satisfy various criteria.

### Notes

- Each criteria is evaluated separately for each individual contour. Satisfaction of any of the individual criteria will
  result in the contour being purged.

- This operation considers individually. It could be extended to operate on whole ROIs (i.e., contour_collections), or
  to perform a separate evaluation within each contour plane. The individual contour approach was taken since filtering
  out small contour 'island' artifacts is the primary use-case.

### Parameters

- ROILabelRegex
- NormalizedROILabelRegex
- InvertLogic
- InvertSelection
- AreaAbove
- AreaBelow
- PerimeterAbove
- PerimeterBelow
- VertexCountAbove
- VertexCountBelow

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### InvertLogic

##### Description

This option controls whether purged contours *should* or *should not* satisfy the specified logical test criteria. If
false (the default), this operation is equivalent to a 'purge if and only if' operation. If true, this operation is
equivalent to a 'retain if and only if' operation. Note that this parameter is independent of the ROI selection
criteria.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```

#### InvertSelection

##### Description

This option controls whether purged contours *should* or *should not* satisfy the specified ROI selection criteria. If
false (the default), this operation only considers contours that match the ROILabelRegex or NormalizedROILabelRegex; all
other contours are ignored (and thus will not be purged, i.e., a denylist). If true, this operation only considers the
*complement* of contours that match the ROILabelRegex or NormalizedROILabelRegex, which can be used to purge all
contours except a handful (i.e., an allowlist).

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```

#### AreaAbove

##### Description

If this option is provided with a valid positive number, contour(s) with an area greater than the specified value are
purged. Note that the DICOM coordinate space is used. (Supplying the default, inf, will effectively disable this
option.)

##### Default

- ```"inf"```

##### Examples

- ```"inf"```
- ```"100.0"```
- ```"1000"```
- ```"10.23E8"```

#### AreaBelow

##### Description

If this option is provided with a valid positive number, contour(s) with an area less than the specified value are
purged. Note that the DICOM coordinate space is used. (Supplying the default, -inf, will effectively disable this
option.)

##### Default

- ```"-inf"```

##### Examples

- ```"-inf"```
- ```"100.0"```
- ```"1000"```
- ```"10.23E8"```

#### PerimeterAbove

##### Description

If this option is provided with a valid positive number, contour(s) with a perimeter greater than the specified value
are purged. Note that the DICOM coordinate space is used. (Supplying the default, inf, will effectively disable this
option.)

##### Default

- ```"inf"```

##### Examples

- ```"inf"```
- ```"10.0"```
- ```"100"```
- ```"10.23E4"```

#### PerimeterBelow

##### Description

If this option is provided with a valid positive number, contour(s) with a perimeter less than the specified value are
purged. Note that the DICOM coordinate space is used. (Supplying the default, -inf, will effectively disable this
option.)

##### Default

- ```"-inf"```

##### Examples

- ```"-inf"```
- ```"10.0"```
- ```"100"```
- ```"10.23E4"```

#### VertexCountAbove

##### Description

If this option is provided with a valid positive number, contour(s) with a vertex count greater than the specified value
are purged. Note that the DICOM coordinate space is used. (Supplying the default, inf, will effectively disable this
option.)

##### Default

- ```"inf"```

##### Examples

- ```"inf"```
- ```"10.0"```
- ```"100"```
- ```"10.23E4"```

#### VertexCountBelow

##### Description

If this option is provided with a valid positive number, contour(s) with a vertex count less than the specified value
are purged. Note that the DICOM coordinate space is used. (Supplying the default, -inf, will effectively disable this
option.)

##### Default

- ```"-inf"```

##### Examples

- ```"-inf"```
- ```"10.0"```
- ```"100"```
- ```"10.23E4"```


----------------------------------------------------

## QuantizePixels

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: contour processing

### Description

This operation quantizes pixel (voxel) values confined to one or more ROIs.

### Notes

- This routine is often helpful for lossy compression.

### Parameters

- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Inclusivity
- ContourOverlap
- Method
- Channel

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. The option 'honour_opposite_orientations' makes overlapping contours with opposite
orientation cancel. Otherwise, orientation is ignored. The latter is useful for Boolean structures where contour
orientation is significant for interior contours (holes). The option 'overlapping_contours_cancel' ignores orientation
and cancels all contour overlap.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Method

##### Description

The method to use for quantization. Currently only 'round' is available, which rounds to the nearest integer.

##### Default

- ```"round"```

##### Supported Options

- ```"round"```

#### Channel

##### Description

The image channel to use. Zero-based.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"2"```


----------------------------------------------------

## QueryUserInteractively

### Tags

- category: interactive
- category: meta
- category: parameter table

### Description

This operation queries the user interactively, and then injects parameters into the global parameter table.

### Parameters

- Queries

#### Queries

##### Description

A list of queries to pose to the user, where each function represents a single query. There are currently three query
types: 'integer', 'real', and 'string'. The only difference being how the user input is validated. All three functions
have the same signature: the variable name (which is used to store the user input), a query/instruction string that is
provided to the user, and a default/example value. For example, 'integer(x, "Input the day of the month.", 0)' will
query the user for an integer with the instructions 'Input the day of the month.' and the result will be stored in
variable named 'x'. Note that multiple queries can be separated by a semicolon, characters can be escaped inside
quotations using a backslash, and outer quotation marks are stripped away. Note that the query interface may also remove
or transform problematic characters.

##### Default

- ```""```

##### Examples

- ```"integer(var1, 'Please provide an integer', 123); real(var2, 'Please provide a float', -1.23); string(var3, 'Please provide a string', 'default text')"```


----------------------------------------------------

## RPCReceive

### Tags

- category: RPC
- category: meta
- category: networking

### Description

This operation launches a server that accepts remote procedure calls (RPC) for distributed computing.

### Notes

- RPC functionality is currently alpha-quality code, and much is expected to change.

### Parameters

- Port

#### Port

##### Description

The port number to listen on.

##### Default

- ```"9090"```

##### Examples

- ```"13"```
- ```"8080"```
- ```"9090"```
- ```"16378"```


----------------------------------------------------

## RPCSend

### Tags

- category: RPC
- category: meta
- category: networking

### Description

This operation sends a remote procedure call (RPC) to a corresponding client for distributed computing.

### Notes

- RPC functionality is currently alpha-quality code, and much is expected to change.

### Parameters

- Port
- Host

#### Port

##### Description

The port number to connect to.

##### Default

- ```"9090"```

##### Examples

- ```"13"```
- ```"8080"```
- ```"9090"```
- ```"16378"```

#### Host

##### Description

The remote host name or IP address to connect to.

##### Default

- ```"localhost"```

##### Examples

- ```"localhost"```
- ```"127.0.0.1"```


----------------------------------------------------

## RankPixels

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation ranks pixels throughout an image array.

### Notes

- This routine operates on all images in an image array, so pixel value ranks are valid throughout the array. However,
  the window and level of each window is separately determined. You will need to set a uniform window and level manually
  if desired.

- This routine operates on all images in an image array. If images need to be processed individually, arrays will have
  to be exploded prior to calling this routine. Note that if this functionality is required, it can be implemented as an
  operation option easily. Likewise, if multiple image arrays must be considered simultaneously, they will need to be
  combined before invoking this operation.

### Parameters

- ImageSelection
- Method
- LowerThreshold
- UpperThreshold

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Method

##### Description

Pixels participating in the ranking process will have their pixel values replaced. They can be replaced with either a
rank or the corresponding percentile. Ranks start at zero and percentiles are centre-weighted (i.e., rank-averaged).

##### Default

- ```"Percentile"```

##### Supported Options

- ```"Rank"```
- ```"Percentile"```

#### LowerThreshold

##### Description

The (inclusive) threshold above which pixel values must be in order to participate in the rank.

##### Default

- ```"-inf"```

##### Examples

- ```"-inf"```
- ```"0.0"```
- ```"-900"```

#### UpperThreshold

##### Description

The (inclusive) threshold below which pixel values must be in order to participate in the rank.

##### Default

- ```"inf"```

##### Examples

- ```"inf"```
- ```"0.0"```
- ```"1500"```


----------------------------------------------------

## ReduceNeighbourhood

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: contour processing
- category: image processing

### Description

This routine walks the voxels of a 3D rectilinear image collection, reducing the distribution of voxels within the local
volumetric neighbourhood to a scalar value, and updating the voxel value with this scalar. This routine can be used to
implement mean and median filters (amongst others) that operate over a variety of 3D neighbourhoods. Besides purely
statistical reductions, logical reductions can be applied.

### Notes

- The provided image collection must be rectilinear.

- This operation can be used to compute core 3D morphology operations (erosion and dilation) as well as composite
  operations like opening (i.e., erosion followed by dilation), closing (i.e., dilation followed by erosion), 'gradient'
  (i.e., the difference between dilation and erosion, which produces an outline), and various other combinations of core
  and composite operations.

### Parameters

- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Channel
- Neighbourhood
- Reduction
- MaxDistance

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Channel

##### Description

The channel to operated on (zero-based). Negative values will cause all channels to be operated on.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```

#### Neighbourhood

##### Description

Controls how the neighbourhood surrounding a voxel is defined.

Variable-size neighbourhoods 'spherical' and 'cubic' are defined. An appropriate isotropic extent must be provided for
these neighbourhoods. (See below; extents must be provided in DICOM units, i.e., mm.)

Fixed-size neighbourhoods specify a fixed number of adjacent voxels.

Fixed rectagular neighbourhoods are specified like 'RxCxI' for row, column, and image slice extents (as integer number
of rows, columns, and slices).

Fixed spherical neighbourhoods are specified like 'Wsphere' where W is the width (i.e., the number of voxels wide). In
morphological terminology, the neighbourhood is referred to as a 'structuring element.' A similar concept is the
convolutional 'kernel.'

##### Default

- ```"spherical"```

##### Supported Options

- ```"spherical"```
- ```"cubic"```
- ```"3x3x3"```
- ```"5x5x5"```
- ```"3sphere"```
- ```"5sphere"```
- ```"7sphere"```
- ```"9sphere"```
- ```"11sphere"```
- ```"13sphere"```
- ```"15sphere"```

#### Reduction

##### Description

Controls how the distribution of voxel values from neighbouring voxels is reduced.

Statistical distribution reducers 'min', 'mean', 'median', and 'max' are defined. 'min' is also known as the 'erosion'
operation. Likewise, 'max' is also known as the 'dilation' operation. Note that the morphological 'opening' operation
can be accomplished by sequentially performing an erosion and then a dilation using the same neighbourhood. The
'standardize' reduction method can be used for adaptive rescaling by subtracting the local neighbourhood mean and
dividing the local neighbourhood standard deviation.

The 'geometric_mean' implements the Nth root of the product of N intensities within the neighbourhood. It is a smoothing
filter often used to remove Gaussian noise. Note that all pixels should be non-negative, otherwise the geometric mean is
not well-defined. Otherwise NaN is returned.

The 'standardize' reduction method is a way to (locally) transform variables on different scales so they can more easily
be compared. Note that standardization can result in undefined voxel values when the local neighbourhood is perfectly
uniform. Also, since only the local neighbourhood is considered, voxels will in general have *neither* zero mean *nor* a
unit standard deviation (growing the neighbourhood extremely large *will* accomplish this, but the calculation will be
inefficient).

The 'percentile01' reduction method evaluates which percentile the central voxel occupies within the local
neighbourhood. It is reported scaled to $[0,1]$. 'percentile01' can be used to implement non-parametric adaptive scaling
since only the local neighbourhood is examined. (Duplicate values assume the percentile of the middle of the range.) In
contrast to 'standardize', the 'percentile01' reduction should remain valid anywhere the local neighbourhood has a
non-zero number of finite voxels.

Logical reducers 'is_min' and 'is_max' are also available -- is_min (is_max) replace the voxel value with 1.0 if it was
the min (max) in the neighbourhood and 0.0 otherwise. Logical reducers 'is_min_nan' and 'is_max_nan' are variants that
replace the voxel with a NaN instead of 1.0 and otherwise do not overwrite the original voxel value.

##### Default

- ```"median"```

##### Supported Options

- ```"min"```
- ```"erode"```
- ```"mean"```
- ```"median"```
- ```"max"```
- ```"dilate"```
- ```"geometric_mean"```
- ```"standardize"```
- ```"percentile01"```
- ```"is_min"```
- ```"is_max"```
- ```"is_min_nan"```
- ```"is_max_nan"```

#### MaxDistance

##### Description

The maximum distance (inclusive, in DICOM units: mm) within which neighbouring voxels will be evaluated for
variable-size neighbourhoods. Note that this parameter will be ignored if a fixed-size neighbourhood has been specified.

For spherical neighbourhoods, this distance refers to the radius. For cubic neighbourhoods, this distance refers to 'box
radius' or the distance from the cube centre to the nearest point on each bounding face. Voxels separated by more than
this distance will not be evaluated together.

##### Default

- ```"2.0"```

##### Examples

- ```"0.5"```
- ```"2.0"```
- ```"15.0"```


----------------------------------------------------

## RemeshSurfaceMeshes

### Tags

- accepts parameter: surface meshes
- category: mesh processing

### Description

This operation re-meshes existing surface meshes according to the specified criteria, replacing the original meshes with
remeshed copies.

### Notes

- Selected surface meshes should represent polyhedra.

### Parameters

- MeshSelection
- Iterations
- TargetEdgeLength

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Iterations

##### Description

The number of remeshing iterations to perform.

##### Default

- ```"5"```

##### Examples

- ```"1"```
- ```"3"```
- ```"5"```
- ```"10"```

#### TargetEdgeLength

##### Description

The desired length of all edges in the remeshed mesh in DICOM units (mm).

##### Default

- ```"1.5"```

##### Examples

- ```"0.2"```
- ```"0.75"```
- ```"1.0"```
- ```"1.5"```
- ```"2.015"```


----------------------------------------------------

## Repeat

### Tags

- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that repeatedly and sequentially invokes all child operations the given
number of times.

### Notes

- If this operation has no children, this operation will evaluate to a no-op.

- Each repeat is performed sequentially, and all side-effects are carried forward for each iteration. In particular, all
  selectors in child operations are evaluated lazily, at the moment when the child operation is invoked.

- This operation will most often be used to repeat operations that compose naturally, such as repeatedly applying a
  small Gaussian filter to simulate a single Gaussian filter with a large kernel, iteratively refining a calculation,
  loading multiple copies of the same file, or attempting a given analysis while waiting for data from a remote server.

### Parameters

- N

#### N

##### Description

The number of times to repeat the children operations.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"5"```
- ```"10"```
- ```"1000"```


----------------------------------------------------

## ReportROIData

### Tags

- accepts parameter: contours
- accepts parameter: tables
- category: contour processing
- category: table processing

### Description

This operation prints ROI contour information into a table.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- TableSelection
- TableLabel

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TableLabel

##### Description

A label to attach to table if and only if a new table is created.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"xyz"```
- ```"sheet A"```


----------------------------------------------------

## ResampleImages

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: contour processing
- category: image processing

### Description

This operation combines two image arrays. The voxel values from one array are resampled onto the geometry of the other.
This routine is used to ensure two image arrays have consistent spatial characteristics (e.g., number of images, rows,
columns, spatial extent, orientations, etc.), which can simplify and accelerate other operations.

### Notes

- No images are overwritten. A resampled image array is created.

- The resampling con be confined using a region of interest (via a contour collection) or using intensity thresholds.
  Note that both of these are applied to the *reference* image array (i.e., the image array that provides the reference
  geometry).

- The image array providing voxel values must be rectilinear. (This is a requirement specific to this implementation, a
  less restrictive implementation could overcome the issue.)

- This operation will make use of trlinear interpolation if corresponding voxels do not exactly overlap.

### Parameters

- ImageSelection
- ReferenceImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Channel
- Lower
- Upper

#### ImageSelection

##### Description

The image array from which voxel values will be borrowed. These voxel values are what is being resampled. Select one or
more image arrays. Note that image arrays can hold anything, but will typically represent a single contiguous 3D volume
(i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically unrelated images
together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"first"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ReferenceImageSelection

##### Description

The image array from which geometry will be borrowed. This image array provides the reference geometry. Select one or
more image arrays. Note that image arrays can hold anything, but will typically represent a single contiguous 3D volume
(i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically unrelated images
together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Channel

##### Description

The channel to compare (zero-based). Setting to -1 will compare each channel separately. Note that both image arrays
must share this specifier.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```

#### Lower

##### Description

Voxel intensity lower threshold. Only voxels with values above this threshold (inclusive) will be altered.

##### Default

- ```"-inf"```

##### Examples

- ```"-inf"```
- ```"0.0"```
- ```"200"```

#### Upper

##### Description

Voxel intensity upper threshold. Only voxels with values below this threshold (inclusive) will be altered.

##### Default

- ```"inf"```

##### Examples

- ```"inf"```
- ```"1.23"```
- ```"1000"```


----------------------------------------------------

## RigidWarpImages

### Tags

- accepts parameter: images
- category: image processing
- category: spatial transform processing

### Description

This operation applies a rigid transform object to the specified image arrays, warping (i.e., rotating, scaling, and
translating) them spatially.

### Aliases

- WarpImagesRigid

### Notes

- A transform object must be selected; this operation cannot create transforms. Transforms can be generated via
  registration or by parsing user-provided functions.

- Images are transformed in-place. Metadata may become invalid by this operation.

- This operation can only handle individual transforms. If multiple, sequential transforms are required, this operation
  must be invoked multiple time. This will guarantee the ordering of the transforms.

- This operation supports only the rigid subset of affine transformations. Local transformations and those requiring
  shear require special handling and voxel resampling that is not yet implemented.

- Transformations are not (generally) restricted to the coordinate frame of reference that they were derived from. This
  permits a single transformation to be applicable to point clouds, surface meshes, images, and contours.

### Parameters

- ImageSelection
- TransformSelection

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TransformSelection

##### Description

Select one or more transform objects (aka 'warp' objects). Selection specifiers can be of three types: positional,
metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth transformation (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last transformation.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the transformation composed of the greatest and fewest number of sub-objects. Only one or zero transformation
will be selected; if there are ties, there is no guarantee which transformation will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple transformation based on a threshold count, i.e., where all selected transformation
have more than or fewer than $N$ sub-objects. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all transformation that do not have the greatest number of sub-objects, not the least-numerous
transformation (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```


----------------------------------------------------

## SDL_Viewer

### Tags

- category: interactive

### Description

Launch an interactive viewer based on SDL.

### Parameters

- LexiconCustomizer
- Contouring
- Guide

#### LexiconCustomizer

##### Description

Controls whether the lexicon customizer interface is opened by default.

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```

#### Contouring

##### Description

Controls whether the contouring interface is opened by default.

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```

#### Guide

##### Description

A guide to display to the user. Usually used to walk the user through one or more actions.

##### Default

- ```""```

##### Examples

- ```"Step 1---Step 2---Step 3"```


----------------------------------------------------

## SFML_Viewer

### Tags

- category: interactive

### Description

Launch an interactive viewer based on SFML. Using this viewer, it is possible to contour ROIs, generate plots of pixel
intensity along profiles or through time, inspect and compare metadata, and various other things.

### Parameters

- SingleScreenshot
- SingleScreenshotFileName
- FPSLimit

#### SingleScreenshot

##### Description

If 'true', a single screenshot is taken and then the viewer is exited. This option works best for quick visual
inspections, and should not be used for later processing or analysis.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```

#### SingleScreenshotFileName

##### Description

Iff invoking the 'SingleScreenshot' argument, use this string as the screenshot filename. If blank, a filename will be
generated sequentially.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/a_screenshot.png"```
- ```"afile.png"```

#### FPSLimit

##### Description

The upper limit on the frame rate, in seconds as an unsigned integer. Note that this value may be treated as a
suggestion.

##### Default

- ```"60"```

##### Examples

- ```"60"```
- ```"30"```
- ```"10"```
- ```"1"```


----------------------------------------------------

## ScalePixels

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This operation scales pixel (voxel) values confined to one or more ROIs.

### Notes

- This routine could be used to derive, for example, per-fraction dose from a total dose image array.

### Parameters

- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Inclusivity
- ContourOverlap
- ScaleFactor
- Channel

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. The option 'honour_opposite_orientations' makes overlapping contours with opposite
orientation cancel. Otherwise, orientation is ignored. The latter is useful for Boolean structures where contour
orientation is significant for interior contours (holes). The option 'overlapping_contours_cancel' ignores orientation
and cancels all contour overlap.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### ScaleFactor

##### Description

The numeric factor to multiply all pixel (voxel) values with.

##### Default

- ```"1.0"```

##### Examples

- ```"-1.0"```
- ```"0.0"```
- ```"1.23E-5"```

#### Channel

##### Description

The image channel to use. Zero-based.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"2"```


----------------------------------------------------

## SeamContours

### Tags

- category: contour processing
- category: needs refresh

### Description

This routine converts contours that represent 'outer' and 'inner' via contour orientation into contours that are
uniformly outer but have a zero-area seam connecting the inner and outer portions.

### Notes

- This routine currently operates on all available ROIs.

- This routine operates on one contour_collection at a time. It will combine contours that are in the same
  contour_collection and overlap, even if they have different ROINames. Consider making a complementary routine that
  partitions contours into ROIs based on ROIName (or other metadata) if more rigorous enforcement is needed.

- This routine actually computes the XOR Boolean of contours that overlap. So if contours partially overlap, this
  routine will treat the overlapping parts as if they are holes, and the non-overlapping parts as if they represent the
  ROI. This behaviour may be surprising in some cases.

- This routine will also treat overlapping contours with like orientation as if the smaller contour were a hole of the
  larger contour.

- This routine will ignore contour orientation if there is only a single contour. More specifically, for a given ROI
  label, planes with a single contour will be unaltered.

- Only the common metadata between outer and inner contours is propagated to the seamed contours.

- This routine will NOT combine disconnected contours with a seam. Disconnected contours will remain disconnected.

### Parameters

No registered options.

----------------------------------------------------

## SelectDirectory

### Tags

- category: interactive
- category: meta
- category: parameter table

### Description

Allow the user to interactively select/specify a directory name, and then insert it into the global parameter table.

### Aliases

- SpecifyDirectory
- SelectFolder
- SpecifyFolder

### Notes

- Invocation of this operation will first purge any existing directory names with the provided key. This is done to
  avoid risk of any existing directory names being propagated through if the selection dialog fails or the user cancels
  the dialog.

- The specified directory name is not validated. However, providing an empty name will cause a false to be returned.

### Parameters

- Key

#### Key

##### Description

The key used to store the selected/specified directory name in the global parameter table.

##### Default

- ```"selected_dirname"```

##### Examples

- ```"selected_dirname"```
- ```"out_dirname"```
- ```"value"```


----------------------------------------------------

## SelectFilename

### Tags

- category: interactive
- category: meta
- category: parameter table

### Description

Allow the user to interactively select/specify a filename, and then insert it into the global parameter table. Note that
either an existing file can be selected, or a new filename can be specified.

A file with the specified name does not need to exist, and no new file is created by this operation.

If a file *does* exist with the specified filename, it will not be modified by this operation.

However, subsequent operations may use the filename to create, overwrite, or append to such a file.

### Aliases

- SpecifyFilename

### Notes

- Invocation of this operation will first purge any existing filename with the provided key. This is done to avoid risk
  of any existing filenames being propagated through if the file selection fails or the user cancels the dialog.

- As with any non-atomic filename selection operation where the file is not reserved, there is a possible race condition
  between filename selection and file use. This is broadly known as the 'TOCTOU' or time-of-check, time-of-use race
  condition. Beware!

- The specified filename is not validated. However, providing an empty filename will cause a false to be returned.

### Parameters

- Key
- Extension

#### Key

##### Description

The key used to store the selected/specified filename in the global parameter table.

##### Default

- ```"selected_filename"```

##### Examples

- ```"selected_filename"```
- ```"out_filename"```
- ```"value"```

#### Extension

##### Description

An extension to impose on the filename. Note that this option will add the extension or override any extension provided
by the user. To permit any extension and disable overriding the extension, leave this parameter empty.

##### Default

- ```""```

##### Examples

- ```""```
- ```".dcm"```
- ```".txt"```
- ```".tar.gz"```
- ```".CSV"```


----------------------------------------------------

## SelectSlicesIntersectingROI

### Tags

- accepts parameter: contours
- category: contour processing
- category: needs refresh

### Description

This operation applies a whitelist to the most-recently loaded images. Images must 'slice' through one of the described
ROIs in order to make the whitelist. This operation is typically used to reduce long computations by trimming the field
of view of extraneous image slices.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## SelectionIsPresent

### Tags

- accepts parameter: contours
- accepts parameter: images
- accepts parameter: line samples
- accepts parameter: point clouds
- accepts parameter: surface meshes
- accepts parameter: tables
- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that evaluates whether the provided selection criteria selects one or
more objects.

For example, if you need to know whether there is an image array with a given metadata key-value pair, this operation
will return a logical 'true' if and only if the image array can be located. This operation allows for branching logic,
where operations will be taken only when data is (or is not) available.

### Notes

- Multiple selection criteria can be provided. If multiple criteria are specified, this operation returns the logical
  'AND' for each selection criteria (e.g., has images AND has contours). If no selection criteria are provided, this
  operation fails therefore evaluates logically to false.

- This operation is read-only and produces no side-effects. It does not alter the selection.

- Selectors for this operation are only considered when you explicitly provide them. The default values are not used by
  this operation.

- Note that many operations will tolerate empty selections, degrading to a no-op. This operation is useful as a
  side-effect-free option for operations that do not tolerate empty selections.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- ImageSelection
- LineSelection
- MeshSelection
- PointSelection
- TableSelection

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### LineSelection

##### Description

Select one or more line samples. Selection specifiers can be of three types: positional, metadata-based key@value regex,
and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth line sample (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last line sample.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the line sample composed of the greatest and fewest number of samples. Only one or zero line sample will be
selected; if there are ties, there is no guarantee which line sample will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple line sample based on a threshold count, i.e., where all selected line sample have
more than or fewer than $N$ samples. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all line sample that do not have the greatest number of samples, not the least-numerous line sample (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### PointSelection

##### Description

Select one or more point clouds. Note that point clouds can hold a variety of data with varying attributes, but each
point cloud is meant to represent a single logically cohesive collection of points. Be aware that it is possible to mix
logically unrelated points together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## SimplifyContours

### Tags

- accepts parameter: contours
- category: contour processing

### Description

This operation performs simplification on contours by removing or moving vertices. This operation is mostly used to
reduce the computational complexity of other operations.

### Notes

- Contours are currently processed individually, not as a volume.

- Simplification is generally performed most eagerly on regions with relatively low curvature. Regions of high curvature
  are generally simplified only as necessary.

### Parameters

- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- FractionalAreaTolerance
- SimplificationMethod

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### FractionalAreaTolerance

##### Description

The fraction of area each contour will tolerate during simplified. This is a measure of how much the contour area can
change due to simplification.

##### Default

- ```"0.01"```

##### Examples

- ```"0.001"```
- ```"0.01"```
- ```"0.02"```
- ```"0.05"```
- ```"0.10"```

#### SimplificationMethod

##### Description

The specific algorithm used to perform contour simplification. 'Vertex removal' is a simple algorithm that removes
vertices one-by-one without replacement. It iteratively ranks vertices and removes the single vertex that has the least
impact on contour area. It is best suited to removing redundant vertices or whenever new vertices should not be added.
'Vertex collapse' combines two adjacent vertices into a single vertex at their midpoint. It iteratively ranks vertex
pairs and removes the single vertex that has the least total impact on contour area. Note that small sharp features that
alternate inward and outward will have a small total area cost, so will be pruned early. Thus this technique acts as a
low-pass filter and will defer simplification of high-curvature regions until necessary. It is more economical compared
to vertex removal in that it will usually simplify contours more for a given tolerance (or, equivalently, can retain
contour fidelity better than vertex removal for the same number of vertices). However, vertex collapse performs an
averaging that may result in numerical imprecision.

##### Default

- ```"vert-collapse"```

##### Supported Options

- ```"vertex-collapse"```
- ```"vertex-removal"```


----------------------------------------------------

## SimplifySurfaceMeshes

### Tags

- accepts parameter: surface meshes
- category: mesh processing

### Description

This operation performs mesh simplification on existing surface meshes according to the specified criteria, replacing
the original meshes with simplified meshes.

### Notes

- Selected surface meshes should represent polyhedra.

### Parameters

- MeshSelection
- Method
- EdgeCountLimit
- ToleranceDistance
- MinAlignAngle

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Method

##### Description

Controls which simplification algorithm is used. Currently supported are 'flat' and 'edge-collapse'.

'flat' removes vertices when the immediate surrounding patch is uniformly flat within a given tolerance distance. Border
and non-manifold vertices are not removed, maintaining surface topology. The 'flat' algorithm works best on redundant,
flat meshes, like those produced by marching cubes. Choosing a small tolerance distance should result in a nearly
lossless simplification, but will only be applicable for meshes with redundant flat sections.

'edge-collapse' builds a priority queue of edges that can be collapsed (converting two vertices into one) one at a time
with minimal impact on the surface. Collapse stops when a given edge count limit is reached. 'edge-collapse' is a
general-purpose simplification algorithm that works well on a variety of meshes.

##### Default

- ```"edge-collapse"```

##### Supported Options

- ```"flat"```
- ```"edge-collapse"```

#### EdgeCountLimit

##### Description

Needed for 'edge-collapse' algorithm. The maximum number of edges simplified meshes should contain.

##### Default

- ```"250000"```

##### Examples

- ```"20000"```
- ```"100000"```
- ```"500000"```
- ```"5000000"```

#### ToleranceDistance

##### Description

Needed for 'flat' algorithm. The maximum allowed surface deviation (in DICOM units; mm) above which vertices will NOT be
simplified.

Note that this number is not the same as the maximum surface deviation after simplification, since every nearby vertex
can in principle perturb the surface up to the tolerance distance. In most practical situations, the tolerance distance
is representative of the surface deviation after simplification.

Setting this number to a value much smaller than the smallest feature should cause effectively lossless simplification
of exactly-flat patches.

##### Default

- ```"0.001"```

##### Examples

- ```"0.001"```
- ```"1E-4"```
- ```"0.5"```
- ```"1.5"```

#### MinAlignAngle

##### Description

Needed for 'flat' algorithm. The minimum angle (in rads) between a candidate surface and the original surface patch's
area-weighted average normal in order for the candidate surface to be accepted.

The range is from zero to pi with zero being perfect alignment and pi (180 degrees) accepting any surface, even if it
faces away from the original.

Note that being too permissive can result in the surface folding back on itself, resulting in (potentially) non-manifold
pinches. An angle between zero and pi/2 is recommended.

##### Default

- ```"1.045"```

##### Examples

- ```"0.01"```
- ```"0.1"```
- ```"0.5"```
- ```"1.0"```
- ```"1.5"```
- ```"3.14159"```


----------------------------------------------------

## SimulateRadiograph

### Tags

- accepts parameter: images
- category: image processing
- category: simulation

### Description

This routine uses ray marching and volumetric sampling to simulate radiographs using a CT image array. Voxels are
assumed to have intensities in HU. A simplisitic conversion from CT number (in HU) to relative electron density (see
note below) is performed for marched rays.

### Notes

- Images must be regular.

- This operation currently takes a simplistic approach and should only be used for purposes where the simulated
  radiograph contrast can be tuned and validated (e.g., in a relative way).

- This operation assumes mass density (in g/cm^3^) and relative electron density (dimensionless; relative to electron
  density of water, which is $3.343E23$ cm^3^) are numerically equivalent. This assumption appears to be reasonable for
  bulk human tissue (arXiv:1508.00226v1).

### Parameters

- ImageSelection
- Filename
- SourcePosition
- AttenuationScale
- ImageModel
- Rows
- Columns

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

The filename (or full path) to which the simulated image will be saved to. The format is FITS. Leaving empty will result
in a unique name being generated.

##### Default

- ```""```

##### Examples

- ```""```
- ```"./img.fits"```
- ```"sim_radiograph.fits"```
- ```"/tmp/out.fits"```

#### SourcePosition

##### Description

This parameter controls where the virtual point source is. Both absolute and relative positioning are available. A
source located at point (1.0, -2.3, 4.5) in the DICOM coordinate system of a given image can be specified as
'absolute(1.0, -2.3, 4.5)'. A source located relative to the image centre by offset (10.0, -23.4, 45.6) in the DICOM
coordinate system of a given image can be specified as 'relative(10.0, -23.4, 45.6)'. Relative offsets must be specified
relative to the image centre. Note that DICOM units (i.e., mm) are used for all coordinates.

##### Default

- ```"relative(0.0, 1000.0, 20.0)"```

##### Examples

- ```"relative(0.0, 1610.0, 20.0)"```
- ```"absolute(-123.0, 123.0, 1.23)"```

#### AttenuationScale

##### Description

This parameter globally scales all attenuation factors derived via ray marching. Adjusting this parameter will alter the
radiograph image contrast the exponential attenuation model; numbers within (0:1) will result in less attenuation,
whereas numbers within (1:inf) will result in more attenuation. Thin or low-mass subjects might require artifically
increased attenuation, whereas thick or high-mass subjects might require artifically decreased attenuation. Setting this
number to 1 will result in no scaling. This parameter has units 1/length, and the magnitude should *roughly* correspond
with the inverse of about $3\times$ the length transited by a typical ray (in mm).

##### Default

- ```"0.001"```

##### Examples

- ```"1.0E-4"```
- ```"0.001"```
- ```"0.01"```
- ```"0.1"```
- ```"1.0"```
- ```"10.0"```
- ```"1E2"```

#### ImageModel

##### Description

This parameter adjusts how the final image is constructed. As rays transit a voxel, the approximate transit distance is
multiplied with the voxel's attenuation coefficient (i.e., $\mu \cdot dL$) to give the ray's attenuation. The sum of all
per-voxel attenuations constitutes the total attenuation. There are many ways this information can be converted into an
image. First, the 'attenuation-length' model directly outputs the total attenuation for each ray. The simulated image's
pixels will contain the total attenuation for one ray. It will almost always provide an image since the attenutation is
not performed. This can be thought of as a log transform of a standard radiograph. Second, the 'exponential' model
performs the attenuation assuming the radiation beam is monoenergetic, narrow, and has the same energy spectrum as the
original imaging device. This model produces a typical radiograph, where each image pixel contains $1 - \exp{-\sum \mu
\cdot dL}$. Note that the values will all $\in [0:1]$ (i.e., Hounsfield units are *not* used). The overall contrast can
be adjusted using the AttenuationScale parameter, however it is easiest to assess a reasonable tuning factor by
inspecting the image produced by the 'attenutation-length' model.

##### Default

- ```"attenuation-length"```

##### Supported Options

- ```"attenuation-length"```
- ```"exponential"```

#### Rows

##### Description

The number of rows that the simulated radiograph will contain. Note that the field of view is determined separately from
the number of rows and columns, so increasing the row count will only result in increased spatial resolution.

##### Default

- ```"512"```

##### Examples

- ```"100"```
- ```"500"```
- ```"2000"```

#### Columns

##### Description

The number of columns that the simulated radiograph will contain. Note that the field of view is determined separately
from the number of rows and columns, so increasing the column count will only result in increased spatial resolution.

##### Default

- ```"512"```

##### Examples

- ```"100"```
- ```"500"```
- ```"2000"```


----------------------------------------------------

## Sleep

### Tags

- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that times how long it takes to execute the child operations.

### Aliases

- Delay
- Wait

### Notes

- Child operations are performed in order, and all side-effects are carried forward. In particular, all selectors in
  child operations are evaluated lazily, at the moment when the child operation is invoked.

- This operation behaves equivalent to the boolean 'And' meta-operation. If a child operation fails, the remaining child
  operations are not performed.

### Parameters

- Duration

#### Duration

##### Description

The length of time to wait, in seconds.

##### Default

- ```"1.0"```

##### Examples

- ```"0.1"```
- ```"1.23"```
- ```"5"```


----------------------------------------------------

## SpatialBlur

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation blurs pixels (within the plane of the image only) using the specified estimator.

### Parameters

- ImageSelection
- Estimator
- GaussianOpenSigma

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Estimator

##### Description

Controls the (in-plane) blur estimator to use. Options are currently: box_3x3, box_5x5, gaussian_3x3, gaussian_5x5, and
gaussian_open. The latter (gaussian_open) is adaptive and requires a supplementary parameter that controls the number of
adjacent pixels to consider. The former ('...3x3' and '...5x5') are 'fixed' estimators that use a convolution kernel
with a fixed size (3x3 or 5x5 pixel neighbourhoods). All estimators operate in 'pixel-space' and are ignorant about the
image spatial extent. All estimators are normalized, and thus won't significantly affect the pixel magnitude scale.

##### Default

- ```"gaussian_open"```

##### Examples

- ```"box_3x3"```
- ```"box_5x5"```
- ```"gaussian_3x3"```
- ```"gaussian_5x5"```
- ```"gaussian_open"```

#### GaussianOpenSigma

##### Description

Controls the number of neighbours to consider (only) when using the gaussian_open estimator. The number of pixels is
computed automatically to accommodate the specified sigma (currently ignored pixels have 3*sigma or less weighting). Be
aware this operation can take an enormous amount of time, since the pixel neighbourhoods quickly grow large.

##### Default

- ```"1.5"```

##### Examples

- ```"0.5"```
- ```"1.0"```
- ```"1.5"```
- ```"2.5"```
- ```"5.0"```


----------------------------------------------------

## SpatialDerivative

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation estimates various partial derivatives (of pixel values) within 2D images.

### Parameters

- ImageSelection
- Estimator
- Method

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Estimator

##### Description

Controls the finite-difference partial derivative order or estimator used. All estimators are centred and use mirror
boundary conditions. First-order estimators include the basic nearest-neighbour first derivative, and Roberts' cross,
Prewitt, Sobel, Scharr estimators. 'XxY' denotes the size of the convolution kernel (i.e., the number of adjacent pixels
considered). The only second-order estimator is the basic nearest-neighbour second derivative.

##### Default

- ```"Scharr-3x3"```

##### Supported Options

- ```"first"```
- ```"Roberts-cross-3x3"```
- ```"Prewitt-3x3"```
- ```"Sobel-3x3"```
- ```"Sobel-5x5"```
- ```"Scharr-3x3"```
- ```"Scharr-5x5"```
- ```"second"```

#### Method

##### Description

Controls partial derivative method. First-order derivatives can be row- or column-aligned, Roberts' cross can be
(+row,+col)-aligned or (-row,+col)-aligned. Second-order derivatives can be row-aligned, column-aligned, or 'cross'
--meaning the compound partial derivative. All methods support non-maximum-suppression for edge thinning, but currently
only the magnitude is output. All methods support magnitude (addition of orthogonal components in quadrature) and
orientation (in radians; [0,2pi) ).

##### Default

- ```"magnitude"```

##### Supported Options

- ```"row-aligned"```
- ```"column-aligned"```
- ```"prow-pcol-aligned"```
- ```"nrow-pcol-aligned"```
- ```"magnitude"```
- ```"orientation"```
- ```"non-maximum-suppression"```
- ```"cross"```


----------------------------------------------------

## SpatialSharpen

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation 'sharpens' pixels (within the plane of the image only) using the specified estimator.

### Parameters

- ImageSelection
- Estimator

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Estimator

##### Description

Controls the (in-plane) sharpening estimator to use. Options are currently: sharpen_3x3 and unsharp_mask_5x5. The latter
is based on a 5x5 Gaussian blur estimator.

##### Default

- ```"unsharp_mask_5x5"```

##### Supported Options

- ```"sharpen_3x3"```
- ```"unsharp_mask_5x5"```


----------------------------------------------------

## SubdivideSurfaceMeshes

### Tags

- accepts parameter: surface meshes
- category: mesh processing

### Description

This operation subdivides existing surface meshes according to the specified criteria, replacing the original meshes
with subdivided copies.

### Notes

- Selected surface meshes should represent polyhedra.

### Parameters

- MeshSelection
- Iterations

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Iterations

##### Description

The number of times subdivision should be performed.

##### Default

- ```"2"```

##### Examples

- ```"1"```
- ```"2"```
- ```"5"```


----------------------------------------------------

## SubsegmentContours

### Tags

- accepts parameter: contours
- category: contour processing

### Description

This operation sub-segments the selected contours, resulting in contours with reduced size.

### Parameters

- ROILabelRegex
- ROISelection
- NormalizedROILabelRegex
- PlanarOrientation
- ReplaceAllWithSubsegment
- RetainSubsegment
- SubsegMethod
- NestedCleaveOrder
- XSelection
- YSelection
- ZSelection
- FractionalTolerance
- MaxBisects

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### PlanarOrientation

##### Description

A string instructing how to orient the cleaving planes. Currently supported:

1. 'cardinal', which aligns the planes with the cardinal direction axes unit vectors. This method is most consistent,
but does not adapt to the anatomy of the subject. It works best when the subject's contours are defined on axial slices
in HFS position or have otherwise been transferred or transformed to this alignment.

2. 'axis-aligned', which aligns the cleave plane's Z axis with the average contour normal and uses a Gram-Schmidt
process to provide best-guesses for appropriate X and Y unit vectors. This method adapts to the subject's position but
because the contour planes and the cleaving planes are coplanar, it can result in splitting difficulties (e.g.,
degeneracies, numerical precision issues like contours being split into many thin, jagged sub-segments). If using this
method, consider limiting the number of iterations and fractional tolerance to help minimize risk of numerical issues.

3. 'static-oblique', which is the same as 'axis-aligned', but rotates all unit vectors by 22.5 degrees to reduce
coplanarity of the contour plane and the cleaving plane. This sometimes improves sub-segment area consistency, but
results in oblique sub-segments.

##### Default

- ```"axis-aligned"```

##### Supported Options

- ```"cardinal"```
- ```"axis-aligned"```
- ```"static-oblique"```

#### ReplaceAllWithSubsegment

##### Description

Keep the sub-segment and remove any existing contours from the original ROIs. This is most useful for further
processing, such as nested sub-segmentation. Note that sub-segment contours currently have identical metadata to their
parent contours.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```

#### RetainSubsegment

##### Description

Keep the sub-segment as part of the original ROIs. The contours are appended to the original ROIs, but the contour
ROIName and NormalizedROIName are set to the argument provided. (If no argument is provided, sub-segments are not
retained.) This is most useful for inspection of sub-segments. Note that sub-segment contours currently have identical
metadata to their parent contours, except they are renamed accordingly.

##### Default

- ```""```

##### Examples

- ```"subsegment_01"```
- ```"subsegment_02"```
- ```"selected_subsegment"```

#### SubsegMethod

##### Description

The method to use for sub-segmentation. Nested sub-segmentation should almost always be preferred unless you know what
you're doing. It should be faster too. Compound sub-segmentation is known to cause problems, e.g., with zero-area
sub-segments and spatial dependence in sub-segment volume.

##### Default

- ```"nested-cleave"```

##### Supported Options

- ```"nested-cleave"```
- ```"compound-cleave"```

#### NestedCleaveOrder

##### Description

The order in which to apply nested cleaves. Typically this will be one of 'ZXX', 'ZYX', 'XYZ', 'XZY', 'YZX', or 'YXZ',
but any non-empty combination of 'X', 'Y', and 'Z' are possible. Cleaves are implemented from left to right using the
specified X, Y, and Z selection criteria. Multiple cleaves along the same axis are possible, but note that currently the
same selection criteria are used for each iteration.

##### Default

- ```"ZXY"```

##### Examples

- ```"ZXY"```
- ```"ZYX"```
- ```"X"```
- ```"XYX"```

#### XSelection

##### Description

(See ZSelection description.) The 'X' direction is defined in terms of movement on an image when the row number
increases. This is generally VERTICAL and DOWNWARD for a patient in head-first supine orientation, but it varies with
orientation conventions. All selections are defined in terms of the original ROIs.

##### Default

- ```"1.0;0.0"```

##### Examples

- ```"0.50;0.50"```
- ```"0.50;0.0"```
- ```"0.30;0.0"```
- ```"0.30;0.70"```

#### YSelection

##### Description

(See ZSelection description.) The 'Y' direction is defined in terms of movement on an image when the column number
increases. This is generally HORIZONTAL and RIGHTWARD for a patient in head-first supine orientation, but it varies with
orientation conventions. All selections are defined in terms of the original ROIs.

##### Default

- ```"1.0;0.0"```

##### Examples

- ```"0.50;0.50"```
- ```"0.50;0.0"```
- ```"0.30;0.0"```
- ```"0.30;0.70"```

#### ZSelection

##### Description

The thickness and offset defining the single, continuous extent of the sub-segmentation in terms of the fractional area
remaining above a plane. The planes define the portion extracted and are determined such that sub-segmentation will give
the desired fractional planar areas. The numbers specify the thickness and offset from the bottom of the ROI volume to
the bottom of the extent. The 'upper' direction is take from the contour plane orientation and assumed to be positive if
pointing toward the positive-z direction. Only a single 3D selection can be made per operation invocation.
Sub-segmentation can be performed in transverse ('Z'), row_unit ('X'), and column_unit ('Y') directions (in that order).
All selections are defined in terms of the original ROIs. Note that impossible selections will likely result in errors,
e.g., specifying a small constraint when the . Note that it is possible to perform nested sub-segmentation (including
passing along the original contours) by opting to replace the original ROI contours with this sub-segmentation and
invoking this operation again with the desired sub-segmentation. Examples: If you want the middle 50% of an ROI, specify
'0.50;0.25'. If you want the upper 50% then specify '0.50;0.50'. If you want the lower 50% then specify '0.50;0.0'. If
you want the upper 30% then specify '0.30;0.70'. If you want the lower 30% then specify '0.30;0.70'.

##### Default

- ```"1.0;0.0"```

##### Examples

- ```"0.50;0.50"```
- ```"0.50;0.0"```
- ```"0.30;0.0"```
- ```"0.30;0.70"```

#### FractionalTolerance

##### Description

The tolerance of X, Y, and Z fractional area bisection criteria (see ZSelection description). This parameter specifies a
stopping condition for the bisection procedure. If it is set too high, sub-segments may be inadequatly rough. If it is
set too low, bisection below the machine precision floor may be attempted, which will result in instabilities. Note that
the number of permitted iterations will control whether this tolerance can possibly be reached; if strict adherence is
required, set the maximum number of iterations to be excessively large.

##### Default

- ```"0.001"```

##### Examples

- ```"1E-2"```
- ```"1E-3"```
- ```"1E-4"```
- ```"1E-5"```

#### MaxBisects

##### Description

The maximum number of iterations the bisection procedure can perform. This parameter specifies a stopping condition for
the bisection procedure. If it is set too low, sub-segments may be inadequatly rough. If it is set too high, bisection
below the machine precision floor may be attempted, which will result in instabilities. Note that the fractional
tolerance will control whether this tolerance can possibly be reached; if an exact number of iterations is required, set
the fractional tolerance to be excessively small.

##### Default

- ```"20"```

##### Examples

- ```"10"```
- ```"20"```
- ```"30"```


----------------------------------------------------

## Subsegment_ComputeDose_VanLuijk

### Tags

- accepts parameter: contours
- category: contour processing

### Description

This operation sub-segments the selected ROI(s) and computes dose within the resulting sub-segments.

### Parameters

- AreaDataFileName
- DerivativeDataFileName
- DistributionDataFileName
- NormalizedROILabelRegex
- PlanarOrientation
- ReplaceAllWithSubsegment
- RetainSubsegment
- ROILabelRegex
- ROISelection
- SubsegMethod
- XSelection
- YSelection
- ZSelection
- FractionalTolerance
- MaxBisects

#### AreaDataFileName

##### Description

A filename (or full path) in which to append sub-segment areaa data generated by this routine. The format is CSV. Note
that if a sub-segment has zero area or does not exist, no area will be printed. You'll have to manually add sub-segments
with zero area as needed if this info is relevant to you (e.g., if you are deriving a population average). Leave empty
to NOT dump anything.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"area_data.csv"```

#### DerivativeDataFileName

##### Description

A filename (or full path) in which to append derivative data generated by this routine. The format is CSV. Leave empty
to dump to generate a unique temporary file.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"derivative_data.csv"```

#### DistributionDataFileName

##### Description

A filename (or full path) in which to append raw distribution data generated by this routine. The format is one line of
description followed by one line for the distribution; pixel intensities are listed with a single space between
elements; the descriptions contain the patient ID, ROIName, and subsegment description (guaranteed) and possibly various
other data afterward. Leave empty to NOT dump anything.

##### Default

- ```""```

##### Examples

- ```""```
- ```"/tmp/somefile"```
- ```"localfile.csv"```
- ```"distributions.data"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### PlanarOrientation

##### Description

A string instructing how to orient the cleaving planes. Currently only 'AxisAligned' (i.e., align with the image/dose
grid row and column unit vectors) and 'StaticOblique' (i.e., same as AxisAligned but rotated 22.5 degrees to reduce
colinearity, which sometimes improves sub-segment area consistency).

##### Default

- ```"AxisAligned"```

##### Supported Options

- ```"AxisAligned"```
- ```"StaticOblique"```

#### ReplaceAllWithSubsegment

##### Description

Keep the sub-segment and remove any existing contours from the original ROIs. This is most useful for further
processing, such as nested sub-segmentation. Note that sub-segment contours currently have identical metadata to their
parent contours.

##### Default

- ```"false"```

##### Examples

- ```"true"```
- ```"false"```

#### RetainSubsegment

##### Description

Keep the sub-segment as part of the original ROIs. The contours are appended to the original ROIs, but the contour
ROIName and NormalizedROIName are set to the argument provided. (If no argument is provided, sub-segments are not
retained.) This is most useful for inspection of sub-segments. Note that sub-segment contours currently have identical
metadata to their parent contours, except they are renamed accordingly.

##### Default

- ```""```

##### Examples

- ```"subsegment_01"```
- ```"subsegment_02"```
- ```"selected_subsegment"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### SubsegMethod

##### Description

The method to use for sub-segmentation. Nested sub-segmentation should almost always be preferred unless you know what
you're doing. It should be faster too. The compound method was used in the van Luijk paper, but it is known to have
serious problems.

##### Default

- ```"nested"```

##### Supported Options

- ```"nested"```
- ```"compound"```

#### XSelection

##### Description

(See ZSelection description.) The "X" direction is defined in terms of movement on an image when the row number
increases. This is generally VERTICAL and DOWNWARD. All selections are defined in terms of the original ROIs.

##### Default

- ```"1.0;0.0"```

##### Examples

- ```"0.50;0.50"```
- ```"0.50;0.0"```
- ```"0.30;0.0"```
- ```"0.30;0.70"```

#### YSelection

##### Description

(See ZSelection description.) The "Y" direction is defined in terms of movement on an image when the column number
increases. This is generally HORIZONTAL and RIGHTWARD. All selections are defined in terms of the original ROIs.

##### Default

- ```"1.0;0.0"```

##### Examples

- ```"0.50;0.50"```
- ```"0.50;0.0"```
- ```"0.30;0.0"```
- ```"0.30;0.70"```

#### ZSelection

##### Description

The thickness and offset defining the single, continuous extent of the sub-segmentation in terms of the fractional area
remaining above a plane. The planes define the portion extracted and are determined such that sub-segmentation will give
the desired fractional planar areas. The numbers specify the thickness and offset from the bottom of the ROI volume to
the bottom of the extent. The 'upper' direction is take from the contour plane orientation and assumed to be positive if
pointing toward the positive-z direction. Only a single 3D selection can be made per operation invocation.
Sub-segmentation can be performed in transverse ("Z"), row_unit ("X"), and column_unit ("Y") directions (in that order).
All selections are defined in terms of the original ROIs. Note that it is possible to perform nested sub-segmentation
(including passing along the original contours) by opting to replace the original ROI contours with this
sub-segmentation and invoking this operation again with the desired sub-segmentation. If you want the middle 50% of an
ROI, specify '0.50;0.25'. If you want the upper 50% then specify '0.50;0.50'. If you want the lower 50% then specify
'0.50;0.0'. If you want the upper 30% then specify '0.30;0.70'. If you want the lower 30% then specify '0.30;0.70'.

##### Default

- ```"1.0;0.0"```

##### Examples

- ```"0.50;0.50"```
- ```"0.50;0.0"```
- ```"0.30;0.0"```
- ```"0.30;0.70"```

#### FractionalTolerance

##### Description

The tolerance of X, Y, and Z fractional area bisection criteria (see ZSelection description). This parameter specifies a
stopping condition for the bisection procedure. If it is set too high, sub-segments may be inadequatly rough. If it is
set too low, bisection below the machine precision floor may be attempted, which will result in instabilities. Note that
the number of permitted iterations will control whether this tolerance can possibly be reached; if strict adherence is
required, set the maximum number of iterations to be excessively large.

##### Default

- ```"0.001"```

##### Examples

- ```"1E-2"```
- ```"1E-3"```
- ```"1E-4"```
- ```"1E-5"```

#### MaxBisects

##### Description

The maximum number of iterations the bisection procedure can perform. This parameter specifies a stopping condition for
the bisection procedure. If it is set too low, sub-segments may be inadequatly rough. If it is set too high, bisection
below the machine precision floor may be attempted, which will result in instabilities. Note that the fractional
tolerance will control whether this tolerance can possibly be reached; if an exact number of iterations is required, set
the fractional tolerance to be excessively small.

##### Default

- ```"20"```

##### Examples

- ```"10"```
- ```"20"```
- ```"30"```


----------------------------------------------------

## SubtractImages

### Tags

- accepts parameter: images
- category: image processing

### Description

This routine subtracts images that spatially overlap.

### Notes

- The ReferenceImageSelection is subtracted from the ImageSelection and the result is stored in ImageSelection. So this
  operation implements $A = A - B$ where A is ImageSelection and B is ReferenceImageSelection. The
  ReferenceImageSelection images are not altered.

- Multiple image volumes can be selected by both ImageSelection and ReferenceImageSelection. For each ImageSelection
  volume, each of the ReferenceImageSelection volumes are subtracted sequentially.

### Parameters

- ImageSelection
- ReferenceImageSelection

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ReferenceImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"!last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## SupersampleImageGrid

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation supersamples (i.e., scales and resamples) whole image arrays so they have more rows and/or columns, but
in a way that the supersampled image array retains the shape and spatial extent of the original image array. This
operation is typically used for 'zooming' into images, or dividing large voxels so that binarization using small
contours has reduced spillover.

### Notes

- Be aware that specifying large multipliers (or even small multipliers on large images) could consume large amounts of
  memory. It is best to pre-crop images to a given region of interest if possible.

### Parameters

- ImageSelection
- RowScaleFactor
- ColumnScaleFactor
- SliceScaleFactor
- SamplingMethod

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### RowScaleFactor

##### Description

A positive integer specifying how many rows will be in the new images. The number is relative to the incoming image row
count. Specifying '1' will result in nothing happening. Specifying '8' will result in 8x as many rows.

##### Default

- ```"2"```

##### Examples

- ```"1"```
- ```"2"```
- ```"3"```
- ```"8"```

#### ColumnScaleFactor

##### Description

A positive integer specifying how many columns will be in the new images. The number is relative to the incoming image
column count. Specifying '1' will result in nothing happening. Specifying '8' will result in 8x as many columns.

##### Default

- ```"2"```

##### Examples

- ```"1"```
- ```"2"```
- ```"3"```
- ```"8"```

#### SliceScaleFactor

##### Description

A positive integer specifying how many image slices will be in the new images. The number is relative to the incoming
image slice count. Specifying '1' will result in nothing happening. Specifying '8' will result in 8x as many slices.
Note that slice supersampling always happens *after* in-plane supersampling. Also note that merely setting this factor
will not enable 3D supersampling; you also need to specify a 3D-aware SamplingMethod.

##### Default

- ```"2"```

##### Examples

- ```"1"```
- ```"2"```
- ```"3"```
- ```"8"```

#### SamplingMethod

##### Description

The supersampling method to use. Note: 'inplane-' methods only consider neighbours in the plane of a single image --
neighbours in adjacent images are not considered and the supersampled image will contain the same number of image slices
as the inputs.

##### Default

- ```"inplane-bilinear"```

##### Supported Options

- ```"inplane-bicubic"```
- ```"inplane-bilinear"```
- ```"trilinear"```


----------------------------------------------------

## TabulateImageMetadata

### Tags

- accepts parameter: images
- category: image processing
- category: metadata
- category: table processing

### Description

Extract metadata from images and write them in a tabular format.

### Parameters

- ImageSelection
- Keys
- ProvideDefault
- DefaultValue
- UserComment
- TableShape
- IncludeHeader
- TableLabel

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Keys

##### Description

A string of semicolon-separated metadata keys. The value corresponding to each key will be output. Images that do not
have the metadata key will either return the user-provided DefaultValue, or simply not output anything if ProvideDefault
is false.

##### Default

- ```"PatientID;Filename"```

##### Examples

- ```"PatientID"```
- ```"Filename"```
- ```"Treatment plan C"```

#### ProvideDefault

##### Description

If an image does not have the given metadata key, this option controls whether the user-provided DefaultValue is output.

##### Default

- ```"true"```

##### Supported Options

- ```"true"```
- ```"false"```

#### DefaultValue

##### Description

If an image does not have the given metadata key, this default will be output when ProvideDefault is true.

##### Default

- ```"NA"```

##### Examples

- ```""```
- ```"NA"```
- ```"NULL"```
- ```"1.23"```

#### UserComment

##### Description

A string that will be inserted into the output. If left empty, the column will be empty in the output.

##### Default

- ```""```

##### Examples

- ```""```
- ```"Using XYZ"```
- ```"Treatment plan C"```

#### TableShape

##### Description

Controls the 'shape' of the output, i.e., whether all records appear on the same line ('wide') or are split along
several lines ('tall', i.e., key-value shape).

##### Default

- ```"wide"```

##### Supported Options

- ```"wide"```
- ```"tall"```

#### IncludeHeader

##### Description

Controls whether a 'header' is output. Note that the header refers to the metadatakeys, which may appear in different
places depending on the TableShape

##### Default

- ```"true"```

##### Supported Options

- ```"true"```
- ```"false"```

#### TableLabel

##### Description

A label to attach to the new table.

##### Default

- ```"unspecified"```

##### Examples

- ```"unspecified"```
- ```"xyz"```
- ```"sheet A"```


----------------------------------------------------

## Terminal_Viewer

### Tags

- category: interactive

### Description

Launch an interactive viewer inside a terminal/console.

### Parameters

- MaxImageLength
- ColourMethod

#### MaxImageLength

##### Description

The maximum size images will be rendered. Note that aspect ratio scaling (which is approximate at best) may result in
images being displayed with smaller vertical and horizontal lengths. The optimal value depends on your screen
resolution, font size, required visual resolution, and, potentially, bandwidth.

##### Default

- ```"120"```

##### Examples

- ```"50"```
- ```"78"```
- ```"80"```
- ```"120"```
- ```"200"```

#### ColourMethod

##### Description

Controls how images are displayed. The default, 'auto', will provide the highest number of colour depth possible.
However, automatic detection is hard so overrides may be needed.

'24-bit' provides the greatest colour depth, but is not supported by all terminals.

'6-bit' provides a reasonable amount of colour depth, and is more widely supported.

'24-steps' provides low-quality colour depth, but is almost universally available.

'5-steps' displays intensity using unicode 'shade' blocks.

'numbers' uses ASCII monochrome numbers (0-9) to display intensity.

'punctuation' uses ASCII monochrome punctuation marks to display intensity.

##### Default

- ```"auto"```

##### Examples

- ```"auto"```
- ```"24-bit"```
- ```"6-bit"```
- ```"24-steps"```
- ```"5-steps"```
- ```"numbers"```
- ```"punctuation"```


----------------------------------------------------

## ThresholdImages

### Tags

- accepts parameter: images
- category: image processing

### Description

This operation applies thresholds to images. Both upper and lower thresholds can be specified.

### Notes

- This routine operates on individual images. When thresholds are specified on a percentile basis, each image is
  considered separately and therefore each image may be thresholded with different values.

- Both thresholds are inclusive. To binarize an image, use the same threshold for both upper and lower threshold
  parameters. Voxels that fall on the threshold will currently be treated as if they exclusively satisfy the upper
  threshold, but this behaviour is not guaranteed.

### Parameters

- Lower
- Low
- Upper
- High
- Channel
- ImageSelection

#### Lower

##### Description

The lower bound (inclusive). Pixels with values < this number are replaced with the 'low' value. If this number is
followed by a '%', the bound will be scaled between the min and max pixel values [0-100%]. If this number is followed by
'tile', the bound will be replaced with the corresponding percentile [0-100tile]. Note that upper and lower bounds can
be specified separately (e.g., lower bound is a percentage, but upper bound is a percentile).

##### Default

- ```"-inf"```

##### Examples

- ```"0.0"```
- ```"-1E-99"```
- ```"1.23"```
- ```"0.2%"```
- ```"23tile"```
- ```"23.123 tile"```

#### Low

##### Description

The value a pixel will take when below the lower threshold.

##### Default

- ```"-inf"```

##### Examples

- ```"0.0"```
- ```"-1000.0"```
- ```"-inf"```
- ```"nan"```

#### Upper

##### Description

The upper bound (inclusive). Pixels with values > this number are replaced with the 'high' value. If this number is
followed by a '%', the bound will be scaled between the min and max pixel values [0-100%]. If this number is followed by
'tile', the bound will be replaced with the corresponding percentile [0-100tile]. Note that upper and lower bounds can
be specified separately (e.g., lower bound is a percentage, but upper bound is a percentile).

##### Default

- ```"inf"```

##### Examples

- ```"1.0"```
- ```"1E-99"```
- ```"2.34"```
- ```"98.12%"```
- ```"94tile"```
- ```"94.123 tile"```

#### High

##### Description

The value a pixel will take when above the upper threshold.

##### Default

- ```"inf"```

##### Examples

- ```"0.0"```
- ```"1000.0"```
- ```"inf"```
- ```"nan"```

#### Channel

##### Description

The image channel to use. Zero-based.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"2"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## ThresholdOtsu

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This routine performs Otsu thresholding (i.e., 'binarization') on an image volume. The thresholding is limited within
ROI(s). Otsu thresholding works best on images with a well-defined bimodal voxel intensity histogram. It works by
finding the threshold that partitions the voxel intensity histogram into two parts, essentially so that the sum of each
partition's variance is minimal. The number of histogram bins (i.e., number of distinct voxel magnitude levels) is
configurable. Voxels are binarized; the replacement values are also configurable.

### Notes

- The Otsu method will not necessarily cleanly separate bimodal peaks in the voxel intensity histogram.

### Parameters

- ImageSelection
- HistogramBins
- ReplacementLow
- ReplacementHigh
- OverwriteVoxels
- Channel
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- ContourOverlap
- Inclusivity

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### HistogramBins

##### Description

The number of equal-width bins the histogram should have. Classically, images were 8-bit integer-valued and thus 255
bins were commonly used. However, because floating-point numbers are used practically any number of bins are supported.
What is optimal (or acceptable) depends on the analytical requirements. If the threshold does not have to be exact, try
use the smallest number of bins you can get away with; 50-150 should suffice. This will speed up computation. If the
threshold is being used for analytical purposes, use as many bins as the data can support -- if the voxel values span
only 8-bit integers, having more than 255 bins will not improve the analysis. Likewise if voxels are discretized or
sparse. Experiment by gradually increasing the number of bins until the threshold value converges to a reasonable
number, and then use that number of bins for future analysis.

##### Default

- ```"255"```

##### Examples

- ```"10"```
- ```"50"```
- ```"100"```
- ```"200"```
- ```"500"```

#### ReplacementLow

##### Description

The value to give voxels which are below (exclusive) the Otsu threshold value.

##### Default

- ```"0.0"```

##### Examples

- ```"-1.0"```
- ```"0.0"```
- ```"1.23"```
- ```"nan"```
- ```"inf"```

#### ReplacementHigh

##### Description

The value to give voxels which are above (inclusive) the Otsu threshold value.

##### Default

- ```"1.0"```

##### Examples

- ```"-1.0"```
- ```"0.0"```
- ```"1.23"```
- ```"nan"```
- ```"inf"```

#### OverwriteVoxels

##### Description

Controls whether voxels should actually be binarized or not. Whether or not voxel intensities are overwritten, the Otsu
threshold value is written into the image metadata as 'OtsuThreshold' in case further processing is needed.

##### Default

- ```"true"```

##### Examples

- ```"true"```
- ```"false"```

#### Channel

##### Description

The image channel to use. Zero-based.

##### Default

- ```"0"```

##### Examples

- ```"0"```
- ```"1"```
- ```"2"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. The option 'honour_opposite_orientations' makes overlapping contours with opposite
orientation cancel. Otherwise, orientation is ignored. The latter is useful for Boolean structures where contour
orientation is significant for interior contours (holes). The option 'overlapping_contours_cancel' ignores orientation
and cancels all contour overlap.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```


----------------------------------------------------

## Time

### Tags

- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that times how long it takes to execute the child operations.

### Notes

- Child operations are performed in order, and all side-effects are carried forward. In particular, all selectors in
  child operations are evaluated lazily, at the moment when the child operation is invoked.

- This operation behaves equivalent to the boolean 'And' meta-operation. If a child operation fails, the remaining child
  operations are not performed.

### Parameters

No registered options.

----------------------------------------------------

## Transaction

### Tags

- category: control flow
- category: meta

### Description

This operation will make a snapshot of the internal data state and execute children operations. If any child operation
fails or returns false, the state will be reset to the snapshot and the remaining children operations will not be
executed. If all children operations succeed, any modifications to the modified state will be committed automatically
when the final operation succeeds, and the snapshot will be discarded.

### Notes

- This operation only transacts the internal state of the Drover object and the parameter table. Any side-effects caused
  by the children operations, such as modifying files, appending to logs, interaction with terminals/consoles, or
  interacting over networks, will not be transacted. Side-effects will therefore be committed immediately, regardless of
  whether the transaction succeeds.

- This operation duplicates the full internal data state, so can be memory-intensive.

### Parameters

No registered options.

----------------------------------------------------

## TrimROIDose

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: contour processing
- category: image processing
- category: radiation dose

### Description

This operation provides a simplified interface for overriding the dose within a ROI. For example, this operation can be
used to modify a base plan by eliminating dose that coincides with a PTV/CTV/GTV/ROI etc.

### Notes

- This operation performs the opposite of the 'Crop' operation, which trims the dose outside a ROI.

- The inclusivity of a dose voxel that straddles the ROI boundary can be specified in various ways. Refer to the
  Inclusivity parameter documentation.

- By default this operation only overrides dose within a ROI. The opposite, overriding dose outside of a ROI, can be
  accomplished using the expert interface.

### Parameters

- Channel
- ImageSelection
- ContourOverlap
- Inclusivity
- Method
- ExteriorVal
- InteriorVal
- ExteriorOverwrite
- InteriorOverwrite
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- ImageSelection
- Filename
- ParanoiaLevel

#### Channel

##### Description

The image channel to use. Zero-based. Use '-1' to operate on all available channels.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. This will effectively honour only the outermost contour regardless of orientation,
but provides the most predictable and consistent results. The option 'honour_opposite_orientations' makes overlapping
contours with opposite orientation cancel. Otherwise, orientation is ignored. This is useful for Boolean structures
where contour orientation is significant for interior contours (holes). If contours do not have consistent overlap
(e.g., if contours intersect) the results can be unpredictable and hard to interpret. The option
'overlapping_contours_cancel' ignores orientation and alternately cancerls all overlapping contours. Again, if the
contours do not have consistent overlap (e.g., if contours intersect) the results can be unpredictable and hard to
interpret.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"planar_inc"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### Method

##### Description

Controls the type of image mask that is generated. The default, 'binary', exclusively overwrites voxels with the
InteriorValue or ExteriorValue. Another method is 'receding_squares' which creates a mask which, if processed with the
marching-squares algorithm, will (mostly) recreate the original contours. The 'receding_squares' can be considered the
inverse of the marching-squares algorithm. Note that the 'receding_squares' implementation is not optimized for speed.

##### Default

- ```"binary"```

##### Supported Options

- ```"binary"```
- ```"receding_squares"```

#### ExteriorVal

##### Description

The value to give to voxels outside the specified ROI(s). For the 'binary' method, note that this value will be ignored
if exterior overwrites are disabled. For the 'receding_squares' method this value is used to define the threshold needed
to recover the original contours (mean of InteriorVal and ExteriorVal).

##### Default

- ```"0.0"```

##### Examples

- ```"0.0"```
- ```"-1.0"```
- ```"1.23"```
- ```"2.34E26"```

#### InteriorVal

##### Description

The value to give to voxels within the specified ROI(s). For the 'binary' method, note that this value will be ignored
if interior overwrites are disabled. For the 'receding_squares' method this value is used to define the threshold needed
to recover the original contours (mean of InteriorVal and ExteriorVal).

##### Default

- ```"0.0"```

##### Examples

- ```"0.0"```
- ```"-1.0"```
- ```"1.23"```
- ```"2.34E26"```

#### ExteriorOverwrite

##### Description

Whether to overwrite voxels exterior to the specified ROI(s).

##### Default

- ```"false"```

##### Supported Options

- ```"true"```
- ```"false"```

#### InteriorOverwrite

##### Description

Whether to overwrite voxels interior to the specified ROI(s).

##### Default

- ```"true"```

##### Supported Options

- ```"true"```
- ```"false"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Filename

##### Description

The filename (or full path name) to which the DICOM file should be written.

##### Default

- ```"/tmp/RD.dcm"```

##### Examples

- ```"/tmp/RD.dcm"```
- ```"./RD.dcm"```
- ```"RD.dcm"```

#### ParanoiaLevel

##### Description

At low paranoia setting, only top-level UIDs are replaced. At medium paranoia setting, many UIDs, descriptions, and
labels are replaced, but the PatientID and FrameOfReferenceUID are retained. The high paranoia setting is the same as
the medium setting, but the PatientID and FrameOfReferenceUID are also replaced. (Note: this is not a full
anonymization.) Use the low setting if you want to retain linkage to the originating data set. Use the medium setting if
you don't. Use the high setting if your TPS goes overboard linking data sets by PatientID and/or FrameOfReferenceUID.

##### Default

- ```"medium"```

##### Supported Options

- ```"low"```
- ```"medium"```
- ```"high"```


----------------------------------------------------

## True

### Tags

- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that completes successfully. It has no side effects and evaluates to a
no-op.

### Parameters

No registered options.

----------------------------------------------------

## UBC3TMRI_DCE

### Tags

- category: image processing
- category: modeling
- category: needs refresh
- category: perfusion

### Description

This operation is used to generate dynamic contrast-enhanced MRI contrast enhancement maps.

### Parameters

No registered options.

----------------------------------------------------

## UBC3TMRI_DCE_Differences

### Tags

- category: image processing
- category: modeling
- category: needs refresh
- category: perfusion

### Description

This operation is used to generate dynamic contrast-enhanced MRI contrast enhancement maps.

### Notes

- This routine generates difference maps using both long DCE scans. Thus it takes up a LOT of memory! Try avoid
  unnecessary copies of large (temporally long) arrays.

### Parameters

No registered options.

----------------------------------------------------

## UBC3TMRI_DCE_Experimental

### Tags

- category: image processing
- category: modeling
- category: needs refresh
- category: perfusion

### Description

This operation is an experimental operation for processing dynamic contrast-enhanced MR images.

### Parameters

No registered options.

----------------------------------------------------

## UBC3TMRI_IVIM_ADC

### Tags

- category: diffusion
- category: image processing
- category: modeling
- category: needs refresh

### Description

This operation is an experimental operation for processing IVIM MR images into ADC maps.

### Parameters

No registered options.

----------------------------------------------------

## ValidateRTPlan

### Tags

- accepts parameter: tables
- category: rtplan processing
- category: table processing

### Description

This operation evaluates a radiotherapy treatment plan against user-specified criteria.

### Parameters

- RTPlanSelection
- Checks
- TableSelection

#### RTPlanSelection

##### Description

Select one or more treatment plans. Note that a single treatment plan may be composed of multiple beams; if delivered
sequentially, they should collectively represent a single logically cohesive plan. Selection specifiers can be of three
types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth treatment plan (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last treatment plan.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the treatment plan composed of the greatest and fewest number of control points. Only one or zero treatment plan
will be selected; if there are ties, there is no guarantee which treatment plan will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple treatment plan based on a threshold count, i.e., where all selected treatment plan
have more than or fewer than $N$ control points. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all treatment plan that do not have the greatest number of control points, not the least-numerous
treatment plan (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Checks

##### Description

The specific checks to perform when evaluating the plan. This parameter will often contain a script with multiple
checks. List of supported checks:

'pass' -- This check always passes.

'fail' -- This check never passes.

'all of' -- All children checks must pass for this check to pass.

'one or more of' -- At least one of the children checks must pass for this check to pass.

'none of' -- All children checks must fail for this check to pass.

'plan name has no spaces' -- Ensure the plan name does not contain any spaces.

'has VMAT arc' -- Ensure the plan name does not contain any spaces.

'VMAT arc collimator angles not degenerate' -- All VMAT arc collimator angles should be distinct to minimize
optimization cost-function degeneracy.

'jaw openings larger than' -- The X and Y jaws should be opened sufficiently to facilitate accurate dosimetric modeling.
Minimum X and Y jaw openings (in mm) are required

##### Default

- ```""```

##### Examples

- ```"require(){ check_A(); check_B(); ... }"```
- ```"all_of(){ check_A(); check_B(); ... }"```
- ```"any_of(){ check_A(); check_B(); ... }"```

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```


----------------------------------------------------

## VolumetricCorrelationDetector

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This operation can assess 3D correlations by sampling the neighbourhood surrounding each voxel and assigning a
similarity score. This routine is useful for detecting repetitive (regular) patterns that are known in advance.

### Notes

- The provided image collection must be rectilinear.

- At the moment this routine can only be modified via recompilation.

### Parameters

- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Low
- High
- Channel

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Low

##### Description

The low percentile.

##### Default

- ```"0.05"```

##### Examples

- ```"0.05"```
- ```"0.5"```
- ```"0.99"```

#### High

##### Description

The high percentile.

##### Default

- ```"0.95"```

##### Examples

- ```"0.95"```
- ```"0.5"```
- ```"0.05"```

#### Channel

##### Description

The channel to operated on (zero-based). Negative values will cause all channels to be operated on.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```


----------------------------------------------------

## VolumetricSpatialBlur

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This operation performs blurring of voxel values within 3D rectilinear image arrays.

### Notes

- The provided image collection must be rectilinear.

### Parameters

- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Channel
- Estimator

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Channel

##### Description

The channel to operated on (zero-based). Negative values will cause all channels to be operated on.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```

#### Estimator

##### Description

Controls which type of blur is computed. Currently, 'Gaussian' refers to a fixed sigma=1 (in pixel coordinates, not
DICOM units) Gaussian blur that extends for 3*sigma thus providing a 7x7x7 window. Note that applying this kernel N
times will approximate a Gaussian with sigma=N. Also note that boundary voxels will cause accessible voxels within the
same window to be more heavily weighted. Try avoid boundaries or add extra margins if possible.

##### Default

- ```"Gaussian"```

##### Supported Options

- ```"Gaussian"```


----------------------------------------------------

## VolumetricSpatialDerivative

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing

### Description

This operation estimates various spatial partial derivatives (of pixel values) within 3D rectilinear image arrays.

### Notes

- The provided image collection must be rectilinear.

### Parameters

- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- Channel
- Estimator
- Method

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### Channel

##### Description

The channel to operated on (zero-based). Negative values will cause all channels to be operated on.

##### Default

- ```"-1"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```

#### Estimator

##### Description

Controls the finite-difference partial derivative order or estimator used. All estimators are centred and use mirror
boundary conditions. First-order estimators include the basic nearest-neighbour first derivative and Sobel estimators.
'XxYxZ' denotes the size of the convolution kernel (i.e., the number of adjacent pixels considered).

##### Default

- ```"Sobel-3x3x3"```

##### Supported Options

- ```"first"```
- ```"Sobel-3x3x3"```

#### Method

##### Description

Controls partial derivative method. First-order derivatives can be row-, column-, or image-aligned, All methods also
support magnitude (addition of orthogonal components in quadrature).

##### Default

- ```"magnitude"```

##### Supported Options

- ```"row-aligned"```
- ```"column-aligned"```
- ```"image-aligned"```
- ```"magnitude"```
- ```"non-maximum-suppression"```


----------------------------------------------------

## VoxelRANSAC

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing
- category: needs refresh

### Description

This routine performs RANSAC fitting using voxel positions as inputs. The search can be confined within ROIs and a range
of voxel intensities.

### Notes

- This operation does not make use of voxel intensities during the RANSAC procedure. Voxel intensities are only used to
  identify which voxel positions are considered.

### Parameters

- ImageSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- ContourOverlap
- Inclusivity
- Channel
- Lower
- Upper
- GridSeparation

#### ImageSelection

##### Description

Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a single
contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix logically
unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. The option 'honour_opposite_orientations' makes overlapping contours with opposite
orientation cancel. Otherwise, orientation is ignored. The latter is useful for Boolean structures where contour
orientation is significant for interior contours (holes). The option 'overlapping_contours_cancel' ignores orientation
and cancels all contour overlap.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### Channel

##### Description

The channel to operated on (zero-based). Negative values will cause all channels to be operated on.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```

#### Lower

##### Description

Lower threshold (inclusive) below which voxels will be ignored by this routine.

##### Default

- ```"-inf"```

##### Examples

- ```"-inf"```
- ```"0.0"```
- ```"1024"```

#### Upper

##### Description

Upper threshold (inclusive) above which voxels will be ignored by this routine.

##### Default

- ```"inf"```

##### Examples

- ```"inf"```
- ```"1.0"```
- ```"2048"```

#### GridSeparation

##### Description

The known separation of the grid (in DICOM units; mm) being sought.

##### Default

- ```"nan"```

##### Examples

- ```"1.0"```
- ```"1.5"```
- ```"10.0"```
- ```"1.23E4"```


----------------------------------------------------

## WarpContours

### Tags

- accepts parameter: contours
- category: contour processing
- category: spatial transform processing

### Description

This operation applies a transform object to the specified contours, warping them spatially.

### Notes

- A transform object must be selected; this operation cannot create transforms. Transforms can be generated via
  registration or by parsing user-provided functions.

- Contours are transformed in-place. Metadata may become invalid by this operation.

- This operation can only handle individual transforms. If multiple, sequential transforms are required, this operation
  must be invoked multiple time. This will guarantee the ordering of the transforms.

- Transformations are not (generally) restricted to the coordinate frame of reference that they were derived from. This
  permits a single transformation to be applicable to point clouds, surface meshes, images, and contours.

### Parameters

- ROILabelRegex
- ROISelection
- NormalizedROILabelRegex
- TransformSelection

#### ROILabelRegex

##### Description

A regular expression (regex) matching *raw* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Select one or more contour regions of interest (aka contour collection). Note that each region of interest may be
comprised of multiple individual contours. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### NormalizedROILabelRegex

##### Description

A regular expression (regex) matching *normalized* ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### TransformSelection

##### Description

Select one or more transform objects (aka 'warp' objects). Selection specifiers can be of three types: positional,
metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth transformation (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last transformation.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the transformation composed of the greatest and fewest number of sub-objects. Only one or zero transformation
will be selected; if there are ties, there is no guarantee which transformation will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple transformation based on a threshold count, i.e., where all selected transformation
have more than or fewer than $N$ sub-objects. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all transformation that do not have the greatest number of sub-objects, not the least-numerous
transformation (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```


----------------------------------------------------

## WarpImages

### Tags

- accepts parameter: contours
- accepts parameter: images
- category: image processing
- category: spatial transform processing

### Description

This operation applies a transform object to the specified image arrays, warping them spatially.

### Notes

- A transform object must be selected; this operation cannot create transforms. Transforms can be generated via
  registration or by parsing user-provided functions.

- Image metadata may become invalidated by this operation.

- This operation can only handle individual transforms. If multiple, sequential transforms are required, this operation
  must be invoked multiple time. This will guarantee the ordering of the transforms.

- This operation currently supports only affine transformations. Local transformations require special handling and
  voxel resampling that is not yet implemented.

- Transformations are not (generally) restricted to the coordinate frame of reference that they were derived from. This
  permits a single transformation to be applicable to point clouds, surface meshes, images, and contours.

### Parameters

- ImageSelection
- ReferenceImageSelection
- TransformSelection
- NormalizedROILabelRegex
- ROILabelRegex
- ROISelection
- ContourOverlap
- Inclusivity
- Channel

#### ImageSelection

##### Description

The image array that will be transformed or sampled. Voxel intensities from ImageSelection will be retain, but possibly
resampled. Select one or more image arrays. Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible to mix
logically unrelated images together. Selection specifiers can be of three types: positional, metadata-based key@value
regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ReferenceImageSelection

##### Description

The image array that will be copied and voxel values overwritten. The ImageSelection will inherit geometry from the
ReferenceImageSelection. Select one or more image arrays. Note that image arrays can hold anything, but will typically
represent a single contiguous 3D volume (i.e., a volumetric CT scan) or '4D' time-series. Be aware that it is possible
to mix logically unrelated images together. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth image array (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last image array.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the image array composed of the greatest and fewest number of images. Only one or zero image array will be
selected; if there are ties, there is no guarantee which image array will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple image array based on a threshold count, i.e., where all selected image array have
more than or fewer than $N$ images. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that '!numerous'
means all image array that do not have the greatest number of images, not the least-numerous image array (i.e.,
'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"first"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TransformSelection

##### Description

Transformations to be applied to the ImageSelection array. Select one or more transform objects (aka 'warp' objects).
Selection specifiers can be of three types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth transformation (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last transformation.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the transformation composed of the greatest and fewest number of sub-objects. Only one or zero transformation
will be selected; if there are ties, there is no guarantee which transformation will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple transformation based on a threshold count, i.e., where all selected transformation
have more than or fewer than $N$ sub-objects. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all transformation that do not have the greatest number of sub-objects, not the least-numerous
transformation (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```

#### NormalizedROILabelRegex

##### Description

Contours on the ReferenceImageSelection images that limit resampling. A regular expression (regex) matching *normalized*
ROI contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match contour labels that have been *normalized* (i.e., mapped, translated) using the
user-provided provided lexicon. This is useful for handling data with heterogeneous naming conventions where fuzzy
matching is required. Refer to the lexicon for available labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*Body.*"```
- ```"Body"```
- ```"liver"```
- ```".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"```
- ```"Left Parotid|Right Parotid"```
- ```"^(?!Left Parotid).*$"```

#### ROILabelRegex

##### Description

Contours on the ReferenceImageSelection images that limit resampling. A regular expression (regex) matching *raw* ROI
contour labels/names to consider.

Selection is performed on a whole-ROI basis; individual contours cannot be selected. Be aware that input spaces are
trimmed to a single space. If your ROI name has more than two sequential spaces, use regular expressions or escaping to
avoid them. All ROIs you want to select must match the provided (single) regex, so use boolean or ('|') if needed.

The regular expression engine is case insensitive and uses a C++ modified ECMAScript grammar which is documented at
<https://en.cppreference.com/w/cpp/regex/ecmascript>. Note that '.*' will match all available ROIs and '^(?!xyz).*$'
will match all except 'xyz'.

Note that this parameter will match 'raw' contour labels.

##### Default

- ```".*"```

##### Examples

- ```".*"```
- ```".*body.*"```
- ```"body"```
- ```"^body$"```
- ```"Liver"```
- ```".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"```
- ```"left_parotid|right_parotid"```
- ```"^(?!left_parotid).*$"```

#### ROISelection

##### Description

Contours on the ReferenceImageSelection images that limit resampling. Select one or more contour regions of interest
(aka contour collection). Note that each region of interest may be comprised of multiple individual contours. Selection
specifiers can be of three types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth contour collections (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last contour
collections. Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the contour collections composed of the greatest and fewest number of contours. Only one or zero contour
collections will be selected; if there are ties, there is no guarantee which contour collections will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple contour collections based on a threshold count, i.e., where all
selected contour collections have more than or fewer than $N$ contours. Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all contour collections that do not have the greatest number of
contours, not the least-numerous contour collections (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"all"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### ContourOverlap

##### Description

Controls overlapping contours are treated. The default 'ignore' treats overlapping contours as a single contour,
regardless of contour orientation. This will effectively honour only the outermost contour regardless of orientation,
but provides the most predictable and consistent results. The option 'honour_opposite_orientations' makes overlapping
contours with opposite orientation cancel. Otherwise, orientation is ignored. This is useful for Boolean structures
where contour orientation is significant for interior contours (holes). If contours do not have consistent overlap
(e.g., if contours intersect) the results can be unpredictable and hard to interpret. The option
'overlapping_contours_cancel' ignores orientation and alternately cancerls all overlapping contours. Again, if the
contours do not have consistent overlap (e.g., if contours intersect) the results can be unpredictable and hard to
interpret.

##### Default

- ```"ignore"```

##### Supported Options

- ```"ignore"```
- ```"honour_opposite_orientations"```
- ```"overlapping_contours_cancel"```
- ```"honour_opps"```
- ```"overlap_cancel"```

#### Inclusivity

##### Description

Controls how voxels are deemed to be 'within' the interior of the selected ROI(s). The default 'center' considers only
the central-most point of each voxel. There are two corner options that correspond to a 2D projection of the voxel onto
the image plane. The first, 'planar_corner_inclusive', considers a voxel interior if ANY corner is interior. The second,
'planar_corner_exclusive', considers a voxel interior if ALL (four) corners are interior.

##### Default

- ```"center"```

##### Supported Options

- ```"center"```
- ```"centre"```
- ```"planar_corner_inclusive"```
- ```"planar_inc"```
- ```"planar_corner_exclusive"```
- ```"planar_exc"```

#### Channel

##### Description

The channel to use (zero-based). Setting to -1 will use each channel separately. Note that both images sets will share
this specifier.

##### Default

- ```"0"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"1"```
- ```"2"```


----------------------------------------------------

## WarpMeshes

### Tags

- accepts parameter: surface meshes
- category: mesh processing
- category: spatial transform processing

### Description

This operation applies a transform object to the specified surface meshes, warping them spatially.

### Notes

- A transform object must be selected; this operation cannot create transforms. Transforms can be generated via
  registration or by parsing user-provided functions.

- Meshes are transformed in-place. Metadata may become invalid by this operation.

- This operation can only handle individual transforms. If multiple, sequential transforms are required, this operation
  must be invoked multiple time. This will guarantee the ordering of the transforms.

- Transformations are not (generally) restricted to the coordinate frame of reference that they were derived from. This
  permits a single transformation to be applicable to point clouds, surface meshes, images, and contours.

### Parameters

- MeshSelection
- TransformSelection

#### MeshSelection

##### Description

Select one or more surface meshes. Note that a single surface mesh may hold many disconnected mesh components; they
should collectively represent a single logically cohesive object. Be aware that it is possible to mix logically
unrelated sub-meshes together in a single mesh. Selection specifiers can be of three types: positional, metadata-based
key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth surface mesh (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last surface mesh.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the surface mesh composed of the greatest and fewest number of elements (vertices + faces). Only one or zero
surface mesh will be selected; if there are ties, there is no guarantee which surface mesh will be selected. Use
'more-than(N)' or 'fewer-than(N)' to select multiple surface mesh based on a threshold count, i.e., where all selected
surface mesh have more than or fewer than $N$ elements (vertices + faces). Intrinsic specifiers can be inverted by
prefixing with a '!'. Note that '!numerous' means all surface mesh that do not have the greatest number of elements
(vertices + faces), not the least-numerous surface mesh (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TransformSelection

##### Description

Select one or more transform objects (aka 'warp' objects). Selection specifiers can be of three types: positional,
metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth transformation (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last transformation.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the transformation composed of the greatest and fewest number of sub-objects. Only one or zero transformation
will be selected; if there are ties, there is no guarantee which transformation will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple transformation based on a threshold count, i.e., where all selected transformation
have more than or fewer than $N$ sub-objects. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all transformation that do not have the greatest number of sub-objects, not the least-numerous
transformation (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```


----------------------------------------------------

## WarpPoints

### Tags

- accepts parameter: point clouds
- category: point cloud processing
- category: spatial transform processing

### Description

This operation applies a transform object to the specified point clouds, warping them spatially.

### Notes

- A transform object must be selected; this operation cannot create transforms. Transforms can be generated via
  registration or by parsing user-provided functions.

- Point clouds are transformed in-place. Metadata may become invalid by this operation.

- This operation can only handle individual transforms. If multiple, sequential transforms are required, this operation
  must be invoked multiple time. This will guarantee the ordering of the transforms.

- Transformations are not (generally) restricted to the coordinate frame of reference that they were derived from. This
  permits a single transformation to be applicable to point clouds, surface meshes, images, and contours.

### Parameters

- PointSelection
- TransformSelection

#### PointSelection

##### Description

The point cloud that will be transformed. Select one or more point clouds. Note that point clouds can hold a variety of
data with varying attributes, but each point cloud is meant to represent a single logically cohesive collection of
points. Be aware that it is possible to mix logically unrelated points together. Selection specifiers can be of three
types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth point cloud (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last point cloud.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the point cloud composed of the greatest and fewest number of vertices. Only one or zero point cloud will be
selected; if there are ties, there is no guarantee which point cloud will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple point cloud based on a threshold count, i.e., where all selected point cloud have
more than or fewer than $N$ vertices. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all point cloud that do not have the greatest number of vertices, not the least-numerous point cloud
(i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### TransformSelection

##### Description

The transformation that will be applied. Select one or more transform objects (aka 'warp' objects). Selection specifiers
can be of three types: positional, metadata-based key@value regex, and intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth transformation (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last transformation.
Positional specifiers can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the transformation composed of the greatest and fewest number of sub-objects. Only one or zero transformation
will be selected; if there are ties, there is no guarantee which transformation will be selected. Use 'more-than(N)' or
'fewer-than(N)' to select multiple transformation based on a threshold count, i.e., where all selected transformation
have more than or fewer than $N$ sub-objects. Intrinsic specifiers can be inverted by prefixing with a '!'. Note that
'!numerous' means all transformation that do not have the greatest number of sub-objects, not the least-numerous
transformation (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```


----------------------------------------------------

## While

### Tags

- category: control flow
- category: meta

### Description

This operation is a control flow meta-operation that repeatedly and sequentially invokes child operations (2-n) until
the first child operation completes successfully.

### Notes

- This operation evaluates the first child (the conditional) before evaluating any other children. So this operation
  represents a while-loop and not a do-while-loop.

- Each repeat is performed sequentially, and all side-effects are carried forward for each iteration. In particular, all
  selectors in child operations are evaluated lazily, at the moment when the child operation is invoked. If any
  non-conditional child operation does not complete successfully, it is treated as a 'break' statement and a true
  truthiness is returned.

### Parameters

- N

#### N

##### Description

The maximum number of times to loop. If the loop reaches this number of iterations, then this operation returns false
truthiness. If 'N' is negative or not provided, then looping will continue indefinitely.

##### Default

- ```"100"```

##### Examples

- ```"-1"```
- ```"0"```
- ```"5"```
- ```"10"```
- ```"1000"```


----------------------------------------------------

## WidenTable

### Tags

- accepts parameter: tables
- category: table processing

### Description

This operation reshapes tables, changing from 'long' to 'wide' by computing a self-intersection.

### Parameters

- TableSelection
- KeyColumns
- IgnoreRows

#### TableSelection

##### Description

Select one or more tables. Selection specifiers can be of three types: positional, metadata-based key@value regex, and
intrinsic.

Positional specifiers can be 'first', 'last', 'none', or 'all' literals. Additionally '#N' for some positive integer N
selects the Nth table (with zero-based indexing). Likewise, '#-N' selects the Nth-from-last table. Positional specifiers
can be inverted by prefixing with a '!'.

Metadata-based key@value expressions are applied by matching the keys verbatim and the values with regex. In order to
invert metadata-based selectors, the regex logic must be inverted (i.e., you can *not* prefix metadata-based selectors
with a '!'). Note regexes are case insensitive and should use extended POSIX syntax.

Intrinsic specifiers can be 'numerous', 'fewest', 'more-than(N)', and 'fewer-than(N)'. Literals 'numerous' and 'fewest'
select the table composed of the greatest and fewest number of rows. Only one or zero table will be selected; if there
are ties, there is no guarantee which table will be selected. Use 'more-than(N)' or 'fewer-than(N)' to select multiple
table based on a threshold count, i.e., where all selected table have more than or fewer than $N$ rows. Intrinsic
specifiers can be inverted by prefixing with a '!'. Note that '!numerous' means all table that do not have the greatest
number of rows, not the least-numerous table (i.e., 'fewest').

All criteria (positional, metadata, and intrinsic) can be mixed together. Multiple criteria can be specified by
separating them with a ';' and are applied in the order specified.

##### Default

- ```"last"```

##### Examples

- ```"last"```
- ```"first"```
- ```"all"```
- ```"none"```
- ```"#0"```
- ```"#-0"```
- ```"!last"```
- ```"!#-3"```
- ```"key@.*value.*"```
- ```"key1@.*value1.*;key2@^value2$;first"```
- ```"numerous"```
- ```"fewest"```
- ```"more-than(5)"```
- ```"!fewer-than(10)"```

#### KeyColumns

##### Description

A list of the columns to collectively use as a key. All rows with matching cell contents in these columns forms a group,
and the group is reshaped such that the first row is unaltered except subsequent rows are appended to the right. After
this operation, the distinct combinations of keys appearing in the specified columns will appear on only one row.

Multiple columns can be specified as a comma-separated list. Specifiers are intepretted as either column numbers (note:
zero-based), or regular expressions. Regular expressions will be applied to the entire table, and the column number of
any cell whose value matches will be added to the list.

Note that the relative order of rows is preserved, except instead of subsequent rows appearing *below* earlier rows,
they will now appear to the *right*.

##### Default

- ```""```

##### Examples

- ```"0"```
- ```"0,1"```
- ```"0,1,5,6"```
- ```"5,6,7"```
- ```"ROILabel,StudyDate,.*Date.*"```

#### IgnoreRows

##### Description

A list of rows to ignore. For example: rows containing headers, or cells that should not be appended.

Multiple rows can be specified as a comma-separated list. Specifiers are intepretted as either row numbers (note:
zero-based), or regular expressions. Regular expressions will be applied to the entire table, and the row number of any
cell whose value matches will be added to the list.

Note that while ignored rows will not participate in the reshaping process, their row numbers may be altered due to
reshaped rows being removed. The relative order will not be altered.

##### Default

- ```""```

##### Examples

- ```"0"```
- ```"0,1"```
- ```"0,1,5,6"```
- ```"5,6,7"```
- ```"ROILabel,StudyDate,.*Date.*"```


# Known Issues and Limitations

## Hanging on Debian

The SFML_Viewer operation hangs on some systems after viewing a plot with Gnuplot. This stems from a known issue in
Ygor.

## Build Requirements

DICOMautomaton depends on several heavily templated libraries and external projects. It requires a considerable amount
of memory to build.

