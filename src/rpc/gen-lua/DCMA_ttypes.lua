--
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
-- @generated
--


require 'Thrift'
require 'DCMA_constants'

vec3_double = __TObject:new{
  x,
  y,
  z
}

function vec3_double:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.DOUBLE then
        self.x = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.DOUBLE then
        self.y = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.DOUBLE then
        self.z = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function vec3_double:write(oprot)
  oprot:writeStructBegin('vec3_double')
  if self.x ~= nil then
    oprot:writeFieldBegin('x', TType.DOUBLE, 1)
    oprot:writeDouble(self.x)
    oprot:writeFieldEnd()
  end
  if self.y ~= nil then
    oprot:writeFieldBegin('y', TType.DOUBLE, 2)
    oprot:writeDouble(self.y)
    oprot:writeFieldEnd()
  end
  if self.z ~= nil then
    oprot:writeFieldBegin('z', TType.DOUBLE, 3)
    oprot:writeDouble(self.z)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

contour_of_points_double = __TObject:new{
  points,
  closed,
  metadata
}

function contour_of_points_double:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.points = {}
        local _etype3, _size0 = iprot:readListBegin()
        for _i=1,_size0 do
          local _elem4 = vec3_double:new{}
          _elem4:read(iprot)
          table.insert(self.points, _elem4)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.BOOL then
        self.closed = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.MAP then
        self.metadata = {}
        local _ktype6, _vtype7, _size5 = iprot:readMapBegin() 
        for _i=1,_size5 do
          local _key9 = iprot:readString()
          local _val10 = iprot:readString()
          self.metadata[_key9] = _val10
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function contour_of_points_double:write(oprot)
  oprot:writeStructBegin('contour_of_points_double')
  if self.points ~= nil then
    oprot:writeFieldBegin('points', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.points)
    for _,iter11 in ipairs(self.points) do
      iter11:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.closed ~= nil then
    oprot:writeFieldBegin('closed', TType.BOOL, 2)
    oprot:writeBool(self.closed)
    oprot:writeFieldEnd()
  end
  if self.metadata ~= nil then
    oprot:writeFieldBegin('metadata', TType.MAP, 3)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.metadata))
    for kiter12,viter13 in pairs(self.metadata) do
      oprot:writeString(kiter12)
      oprot:writeString(viter13)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

contour_collection_double = __TObject:new{
  contours
}

function contour_collection_double:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.contours = {}
        local _etype17, _size14 = iprot:readListBegin()
        for _i=1,_size14 do
          local _elem18 = contour_of_points_double:new{}
          _elem18:read(iprot)
          table.insert(self.contours, _elem18)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function contour_collection_double:write(oprot)
  oprot:writeStructBegin('contour_collection_double')
  if self.contours ~= nil then
    oprot:writeFieldBegin('contours', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.contours)
    for _,iter19 in ipairs(self.contours) do
      iter19:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

point_set_double = __TObject:new{
  points,
  normals,
  colours,
  metadata
}

function point_set_double:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.points = {}
        local _etype23, _size20 = iprot:readListBegin()
        for _i=1,_size20 do
          local _elem24 = vec3_double:new{}
          _elem24:read(iprot)
          table.insert(self.points, _elem24)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.normals = {}
        local _etype28, _size25 = iprot:readListBegin()
        for _i=1,_size25 do
          local _elem29 = vec3_double:new{}
          _elem29:read(iprot)
          table.insert(self.normals, _elem29)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.colours = {}
        local _etype33, _size30 = iprot:readListBegin()
        for _i=1,_size30 do
          local _elem34 = iprot:readI64()
          table.insert(self.colours, _elem34)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.MAP then
        self.metadata = {}
        local _ktype36, _vtype37, _size35 = iprot:readMapBegin() 
        for _i=1,_size35 do
          local _key39 = iprot:readString()
          local _val40 = iprot:readString()
          self.metadata[_key39] = _val40
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function point_set_double:write(oprot)
  oprot:writeStructBegin('point_set_double')
  if self.points ~= nil then
    oprot:writeFieldBegin('points', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.points)
    for _,iter41 in ipairs(self.points) do
      iter41:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.normals ~= nil then
    oprot:writeFieldBegin('normals', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.normals)
    for _,iter42 in ipairs(self.normals) do
      iter42:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.colours ~= nil then
    oprot:writeFieldBegin('colours', TType.LIST, 3)
    oprot:writeListBegin(TType.I64, #self.colours)
    for _,iter43 in ipairs(self.colours) do
      oprot:writeI64(iter43)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.metadata ~= nil then
    oprot:writeFieldBegin('metadata', TType.MAP, 4)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.metadata))
    for kiter44,viter45 in pairs(self.metadata) do
      oprot:writeString(kiter44)
      oprot:writeString(viter45)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sample4_double = __TObject:new{
  x,
  sigma_x,
  f,
  sigma_f
}

function sample4_double:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.DOUBLE then
        self.x = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.DOUBLE then
        self.sigma_x = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.DOUBLE then
        self.f = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.DOUBLE then
        self.sigma_f = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sample4_double:write(oprot)
  oprot:writeStructBegin('sample4_double')
  if self.x ~= nil then
    oprot:writeFieldBegin('x', TType.DOUBLE, 1)
    oprot:writeDouble(self.x)
    oprot:writeFieldEnd()
  end
  if self.sigma_x ~= nil then
    oprot:writeFieldBegin('sigma_x', TType.DOUBLE, 2)
    oprot:writeDouble(self.sigma_x)
    oprot:writeFieldEnd()
  end
  if self.f ~= nil then
    oprot:writeFieldBegin('f', TType.DOUBLE, 3)
    oprot:writeDouble(self.f)
    oprot:writeFieldEnd()
  end
  if self.sigma_f ~= nil then
    oprot:writeFieldBegin('sigma_f', TType.DOUBLE, 4)
    oprot:writeDouble(self.sigma_f)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

samples_1D_double = __TObject:new{
  samples,
  uncertainties_known_to_be_independent_and_random,
  metadata
}

function samples_1D_double:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.samples = {}
        local _etype49, _size46 = iprot:readListBegin()
        for _i=1,_size46 do
          local _elem50 = sample4_double:new{}
          _elem50:read(iprot)
          table.insert(self.samples, _elem50)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.BOOL then
        self.uncertainties_known_to_be_independent_and_random = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.MAP then
        self.metadata = {}
        local _ktype52, _vtype53, _size51 = iprot:readMapBegin() 
        for _i=1,_size51 do
          local _key55 = iprot:readString()
          local _val56 = iprot:readString()
          self.metadata[_key55] = _val56
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function samples_1D_double:write(oprot)
  oprot:writeStructBegin('samples_1D_double')
  if self.samples ~= nil then
    oprot:writeFieldBegin('samples', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.samples)
    for _,iter57 in ipairs(self.samples) do
      iter57:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.uncertainties_known_to_be_independent_and_random ~= nil then
    oprot:writeFieldBegin('uncertainties_known_to_be_independent_and_random', TType.BOOL, 2)
    oprot:writeBool(self.uncertainties_known_to_be_independent_and_random)
    oprot:writeFieldEnd()
  end
  if self.metadata ~= nil then
    oprot:writeFieldBegin('metadata', TType.MAP, 3)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.metadata))
    for kiter58,viter59 in pairs(self.metadata) do
      oprot:writeString(kiter58)
      oprot:writeString(viter59)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fv_surface_mesh_double_int64 = __TObject:new{
  vertices,
  vertex_normals,
  vertex_colours,
  faces,
  involved_faces,
  metadata
}

function fv_surface_mesh_double_int64:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.vertices = {}
        local _etype63, _size60 = iprot:readListBegin()
        for _i=1,_size60 do
          local _elem64 = vec3_double:new{}
          _elem64:read(iprot)
          table.insert(self.vertices, _elem64)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.vertex_normals = {}
        local _etype68, _size65 = iprot:readListBegin()
        for _i=1,_size65 do
          local _elem69 = vec3_double:new{}
          _elem69:read(iprot)
          table.insert(self.vertex_normals, _elem69)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.vertex_colours = {}
        local _etype73, _size70 = iprot:readListBegin()
        for _i=1,_size70 do
          local _elem74 = iprot:readI64()
          table.insert(self.vertex_colours, _elem74)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.LIST then
        self.faces = {}
        local _etype78, _size75 = iprot:readListBegin()
        for _i=1,_size75 do
          local _elem79 = {}
          local _etype83, _size80 = iprot:readListBegin()
          for _i=1,_size80 do
            local _elem84 = iprot:readI64()
            table.insert(_elem79, _elem84)
          end
          iprot:readListEnd()
          table.insert(self.faces, _elem79)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.LIST then
        self.involved_faces = {}
        local _etype88, _size85 = iprot:readListBegin()
        for _i=1,_size85 do
          local _elem89 = {}
          local _etype93, _size90 = iprot:readListBegin()
          for _i=1,_size90 do
            local _elem94 = iprot:readI64()
            table.insert(_elem89, _elem94)
          end
          iprot:readListEnd()
          table.insert(self.involved_faces, _elem89)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.MAP then
        self.metadata = {}
        local _ktype96, _vtype97, _size95 = iprot:readMapBegin() 
        for _i=1,_size95 do
          local _key99 = iprot:readString()
          local _val100 = iprot:readString()
          self.metadata[_key99] = _val100
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fv_surface_mesh_double_int64:write(oprot)
  oprot:writeStructBegin('fv_surface_mesh_double_int64')
  if self.vertices ~= nil then
    oprot:writeFieldBegin('vertices', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.vertices)
    for _,iter101 in ipairs(self.vertices) do
      iter101:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.vertex_normals ~= nil then
    oprot:writeFieldBegin('vertex_normals', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.vertex_normals)
    for _,iter102 in ipairs(self.vertex_normals) do
      iter102:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.vertex_colours ~= nil then
    oprot:writeFieldBegin('vertex_colours', TType.LIST, 3)
    oprot:writeListBegin(TType.I64, #self.vertex_colours)
    for _,iter103 in ipairs(self.vertex_colours) do
      oprot:writeI64(iter103)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.faces ~= nil then
    oprot:writeFieldBegin('faces', TType.LIST, 4)
    oprot:writeListBegin(TType.LIST, #self.faces)
    for _,iter104 in ipairs(self.faces) do
      oprot:writeListBegin(TType.I64, #iter104)
      for _,iter105 in ipairs(iter104) do
        oprot:writeI64(iter105)
      end
      oprot:writeListEnd()
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.involved_faces ~= nil then
    oprot:writeFieldBegin('involved_faces', TType.LIST, 5)
    oprot:writeListBegin(TType.LIST, #self.involved_faces)
    for _,iter106 in ipairs(self.involved_faces) do
      oprot:writeListBegin(TType.I64, #iter106)
      for _,iter107 in ipairs(iter106) do
        oprot:writeI64(iter107)
      end
      oprot:writeListEnd()
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.metadata ~= nil then
    oprot:writeFieldBegin('metadata', TType.MAP, 6)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.metadata))
    for kiter108,viter109 in pairs(self.metadata) do
      oprot:writeString(kiter108)
      oprot:writeString(viter109)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

planar_image_double_double = __TObject:new{
  data,
  rows,
  columns,
  channels,
  pxl_dx,
  pxl_dy,
  pxl_dz,
  anchor,
  offset,
  row_unit,
  col_unit,
  metadata
}

function planar_image_double_double:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.data = {}
        local _etype113, _size110 = iprot:readListBegin()
        for _i=1,_size110 do
          local _elem114 = iprot:readDouble()
          table.insert(self.data, _elem114)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.rows = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.columns = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I64 then
        self.channels = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.DOUBLE then
        self.pxl_dx = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.DOUBLE then
        self.pxl_dy = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.DOUBLE then
        self.pxl_dz = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.STRUCT then
        self.anchor = vec3_double:new{}
        self.anchor:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.STRUCT then
        self.offset = vec3_double:new{}
        self.offset:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 10 then
      if ftype == TType.STRUCT then
        self.row_unit = vec3_double:new{}
        self.row_unit:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 11 then
      if ftype == TType.STRUCT then
        self.col_unit = vec3_double:new{}
        self.col_unit:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 12 then
      if ftype == TType.MAP then
        self.metadata = {}
        local _ktype116, _vtype117, _size115 = iprot:readMapBegin() 
        for _i=1,_size115 do
          local _key119 = iprot:readString()
          local _val120 = iprot:readString()
          self.metadata[_key119] = _val120
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function planar_image_double_double:write(oprot)
  oprot:writeStructBegin('planar_image_double_double')
  if self.data ~= nil then
    oprot:writeFieldBegin('data', TType.LIST, 1)
    oprot:writeListBegin(TType.DOUBLE, #self.data)
    for _,iter121 in ipairs(self.data) do
      oprot:writeDouble(iter121)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.rows ~= nil then
    oprot:writeFieldBegin('rows', TType.I64, 2)
    oprot:writeI64(self.rows)
    oprot:writeFieldEnd()
  end
  if self.columns ~= nil then
    oprot:writeFieldBegin('columns', TType.I64, 3)
    oprot:writeI64(self.columns)
    oprot:writeFieldEnd()
  end
  if self.channels ~= nil then
    oprot:writeFieldBegin('channels', TType.I64, 4)
    oprot:writeI64(self.channels)
    oprot:writeFieldEnd()
  end
  if self.pxl_dx ~= nil then
    oprot:writeFieldBegin('pxl_dx', TType.DOUBLE, 5)
    oprot:writeDouble(self.pxl_dx)
    oprot:writeFieldEnd()
  end
  if self.pxl_dy ~= nil then
    oprot:writeFieldBegin('pxl_dy', TType.DOUBLE, 6)
    oprot:writeDouble(self.pxl_dy)
    oprot:writeFieldEnd()
  end
  if self.pxl_dz ~= nil then
    oprot:writeFieldBegin('pxl_dz', TType.DOUBLE, 7)
    oprot:writeDouble(self.pxl_dz)
    oprot:writeFieldEnd()
  end
  if self.anchor ~= nil then
    oprot:writeFieldBegin('anchor', TType.STRUCT, 8)
    self.anchor:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.offset ~= nil then
    oprot:writeFieldBegin('offset', TType.STRUCT, 9)
    self.offset:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.row_unit ~= nil then
    oprot:writeFieldBegin('row_unit', TType.STRUCT, 10)
    self.row_unit:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.col_unit ~= nil then
    oprot:writeFieldBegin('col_unit', TType.STRUCT, 11)
    self.col_unit:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.metadata ~= nil then
    oprot:writeFieldBegin('metadata', TType.MAP, 12)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.metadata))
    for kiter122,viter123 in pairs(self.metadata) do
      oprot:writeString(kiter122)
      oprot:writeString(viter123)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

planar_image_collection_double_double = __TObject:new{
  images
}

function planar_image_collection_double_double:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.images = {}
        local _etype127, _size124 = iprot:readListBegin()
        for _i=1,_size124 do
          local _elem128 = planar_image_double_double:new{}
          _elem128:read(iprot)
          table.insert(self.images, _elem128)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function planar_image_collection_double_double:write(oprot)
  oprot:writeStructBegin('planar_image_collection_double_double')
  if self.images ~= nil then
    oprot:writeFieldBegin('images', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.images)
    for _,iter129 in ipairs(self.images) do
      iter129:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

cell_string = __TObject:new{

}

function cell_string:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function cell_string:write(oprot)
  oprot:writeStructBegin('cell_string')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

table2 = __TObject:new{

}

function table2:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function table2:write(oprot)
  oprot:writeStructBegin('table2')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Contour_Data = __TObject:new{
  ccs
}

function Contour_Data:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.ccs = {}
        local _etype133, _size130 = iprot:readListBegin()
        for _i=1,_size130 do
          local _elem134 = contour_collection_double:new{}
          _elem134:read(iprot)
          table.insert(self.ccs, _elem134)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Contour_Data:write(oprot)
  oprot:writeStructBegin('Contour_Data')
  if self.ccs ~= nil then
    oprot:writeFieldBegin('ccs', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.ccs)
    for _,iter135 in ipairs(self.ccs) do
      iter135:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Image_Array = __TObject:new{
  imagecoll,
  filename
}

function Image_Array:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.imagecoll = planar_image_collection_double_double:new{}
        self.imagecoll:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.filename = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Image_Array:write(oprot)
  oprot:writeStructBegin('Image_Array')
  if self.imagecoll ~= nil then
    oprot:writeFieldBegin('imagecoll', TType.STRUCT, 1)
    self.imagecoll:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.filename ~= nil then
    oprot:writeFieldBegin('filename', TType.STRING, 2)
    oprot:writeString(self.filename)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Point_Cloud = __TObject:new{
  pset
}

function Point_Cloud:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.pset = point_set_double:new{}
        self.pset:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Point_Cloud:write(oprot)
  oprot:writeStructBegin('Point_Cloud')
  if self.pset ~= nil then
    oprot:writeFieldBegin('pset', TType.STRUCT, 1)
    self.pset:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Surface_Mesh = __TObject:new{
  meshes
}

function Surface_Mesh:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.meshes = fv_surface_mesh_double_int64:new{}
        self.meshes:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Surface_Mesh:write(oprot)
  oprot:writeStructBegin('Surface_Mesh')
  if self.meshes ~= nil then
    oprot:writeFieldBegin('meshes', TType.STRUCT, 1)
    self.meshes:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Static_Machine_State = __TObject:new{
  CumulativeMetersetWeight,
  ControlPointIndex,
  GantryAngle,
  GantryRotationDirection,
  BeamLimitingDeviceAngle,
  BeamLimitingDeviceRotationDirection,
  PatientSupportAngle,
  PatientSupportRotationDirection,
  TableTopEccentricAngle,
  TableTopEccentricRotationDirection,
  TableTopVerticalPosition,
  TableTopLongitudinalPosition,
  TableTopLateralPosition,
  TableTopPitchAngle,
  TableTopPitchRotationDirection,
  TableTopRollAngle,
  TableTopRollRotationDirection,
  IsocentrePosition,
  JawPositionsX,
  JawPositionsY,
  MLCPositionsX,
  metadata
}

function Static_Machine_State:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.DOUBLE then
        self.CumulativeMetersetWeight = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.ControlPointIndex = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.DOUBLE then
        self.GantryAngle = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.DOUBLE then
        self.GantryRotationDirection = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.DOUBLE then
        self.BeamLimitingDeviceAngle = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.DOUBLE then
        self.BeamLimitingDeviceRotationDirection = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.DOUBLE then
        self.PatientSupportAngle = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.DOUBLE then
        self.PatientSupportRotationDirection = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.DOUBLE then
        self.TableTopEccentricAngle = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 10 then
      if ftype == TType.DOUBLE then
        self.TableTopEccentricRotationDirection = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 11 then
      if ftype == TType.DOUBLE then
        self.TableTopVerticalPosition = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 12 then
      if ftype == TType.DOUBLE then
        self.TableTopLongitudinalPosition = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 13 then
      if ftype == TType.DOUBLE then
        self.TableTopLateralPosition = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 14 then
      if ftype == TType.DOUBLE then
        self.TableTopPitchAngle = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 15 then
      if ftype == TType.DOUBLE then
        self.TableTopPitchRotationDirection = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 16 then
      if ftype == TType.DOUBLE then
        self.TableTopRollAngle = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 17 then
      if ftype == TType.DOUBLE then
        self.TableTopRollRotationDirection = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 18 then
      if ftype == TType.STRUCT then
        self.IsocentrePosition = vec3_double:new{}
        self.IsocentrePosition:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 19 then
      if ftype == TType.LIST then
        self.JawPositionsX = {}
        local _etype139, _size136 = iprot:readListBegin()
        for _i=1,_size136 do
          local _elem140 = iprot:readDouble()
          table.insert(self.JawPositionsX, _elem140)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 20 then
      if ftype == TType.LIST then
        self.JawPositionsY = {}
        local _etype144, _size141 = iprot:readListBegin()
        for _i=1,_size141 do
          local _elem145 = iprot:readDouble()
          table.insert(self.JawPositionsY, _elem145)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 21 then
      if ftype == TType.LIST then
        self.MLCPositionsX = {}
        local _etype149, _size146 = iprot:readListBegin()
        for _i=1,_size146 do
          local _elem150 = iprot:readDouble()
          table.insert(self.MLCPositionsX, _elem150)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 22 then
      if ftype == TType.MAP then
        self.metadata = {}
        local _ktype152, _vtype153, _size151 = iprot:readMapBegin() 
        for _i=1,_size151 do
          local _key155 = iprot:readString()
          local _val156 = iprot:readString()
          self.metadata[_key155] = _val156
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Static_Machine_State:write(oprot)
  oprot:writeStructBegin('Static_Machine_State')
  if self.CumulativeMetersetWeight ~= nil then
    oprot:writeFieldBegin('CumulativeMetersetWeight', TType.DOUBLE, 1)
    oprot:writeDouble(self.CumulativeMetersetWeight)
    oprot:writeFieldEnd()
  end
  if self.ControlPointIndex ~= nil then
    oprot:writeFieldBegin('ControlPointIndex', TType.I64, 2)
    oprot:writeI64(self.ControlPointIndex)
    oprot:writeFieldEnd()
  end
  if self.GantryAngle ~= nil then
    oprot:writeFieldBegin('GantryAngle', TType.DOUBLE, 3)
    oprot:writeDouble(self.GantryAngle)
    oprot:writeFieldEnd()
  end
  if self.GantryRotationDirection ~= nil then
    oprot:writeFieldBegin('GantryRotationDirection', TType.DOUBLE, 4)
    oprot:writeDouble(self.GantryRotationDirection)
    oprot:writeFieldEnd()
  end
  if self.BeamLimitingDeviceAngle ~= nil then
    oprot:writeFieldBegin('BeamLimitingDeviceAngle', TType.DOUBLE, 5)
    oprot:writeDouble(self.BeamLimitingDeviceAngle)
    oprot:writeFieldEnd()
  end
  if self.BeamLimitingDeviceRotationDirection ~= nil then
    oprot:writeFieldBegin('BeamLimitingDeviceRotationDirection', TType.DOUBLE, 6)
    oprot:writeDouble(self.BeamLimitingDeviceRotationDirection)
    oprot:writeFieldEnd()
  end
  if self.PatientSupportAngle ~= nil then
    oprot:writeFieldBegin('PatientSupportAngle', TType.DOUBLE, 7)
    oprot:writeDouble(self.PatientSupportAngle)
    oprot:writeFieldEnd()
  end
  if self.PatientSupportRotationDirection ~= nil then
    oprot:writeFieldBegin('PatientSupportRotationDirection', TType.DOUBLE, 8)
    oprot:writeDouble(self.PatientSupportRotationDirection)
    oprot:writeFieldEnd()
  end
  if self.TableTopEccentricAngle ~= nil then
    oprot:writeFieldBegin('TableTopEccentricAngle', TType.DOUBLE, 9)
    oprot:writeDouble(self.TableTopEccentricAngle)
    oprot:writeFieldEnd()
  end
  if self.TableTopEccentricRotationDirection ~= nil then
    oprot:writeFieldBegin('TableTopEccentricRotationDirection', TType.DOUBLE, 10)
    oprot:writeDouble(self.TableTopEccentricRotationDirection)
    oprot:writeFieldEnd()
  end
  if self.TableTopVerticalPosition ~= nil then
    oprot:writeFieldBegin('TableTopVerticalPosition', TType.DOUBLE, 11)
    oprot:writeDouble(self.TableTopVerticalPosition)
    oprot:writeFieldEnd()
  end
  if self.TableTopLongitudinalPosition ~= nil then
    oprot:writeFieldBegin('TableTopLongitudinalPosition', TType.DOUBLE, 12)
    oprot:writeDouble(self.TableTopLongitudinalPosition)
    oprot:writeFieldEnd()
  end
  if self.TableTopLateralPosition ~= nil then
    oprot:writeFieldBegin('TableTopLateralPosition', TType.DOUBLE, 13)
    oprot:writeDouble(self.TableTopLateralPosition)
    oprot:writeFieldEnd()
  end
  if self.TableTopPitchAngle ~= nil then
    oprot:writeFieldBegin('TableTopPitchAngle', TType.DOUBLE, 14)
    oprot:writeDouble(self.TableTopPitchAngle)
    oprot:writeFieldEnd()
  end
  if self.TableTopPitchRotationDirection ~= nil then
    oprot:writeFieldBegin('TableTopPitchRotationDirection', TType.DOUBLE, 15)
    oprot:writeDouble(self.TableTopPitchRotationDirection)
    oprot:writeFieldEnd()
  end
  if self.TableTopRollAngle ~= nil then
    oprot:writeFieldBegin('TableTopRollAngle', TType.DOUBLE, 16)
    oprot:writeDouble(self.TableTopRollAngle)
    oprot:writeFieldEnd()
  end
  if self.TableTopRollRotationDirection ~= nil then
    oprot:writeFieldBegin('TableTopRollRotationDirection', TType.DOUBLE, 17)
    oprot:writeDouble(self.TableTopRollRotationDirection)
    oprot:writeFieldEnd()
  end
  if self.IsocentrePosition ~= nil then
    oprot:writeFieldBegin('IsocentrePosition', TType.STRUCT, 18)
    self.IsocentrePosition:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.JawPositionsX ~= nil then
    oprot:writeFieldBegin('JawPositionsX', TType.LIST, 19)
    oprot:writeListBegin(TType.DOUBLE, #self.JawPositionsX)
    for _,iter157 in ipairs(self.JawPositionsX) do
      oprot:writeDouble(iter157)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.JawPositionsY ~= nil then
    oprot:writeFieldBegin('JawPositionsY', TType.LIST, 20)
    oprot:writeListBegin(TType.DOUBLE, #self.JawPositionsY)
    for _,iter158 in ipairs(self.JawPositionsY) do
      oprot:writeDouble(iter158)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.MLCPositionsX ~= nil then
    oprot:writeFieldBegin('MLCPositionsX', TType.LIST, 21)
    oprot:writeListBegin(TType.DOUBLE, #self.MLCPositionsX)
    for _,iter159 in ipairs(self.MLCPositionsX) do
      oprot:writeDouble(iter159)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.metadata ~= nil then
    oprot:writeFieldBegin('metadata', TType.MAP, 22)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.metadata))
    for kiter160,viter161 in pairs(self.metadata) do
      oprot:writeString(kiter160)
      oprot:writeString(viter161)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Dynamic_Machine_State = __TObject:new{
  BeamNumber,
  FinalCumulativeMetersetWeight,
  static_states,
  metadata
}

function Dynamic_Machine_State:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I64 then
        self.BeamNumber = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.DOUBLE then
        self.FinalCumulativeMetersetWeight = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.static_states = {}
        local _etype165, _size162 = iprot:readListBegin()
        for _i=1,_size162 do
          local _elem166 = Static_Machine_State:new{}
          _elem166:read(iprot)
          table.insert(self.static_states, _elem166)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.MAP then
        self.metadata = {}
        local _ktype168, _vtype169, _size167 = iprot:readMapBegin() 
        for _i=1,_size167 do
          local _key171 = iprot:readString()
          local _val172 = iprot:readString()
          self.metadata[_key171] = _val172
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Dynamic_Machine_State:write(oprot)
  oprot:writeStructBegin('Dynamic_Machine_State')
  if self.BeamNumber ~= nil then
    oprot:writeFieldBegin('BeamNumber', TType.I64, 1)
    oprot:writeI64(self.BeamNumber)
    oprot:writeFieldEnd()
  end
  if self.FinalCumulativeMetersetWeight ~= nil then
    oprot:writeFieldBegin('FinalCumulativeMetersetWeight', TType.DOUBLE, 2)
    oprot:writeDouble(self.FinalCumulativeMetersetWeight)
    oprot:writeFieldEnd()
  end
  if self.static_states ~= nil then
    oprot:writeFieldBegin('static_states', TType.LIST, 3)
    oprot:writeListBegin(TType.STRUCT, #self.static_states)
    for _,iter173 in ipairs(self.static_states) do
      iter173:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.metadata ~= nil then
    oprot:writeFieldBegin('metadata', TType.MAP, 4)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.metadata))
    for kiter174,viter175 in pairs(self.metadata) do
      oprot:writeString(kiter174)
      oprot:writeString(viter175)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

RTPlan = __TObject:new{
  dynamic_states,
  metadata
}

function RTPlan:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.dynamic_states = {}
        local _etype179, _size176 = iprot:readListBegin()
        for _i=1,_size176 do
          local _elem180 = Dynamic_Machine_State:new{}
          _elem180:read(iprot)
          table.insert(self.dynamic_states, _elem180)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.MAP then
        self.metadata = {}
        local _ktype182, _vtype183, _size181 = iprot:readMapBegin() 
        for _i=1,_size181 do
          local _key185 = iprot:readString()
          local _val186 = iprot:readString()
          self.metadata[_key185] = _val186
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function RTPlan:write(oprot)
  oprot:writeStructBegin('RTPlan')
  if self.dynamic_states ~= nil then
    oprot:writeFieldBegin('dynamic_states', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.dynamic_states)
    for _,iter187 in ipairs(self.dynamic_states) do
      iter187:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.metadata ~= nil then
    oprot:writeFieldBegin('metadata', TType.MAP, 2)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.metadata))
    for kiter188,viter189 in pairs(self.metadata) do
      oprot:writeString(kiter188)
      oprot:writeString(viter189)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Line_Sample = __TObject:new{
  line
}

function Line_Sample:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.line = samples_1D_double:new{}
        self.line:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Line_Sample:write(oprot)
  oprot:writeStructBegin('Line_Sample')
  if self.line ~= nil then
    oprot:writeFieldBegin('line', TType.STRUCT, 1)
    self.line:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Transform3 = __TObject:new{

}

function Transform3:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Transform3:write(oprot)
  oprot:writeStructBegin('Transform3')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Sparse_Table = __TObject:new{
  table
}

function Sparse_Table:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.table = table2:new{}
        self.table:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Sparse_Table:write(oprot)
  oprot:writeStructBegin('Sparse_Table')
  if self.table ~= nil then
    oprot:writeFieldBegin('table', TType.STRUCT, 1)
    self.table:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Drover = __TObject:new{
  contour_data,
  image_data,
  point_data,
  smesh_data,
  rtplan_data,
  lsamp_data,
  trans_data,
  table_data
}

function Drover:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.contour_data = {}
        local _etype193, _size190 = iprot:readListBegin()
        for _i=1,_size190 do
          local _elem194 = Contour_Data:new{}
          _elem194:read(iprot)
          table.insert(self.contour_data, _elem194)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.image_data = {}
        local _etype198, _size195 = iprot:readListBegin()
        for _i=1,_size195 do
          local _elem199 = Image_Array:new{}
          _elem199:read(iprot)
          table.insert(self.image_data, _elem199)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.point_data = {}
        local _etype203, _size200 = iprot:readListBegin()
        for _i=1,_size200 do
          local _elem204 = Point_Cloud:new{}
          _elem204:read(iprot)
          table.insert(self.point_data, _elem204)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.LIST then
        self.smesh_data = {}
        local _etype208, _size205 = iprot:readListBegin()
        for _i=1,_size205 do
          local _elem209 = Surface_Mesh:new{}
          _elem209:read(iprot)
          table.insert(self.smesh_data, _elem209)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.LIST then
        self.rtplan_data = {}
        local _etype213, _size210 = iprot:readListBegin()
        for _i=1,_size210 do
          local _elem214 = RTPlan:new{}
          _elem214:read(iprot)
          table.insert(self.rtplan_data, _elem214)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.LIST then
        self.lsamp_data = {}
        local _etype218, _size215 = iprot:readListBegin()
        for _i=1,_size215 do
          local _elem219 = Line_Sample:new{}
          _elem219:read(iprot)
          table.insert(self.lsamp_data, _elem219)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.LIST then
        self.trans_data = {}
        local _etype223, _size220 = iprot:readListBegin()
        for _i=1,_size220 do
          local _elem224 = Transform3:new{}
          _elem224:read(iprot)
          table.insert(self.trans_data, _elem224)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.LIST then
        self.table_data = {}
        local _etype228, _size225 = iprot:readListBegin()
        for _i=1,_size225 do
          local _elem229 = Sparse_Table:new{}
          _elem229:read(iprot)
          table.insert(self.table_data, _elem229)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Drover:write(oprot)
  oprot:writeStructBegin('Drover')
  if self.contour_data ~= nil then
    oprot:writeFieldBegin('contour_data', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.contour_data)
    for _,iter230 in ipairs(self.contour_data) do
      iter230:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.image_data ~= nil then
    oprot:writeFieldBegin('image_data', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.image_data)
    for _,iter231 in ipairs(self.image_data) do
      iter231:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.point_data ~= nil then
    oprot:writeFieldBegin('point_data', TType.LIST, 3)
    oprot:writeListBegin(TType.STRUCT, #self.point_data)
    for _,iter232 in ipairs(self.point_data) do
      iter232:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.smesh_data ~= nil then
    oprot:writeFieldBegin('smesh_data', TType.LIST, 4)
    oprot:writeListBegin(TType.STRUCT, #self.smesh_data)
    for _,iter233 in ipairs(self.smesh_data) do
      iter233:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.rtplan_data ~= nil then
    oprot:writeFieldBegin('rtplan_data', TType.LIST, 5)
    oprot:writeListBegin(TType.STRUCT, #self.rtplan_data)
    for _,iter234 in ipairs(self.rtplan_data) do
      iter234:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.lsamp_data ~= nil then
    oprot:writeFieldBegin('lsamp_data', TType.LIST, 6)
    oprot:writeListBegin(TType.STRUCT, #self.lsamp_data)
    for _,iter235 in ipairs(self.lsamp_data) do
      iter235:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.trans_data ~= nil then
    oprot:writeFieldBegin('trans_data', TType.LIST, 7)
    oprot:writeListBegin(TType.STRUCT, #self.trans_data)
    for _,iter236 in ipairs(self.trans_data) do
      iter236:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.table_data ~= nil then
    oprot:writeFieldBegin('table_data', TType.LIST, 8)
    oprot:writeListBegin(TType.STRUCT, #self.table_data)
    for _,iter237 in ipairs(self.table_data) do
      iter237:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

OperationsQuery = __TObject:new{

}

function OperationsQuery:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function OperationsQuery:write(oprot)
  oprot:writeStructBegin('OperationsQuery')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

KnownOperation = __TObject:new{
  name
}

function KnownOperation:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.name = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function KnownOperation:write(oprot)
  oprot:writeStructBegin('KnownOperation')
  if self.name ~= nil then
    oprot:writeFieldBegin('name', TType.STRING, 1)
    oprot:writeString(self.name)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

LoadFilesQuery = __TObject:new{
  server_filename
}

function LoadFilesQuery:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.server_filename = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function LoadFilesQuery:write(oprot)
  oprot:writeStructBegin('LoadFilesQuery')
  if self.server_filename ~= nil then
    oprot:writeFieldBegin('server_filename', TType.STRING, 1)
    oprot:writeString(self.server_filename)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

LoadFilesResponse = __TObject:new{
  success,
  drover
}

function LoadFilesResponse:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.BOOL then
        self.success = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.drover = Drover:new{}
        self.drover:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function LoadFilesResponse:write(oprot)
  oprot:writeStructBegin('LoadFilesResponse')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.BOOL, 1)
    oprot:writeBool(self.success)
    oprot:writeFieldEnd()
  end
  if self.drover ~= nil then
    oprot:writeFieldBegin('drover', TType.STRUCT, 2)
    self.drover:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

ExecuteScriptQuery = __TObject:new{
  drover,
  invocation_metadata,
  filename_lex
}

function ExecuteScriptQuery:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.drover = Drover:new{}
        self.drover:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.MAP then
        self.invocation_metadata = {}
        local _ktype239, _vtype240, _size238 = iprot:readMapBegin() 
        for _i=1,_size238 do
          local _key242 = iprot:readString()
          local _val243 = iprot:readString()
          self.invocation_metadata[_key242] = _val243
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.filename_lex = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function ExecuteScriptQuery:write(oprot)
  oprot:writeStructBegin('ExecuteScriptQuery')
  if self.drover ~= nil then
    oprot:writeFieldBegin('drover', TType.STRUCT, 1)
    self.drover:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.invocation_metadata ~= nil then
    oprot:writeFieldBegin('invocation_metadata', TType.MAP, 2)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.invocation_metadata))
    for kiter244,viter245 in pairs(self.invocation_metadata) do
      oprot:writeString(kiter244)
      oprot:writeString(viter245)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.filename_lex ~= nil then
    oprot:writeFieldBegin('filename_lex', TType.STRING, 3)
    oprot:writeString(self.filename_lex)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

ExecuteScriptResponse = __TObject:new{
  success,
  drover,
  invocation_metadata,
  filename_lex
}

function ExecuteScriptResponse:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.BOOL then
        self.success = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.drover = Drover:new{}
        self.drover:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.MAP then
        self.invocation_metadata = {}
        local _ktype247, _vtype248, _size246 = iprot:readMapBegin() 
        for _i=1,_size246 do
          local _key250 = iprot:readString()
          local _val251 = iprot:readString()
          self.invocation_metadata[_key250] = _val251
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.filename_lex = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function ExecuteScriptResponse:write(oprot)
  oprot:writeStructBegin('ExecuteScriptResponse')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.BOOL, 1)
    oprot:writeBool(self.success)
    oprot:writeFieldEnd()
  end
  if self.drover ~= nil then
    oprot:writeFieldBegin('drover', TType.STRUCT, 2)
    self.drover:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.invocation_metadata ~= nil then
    oprot:writeFieldBegin('invocation_metadata', TType.MAP, 3)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.invocation_metadata))
    for kiter252,viter253 in pairs(self.invocation_metadata) do
      oprot:writeString(kiter252)
      oprot:writeString(viter253)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.filename_lex ~= nil then
    oprot:writeFieldBegin('filename_lex', TType.STRING, 4)
    oprot:writeString(self.filename_lex)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end