/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "DCMA_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dcma { namespace rpc {


vec3_double::~vec3_double() noexcept {
}


void vec3_double::__set_x(const double val) {
  this->x = val;
}

void vec3_double::__set_y(const double val) {
  this->y = val;
}

void vec3_double::__set_z(const double val) {
  this->z = val;
}
std::ostream& operator<<(std::ostream& out, const vec3_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t vec3_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_x = false;
  bool isset_y = false;
  bool isset_z = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          isset_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          isset_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          isset_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_x)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_y)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_z)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t vec3_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("vec3_double");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(vec3_double &a, vec3_double &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
}

vec3_double::vec3_double(const vec3_double& other0) noexcept {
  x = other0.x;
  y = other0.y;
  z = other0.z;
}
vec3_double& vec3_double::operator=(const vec3_double& other1) noexcept {
  x = other1.x;
  y = other1.y;
  z = other1.z;
  return *this;
}
void vec3_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "vec3_double(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z=" << to_string(z);
  out << ")";
}


contour_of_points_double::~contour_of_points_double() noexcept {
}


void contour_of_points_double::__set_points(const std::vector<vec3_double> & val) {
  this->points = val;
}

void contour_of_points_double::__set_closed(const bool val) {
  this->closed = val;
}

void contour_of_points_double::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const contour_of_points_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t contour_of_points_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_points = false;
  bool isset_closed = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->points.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->points.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->points[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_points = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->closed);
          isset_closed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _ktype8;
            ::apache::thrift::protocol::TType _vtype9;
            xfer += iprot->readMapBegin(_ktype8, _vtype9, _size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              std::string _key12;
              xfer += iprot->readString(_key12);
              std::string& _val13 = this->metadata[_key12];
              xfer += iprot->readString(_val13);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_points)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_closed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t contour_of_points_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("contour_of_points_double");

  xfer += oprot->writeFieldBegin("points", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->points.size()));
    std::vector<vec3_double> ::const_iterator _iter14;
    for (_iter14 = this->points.begin(); _iter14 != this->points.end(); ++_iter14)
    {
      xfer += (*_iter14).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("closed", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->closed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter15;
    for (_iter15 = this->metadata.begin(); _iter15 != this->metadata.end(); ++_iter15)
    {
      xfer += oprot->writeString(_iter15->first);
      xfer += oprot->writeString(_iter15->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(contour_of_points_double &a, contour_of_points_double &b) {
  using ::std::swap;
  swap(a.points, b.points);
  swap(a.closed, b.closed);
  swap(a.metadata, b.metadata);
}

contour_of_points_double::contour_of_points_double(const contour_of_points_double& other16) {
  points = other16.points;
  closed = other16.closed;
  metadata = other16.metadata;
}
contour_of_points_double& contour_of_points_double::operator=(const contour_of_points_double& other17) {
  points = other17.points;
  closed = other17.closed;
  metadata = other17.metadata;
  return *this;
}
void contour_of_points_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "contour_of_points_double(";
  out << "points=" << to_string(points);
  out << ", " << "closed=" << to_string(closed);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


contour_collection_double::~contour_collection_double() noexcept {
}


void contour_collection_double::__set_contours(const std::vector<contour_of_points_double> & val) {
  this->contours = val;
}
std::ostream& operator<<(std::ostream& out, const contour_collection_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t contour_collection_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_contours = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->contours.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->contours.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += this->contours[_i22].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_contours = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_contours)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t contour_collection_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("contour_collection_double");

  xfer += oprot->writeFieldBegin("contours", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->contours.size()));
    std::vector<contour_of_points_double> ::const_iterator _iter23;
    for (_iter23 = this->contours.begin(); _iter23 != this->contours.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(contour_collection_double &a, contour_collection_double &b) {
  using ::std::swap;
  swap(a.contours, b.contours);
}

contour_collection_double::contour_collection_double(const contour_collection_double& other24) {
  contours = other24.contours;
}
contour_collection_double& contour_collection_double::operator=(const contour_collection_double& other25) {
  contours = other25.contours;
  return *this;
}
void contour_collection_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "contour_collection_double(";
  out << "contours=" << to_string(contours);
  out << ")";
}


point_set_double::~point_set_double() noexcept {
}


void point_set_double::__set_points(const std::vector<vec3_double> & val) {
  this->points = val;
}

void point_set_double::__set_normals(const std::vector<vec3_double> & val) {
  this->normals = val;
}

void point_set_double::__set_colours(const std::vector<int64_t> & val) {
  this->colours = val;
}

void point_set_double::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const point_set_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t point_set_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_points = false;
  bool isset_normals = false;
  bool isset_colours = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->points.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->points.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->points[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_points = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->normals.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->normals.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->normals[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_normals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colours.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->colours.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readI64(this->colours[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          isset_colours = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _ktype42;
            ::apache::thrift::protocol::TType _vtype43;
            xfer += iprot->readMapBegin(_ktype42, _vtype43, _size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              std::string _key46;
              xfer += iprot->readString(_key46);
              std::string& _val47 = this->metadata[_key46];
              xfer += iprot->readString(_val47);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_points)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_normals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colours)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t point_set_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("point_set_double");

  xfer += oprot->writeFieldBegin("points", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->points.size()));
    std::vector<vec3_double> ::const_iterator _iter48;
    for (_iter48 = this->points.begin(); _iter48 != this->points.end(); ++_iter48)
    {
      xfer += (*_iter48).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("normals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->normals.size()));
    std::vector<vec3_double> ::const_iterator _iter49;
    for (_iter49 = this->normals.begin(); _iter49 != this->normals.end(); ++_iter49)
    {
      xfer += (*_iter49).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colours", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->colours.size()));
    std::vector<int64_t> ::const_iterator _iter50;
    for (_iter50 = this->colours.begin(); _iter50 != this->colours.end(); ++_iter50)
    {
      xfer += oprot->writeI64((*_iter50));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter51;
    for (_iter51 = this->metadata.begin(); _iter51 != this->metadata.end(); ++_iter51)
    {
      xfer += oprot->writeString(_iter51->first);
      xfer += oprot->writeString(_iter51->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(point_set_double &a, point_set_double &b) {
  using ::std::swap;
  swap(a.points, b.points);
  swap(a.normals, b.normals);
  swap(a.colours, b.colours);
  swap(a.metadata, b.metadata);
}

point_set_double::point_set_double(const point_set_double& other52) {
  points = other52.points;
  normals = other52.normals;
  colours = other52.colours;
  metadata = other52.metadata;
}
point_set_double& point_set_double::operator=(const point_set_double& other53) {
  points = other53.points;
  normals = other53.normals;
  colours = other53.colours;
  metadata = other53.metadata;
  return *this;
}
void point_set_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "point_set_double(";
  out << "points=" << to_string(points);
  out << ", " << "normals=" << to_string(normals);
  out << ", " << "colours=" << to_string(colours);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


sample4_double::~sample4_double() noexcept {
}


void sample4_double::__set_x(const double val) {
  this->x = val;
}

void sample4_double::__set_sigma_x(const double val) {
  this->sigma_x = val;
}

void sample4_double::__set_f(const double val) {
  this->f = val;
}

void sample4_double::__set_sigma_f(const double val) {
  this->sigma_f = val;
}
std::ostream& operator<<(std::ostream& out, const sample4_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t sample4_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_x = false;
  bool isset_sigma_x = false;
  bool isset_f = false;
  bool isset_sigma_f = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          isset_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->sigma_x);
          isset_sigma_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->f);
          isset_f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->sigma_f);
          isset_sigma_f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_x)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sigma_x)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_f)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sigma_f)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t sample4_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("sample4_double");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sigma_x", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->sigma_x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->f);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sigma_f", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->sigma_f);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(sample4_double &a, sample4_double &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.sigma_x, b.sigma_x);
  swap(a.f, b.f);
  swap(a.sigma_f, b.sigma_f);
}

sample4_double::sample4_double(const sample4_double& other54) noexcept {
  x = other54.x;
  sigma_x = other54.sigma_x;
  f = other54.f;
  sigma_f = other54.sigma_f;
}
sample4_double& sample4_double::operator=(const sample4_double& other55) noexcept {
  x = other55.x;
  sigma_x = other55.sigma_x;
  f = other55.f;
  sigma_f = other55.sigma_f;
  return *this;
}
void sample4_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "sample4_double(";
  out << "x=" << to_string(x);
  out << ", " << "sigma_x=" << to_string(sigma_x);
  out << ", " << "f=" << to_string(f);
  out << ", " << "sigma_f=" << to_string(sigma_f);
  out << ")";
}


samples_1D_double::~samples_1D_double() noexcept {
}


void samples_1D_double::__set_samples(const std::vector<sample4_double> & val) {
  this->samples = val;
}

void samples_1D_double::__set_uncertainties_known_to_be_independent_and_random(const bool val) {
  this->uncertainties_known_to_be_independent_and_random = val;
}

void samples_1D_double::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const samples_1D_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t samples_1D_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_samples = false;
  bool isset_uncertainties_known_to_be_independent_and_random = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->samples.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->samples.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += this->samples[_i60].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_samples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->uncertainties_known_to_be_independent_and_random);
          isset_uncertainties_known_to_be_independent_and_random = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _ktype62;
            ::apache::thrift::protocol::TType _vtype63;
            xfer += iprot->readMapBegin(_ktype62, _vtype63, _size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              std::string _key66;
              xfer += iprot->readString(_key66);
              std::string& _val67 = this->metadata[_key66];
              xfer += iprot->readString(_val67);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_samples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_uncertainties_known_to_be_independent_and_random)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t samples_1D_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("samples_1D_double");

  xfer += oprot->writeFieldBegin("samples", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->samples.size()));
    std::vector<sample4_double> ::const_iterator _iter68;
    for (_iter68 = this->samples.begin(); _iter68 != this->samples.end(); ++_iter68)
    {
      xfer += (*_iter68).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uncertainties_known_to_be_independent_and_random", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->uncertainties_known_to_be_independent_and_random);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter69;
    for (_iter69 = this->metadata.begin(); _iter69 != this->metadata.end(); ++_iter69)
    {
      xfer += oprot->writeString(_iter69->first);
      xfer += oprot->writeString(_iter69->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(samples_1D_double &a, samples_1D_double &b) {
  using ::std::swap;
  swap(a.samples, b.samples);
  swap(a.uncertainties_known_to_be_independent_and_random, b.uncertainties_known_to_be_independent_and_random);
  swap(a.metadata, b.metadata);
}

samples_1D_double::samples_1D_double(const samples_1D_double& other70) {
  samples = other70.samples;
  uncertainties_known_to_be_independent_and_random = other70.uncertainties_known_to_be_independent_and_random;
  metadata = other70.metadata;
}
samples_1D_double& samples_1D_double::operator=(const samples_1D_double& other71) {
  samples = other71.samples;
  uncertainties_known_to_be_independent_and_random = other71.uncertainties_known_to_be_independent_and_random;
  metadata = other71.metadata;
  return *this;
}
void samples_1D_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "samples_1D_double(";
  out << "samples=" << to_string(samples);
  out << ", " << "uncertainties_known_to_be_independent_and_random=" << to_string(uncertainties_known_to_be_independent_and_random);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


fv_surface_mesh_double_int64::~fv_surface_mesh_double_int64() noexcept {
}


void fv_surface_mesh_double_int64::__set_vertices(const std::vector<vec3_double> & val) {
  this->vertices = val;
}

void fv_surface_mesh_double_int64::__set_vertex_normals(const std::vector<vec3_double> & val) {
  this->vertex_normals = val;
}

void fv_surface_mesh_double_int64::__set_vertex_colours(const std::vector<int64_t> & val) {
  this->vertex_colours = val;
}

void fv_surface_mesh_double_int64::__set_faces(const std::vector<std::vector<int64_t> > & val) {
  this->faces = val;
}

void fv_surface_mesh_double_int64::__set_involved_faces(const std::vector<std::vector<int64_t> > & val) {
  this->involved_faces = val;
}

void fv_surface_mesh_double_int64::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const fv_surface_mesh_double_int64& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t fv_surface_mesh_double_int64::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_vertices = false;
  bool isset_vertex_normals = false;
  bool isset_vertex_colours = false;
  bool isset_faces = false;
  bool isset_involved_faces = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vertices.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->vertices.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += this->vertices[_i76].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_vertices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vertex_normals.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->vertex_normals.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->vertex_normals[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_vertex_normals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vertex_colours.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _etype85;
            xfer += iprot->readListBegin(_etype85, _size82);
            this->vertex_colours.resize(_size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              xfer += iprot->readI64(this->vertex_colours[_i86]);
            }
            xfer += iprot->readListEnd();
          }
          isset_vertex_colours = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->faces.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            this->faces.resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              {
                this->faces[_i91].clear();
                uint32_t _size92;
                ::apache::thrift::protocol::TType _etype95;
                xfer += iprot->readListBegin(_etype95, _size92);
                this->faces[_i91].resize(_size92);
                uint32_t _i96;
                for (_i96 = 0; _i96 < _size92; ++_i96)
                {
                  xfer += iprot->readI64(this->faces[_i91][_i96]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_faces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->involved_faces.clear();
            uint32_t _size97;
            ::apache::thrift::protocol::TType _etype100;
            xfer += iprot->readListBegin(_etype100, _size97);
            this->involved_faces.resize(_size97);
            uint32_t _i101;
            for (_i101 = 0; _i101 < _size97; ++_i101)
            {
              {
                this->involved_faces[_i101].clear();
                uint32_t _size102;
                ::apache::thrift::protocol::TType _etype105;
                xfer += iprot->readListBegin(_etype105, _size102);
                this->involved_faces[_i101].resize(_size102);
                uint32_t _i106;
                for (_i106 = 0; _i106 < _size102; ++_i106)
                {
                  xfer += iprot->readI64(this->involved_faces[_i101][_i106]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_involved_faces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size107;
            ::apache::thrift::protocol::TType _ktype108;
            ::apache::thrift::protocol::TType _vtype109;
            xfer += iprot->readMapBegin(_ktype108, _vtype109, _size107);
            uint32_t _i111;
            for (_i111 = 0; _i111 < _size107; ++_i111)
            {
              std::string _key112;
              xfer += iprot->readString(_key112);
              std::string& _val113 = this->metadata[_key112];
              xfer += iprot->readString(_val113);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_vertices)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_vertex_normals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_vertex_colours)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_faces)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_involved_faces)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t fv_surface_mesh_double_int64::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("fv_surface_mesh_double_int64");

  xfer += oprot->writeFieldBegin("vertices", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vertices.size()));
    std::vector<vec3_double> ::const_iterator _iter114;
    for (_iter114 = this->vertices.begin(); _iter114 != this->vertices.end(); ++_iter114)
    {
      xfer += (*_iter114).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vertex_normals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vertex_normals.size()));
    std::vector<vec3_double> ::const_iterator _iter115;
    for (_iter115 = this->vertex_normals.begin(); _iter115 != this->vertex_normals.end(); ++_iter115)
    {
      xfer += (*_iter115).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vertex_colours", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->vertex_colours.size()));
    std::vector<int64_t> ::const_iterator _iter116;
    for (_iter116 = this->vertex_colours.begin(); _iter116 != this->vertex_colours.end(); ++_iter116)
    {
      xfer += oprot->writeI64((*_iter116));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("faces", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->faces.size()));
    std::vector<std::vector<int64_t> > ::const_iterator _iter117;
    for (_iter117 = this->faces.begin(); _iter117 != this->faces.end(); ++_iter117)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*_iter117).size()));
        std::vector<int64_t> ::const_iterator _iter118;
        for (_iter118 = (*_iter117).begin(); _iter118 != (*_iter117).end(); ++_iter118)
        {
          xfer += oprot->writeI64((*_iter118));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("involved_faces", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->involved_faces.size()));
    std::vector<std::vector<int64_t> > ::const_iterator _iter119;
    for (_iter119 = this->involved_faces.begin(); _iter119 != this->involved_faces.end(); ++_iter119)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*_iter119).size()));
        std::vector<int64_t> ::const_iterator _iter120;
        for (_iter120 = (*_iter119).begin(); _iter120 != (*_iter119).end(); ++_iter120)
        {
          xfer += oprot->writeI64((*_iter120));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter121;
    for (_iter121 = this->metadata.begin(); _iter121 != this->metadata.end(); ++_iter121)
    {
      xfer += oprot->writeString(_iter121->first);
      xfer += oprot->writeString(_iter121->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(fv_surface_mesh_double_int64 &a, fv_surface_mesh_double_int64 &b) {
  using ::std::swap;
  swap(a.vertices, b.vertices);
  swap(a.vertex_normals, b.vertex_normals);
  swap(a.vertex_colours, b.vertex_colours);
  swap(a.faces, b.faces);
  swap(a.involved_faces, b.involved_faces);
  swap(a.metadata, b.metadata);
}

fv_surface_mesh_double_int64::fv_surface_mesh_double_int64(const fv_surface_mesh_double_int64& other122) {
  vertices = other122.vertices;
  vertex_normals = other122.vertex_normals;
  vertex_colours = other122.vertex_colours;
  faces = other122.faces;
  involved_faces = other122.involved_faces;
  metadata = other122.metadata;
}
fv_surface_mesh_double_int64& fv_surface_mesh_double_int64::operator=(const fv_surface_mesh_double_int64& other123) {
  vertices = other123.vertices;
  vertex_normals = other123.vertex_normals;
  vertex_colours = other123.vertex_colours;
  faces = other123.faces;
  involved_faces = other123.involved_faces;
  metadata = other123.metadata;
  return *this;
}
void fv_surface_mesh_double_int64::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "fv_surface_mesh_double_int64(";
  out << "vertices=" << to_string(vertices);
  out << ", " << "vertex_normals=" << to_string(vertex_normals);
  out << ", " << "vertex_colours=" << to_string(vertex_colours);
  out << ", " << "faces=" << to_string(faces);
  out << ", " << "involved_faces=" << to_string(involved_faces);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


planar_image_double_double::~planar_image_double_double() noexcept {
}


void planar_image_double_double::__set_data(const std::vector<double> & val) {
  this->data = val;
}

void planar_image_double_double::__set_rows(const int64_t val) {
  this->rows = val;
}

void planar_image_double_double::__set_columns(const int64_t val) {
  this->columns = val;
}

void planar_image_double_double::__set_channels(const int64_t val) {
  this->channels = val;
}

void planar_image_double_double::__set_pxl_dx(const double val) {
  this->pxl_dx = val;
}

void planar_image_double_double::__set_pxl_dy(const double val) {
  this->pxl_dy = val;
}

void planar_image_double_double::__set_pxl_dz(const double val) {
  this->pxl_dz = val;
}

void planar_image_double_double::__set_anchor(const vec3_double& val) {
  this->anchor = val;
}

void planar_image_double_double::__set_offset(const vec3_double& val) {
  this->offset = val;
}

void planar_image_double_double::__set_row_unit(const vec3_double& val) {
  this->row_unit = val;
}

void planar_image_double_double::__set_col_unit(const vec3_double& val) {
  this->col_unit = val;
}

void planar_image_double_double::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const planar_image_double_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t planar_image_double_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;
  bool isset_rows = false;
  bool isset_columns = false;
  bool isset_channels = false;
  bool isset_pxl_dx = false;
  bool isset_pxl_dy = false;
  bool isset_pxl_dz = false;
  bool isset_anchor = false;
  bool isset_offset = false;
  bool isset_row_unit = false;
  bool isset_col_unit = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _etype127;
            xfer += iprot->readListBegin(_etype127, _size124);
            this->data.resize(_size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              xfer += iprot->readDouble(this->data[_i128]);
            }
            xfer += iprot->readListEnd();
          }
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows);
          isset_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->columns);
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->channels);
          isset_channels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pxl_dx);
          isset_pxl_dx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pxl_dy);
          isset_pxl_dy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pxl_dz);
          isset_pxl_dz = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->anchor.read(iprot);
          isset_anchor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->offset.read(iprot);
          isset_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_unit.read(iprot);
          isset_row_unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->col_unit.read(iprot);
          isset_col_unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size129;
            ::apache::thrift::protocol::TType _ktype130;
            ::apache::thrift::protocol::TType _vtype131;
            xfer += iprot->readMapBegin(_ktype130, _vtype131, _size129);
            uint32_t _i133;
            for (_i133 = 0; _i133 < _size129; ++_i133)
            {
              std::string _key134;
              xfer += iprot->readString(_key134);
              std::string& _val135 = this->metadata[_key134];
              xfer += iprot->readString(_val135);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_channels)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pxl_dx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pxl_dy)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pxl_dz)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_anchor)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_offset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_row_unit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_col_unit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t planar_image_double_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("planar_image_double_double");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->data.size()));
    std::vector<double> ::const_iterator _iter136;
    for (_iter136 = this->data.begin(); _iter136 != this->data.end(); ++_iter136)
    {
      xfer += oprot->writeDouble((*_iter136));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->columns);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("channels", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->channels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pxl_dx", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->pxl_dx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pxl_dy", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->pxl_dy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pxl_dz", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->pxl_dz);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("anchor", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->anchor.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->offset.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_unit", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->row_unit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_unit", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->col_unit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 12);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter137;
    for (_iter137 = this->metadata.begin(); _iter137 != this->metadata.end(); ++_iter137)
    {
      xfer += oprot->writeString(_iter137->first);
      xfer += oprot->writeString(_iter137->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(planar_image_double_double &a, planar_image_double_double &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.rows, b.rows);
  swap(a.columns, b.columns);
  swap(a.channels, b.channels);
  swap(a.pxl_dx, b.pxl_dx);
  swap(a.pxl_dy, b.pxl_dy);
  swap(a.pxl_dz, b.pxl_dz);
  swap(a.anchor, b.anchor);
  swap(a.offset, b.offset);
  swap(a.row_unit, b.row_unit);
  swap(a.col_unit, b.col_unit);
  swap(a.metadata, b.metadata);
}

planar_image_double_double::planar_image_double_double(const planar_image_double_double& other138) {
  data = other138.data;
  rows = other138.rows;
  columns = other138.columns;
  channels = other138.channels;
  pxl_dx = other138.pxl_dx;
  pxl_dy = other138.pxl_dy;
  pxl_dz = other138.pxl_dz;
  anchor = other138.anchor;
  offset = other138.offset;
  row_unit = other138.row_unit;
  col_unit = other138.col_unit;
  metadata = other138.metadata;
}
planar_image_double_double& planar_image_double_double::operator=(const planar_image_double_double& other139) {
  data = other139.data;
  rows = other139.rows;
  columns = other139.columns;
  channels = other139.channels;
  pxl_dx = other139.pxl_dx;
  pxl_dy = other139.pxl_dy;
  pxl_dz = other139.pxl_dz;
  anchor = other139.anchor;
  offset = other139.offset;
  row_unit = other139.row_unit;
  col_unit = other139.col_unit;
  metadata = other139.metadata;
  return *this;
}
void planar_image_double_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "planar_image_double_double(";
  out << "data=" << to_string(data);
  out << ", " << "rows=" << to_string(rows);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "channels=" << to_string(channels);
  out << ", " << "pxl_dx=" << to_string(pxl_dx);
  out << ", " << "pxl_dy=" << to_string(pxl_dy);
  out << ", " << "pxl_dz=" << to_string(pxl_dz);
  out << ", " << "anchor=" << to_string(anchor);
  out << ", " << "offset=" << to_string(offset);
  out << ", " << "row_unit=" << to_string(row_unit);
  out << ", " << "col_unit=" << to_string(col_unit);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


planar_image_collection_double_double::~planar_image_collection_double_double() noexcept {
}


void planar_image_collection_double_double::__set_images(const std::vector<planar_image_double_double> & val) {
  this->images = val;
}
std::ostream& operator<<(std::ostream& out, const planar_image_collection_double_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t planar_image_collection_double_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_images = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->images.clear();
            uint32_t _size140;
            ::apache::thrift::protocol::TType _etype143;
            xfer += iprot->readListBegin(_etype143, _size140);
            this->images.resize(_size140);
            uint32_t _i144;
            for (_i144 = 0; _i144 < _size140; ++_i144)
            {
              xfer += this->images[_i144].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_images = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_images)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t planar_image_collection_double_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("planar_image_collection_double_double");

  xfer += oprot->writeFieldBegin("images", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->images.size()));
    std::vector<planar_image_double_double> ::const_iterator _iter145;
    for (_iter145 = this->images.begin(); _iter145 != this->images.end(); ++_iter145)
    {
      xfer += (*_iter145).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(planar_image_collection_double_double &a, planar_image_collection_double_double &b) {
  using ::std::swap;
  swap(a.images, b.images);
}

planar_image_collection_double_double::planar_image_collection_double_double(const planar_image_collection_double_double& other146) {
  images = other146.images;
}
planar_image_collection_double_double& planar_image_collection_double_double::operator=(const planar_image_collection_double_double& other147) {
  images = other147.images;
  return *this;
}
void planar_image_collection_double_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "planar_image_collection_double_double(";
  out << "images=" << to_string(images);
  out << ")";
}


cell_string::~cell_string() noexcept {
}

std::ostream& operator<<(std::ostream& out, const cell_string& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t cell_string::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cell_string::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cell_string");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cell_string &a, cell_string &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

cell_string::cell_string(const cell_string& other148) noexcept {
  (void) other148;
}
cell_string& cell_string::operator=(const cell_string& other149) noexcept {
  (void) other149;
  return *this;
}
void cell_string::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cell_string(";
  out << ")";
}


table2::~table2() noexcept {
}

std::ostream& operator<<(std::ostream& out, const table2& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t table2::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t table2::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("table2");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(table2 &a, table2 &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

table2::table2(const table2& other150) noexcept {
  (void) other150;
}
table2& table2::operator=(const table2& other151) noexcept {
  (void) other151;
  return *this;
}
void table2::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "table2(";
  out << ")";
}


Contour_Data::~Contour_Data() noexcept {
}


void Contour_Data::__set_ccs(const std::vector<contour_collection_double> & val) {
  this->ccs = val;
}
std::ostream& operator<<(std::ostream& out, const Contour_Data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Contour_Data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ccs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ccs.clear();
            uint32_t _size152;
            ::apache::thrift::protocol::TType _etype155;
            xfer += iprot->readListBegin(_etype155, _size152);
            this->ccs.resize(_size152);
            uint32_t _i156;
            for (_i156 = 0; _i156 < _size152; ++_i156)
            {
              xfer += this->ccs[_i156].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_ccs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ccs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Contour_Data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Contour_Data");

  xfer += oprot->writeFieldBegin("ccs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ccs.size()));
    std::vector<contour_collection_double> ::const_iterator _iter157;
    for (_iter157 = this->ccs.begin(); _iter157 != this->ccs.end(); ++_iter157)
    {
      xfer += (*_iter157).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Contour_Data &a, Contour_Data &b) {
  using ::std::swap;
  swap(a.ccs, b.ccs);
}

Contour_Data::Contour_Data(const Contour_Data& other158) {
  ccs = other158.ccs;
}
Contour_Data& Contour_Data::operator=(const Contour_Data& other159) {
  ccs = other159.ccs;
  return *this;
}
void Contour_Data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Contour_Data(";
  out << "ccs=" << to_string(ccs);
  out << ")";
}


Image_Array::~Image_Array() noexcept {
}


void Image_Array::__set_imagecoll(const planar_image_collection_double_double& val) {
  this->imagecoll = val;
}

void Image_Array::__set_filename(const std::string& val) {
  this->filename = val;
}
std::ostream& operator<<(std::ostream& out, const Image_Array& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Image_Array::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_imagecoll = false;
  bool isset_filename = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->imagecoll.read(iprot);
          isset_imagecoll = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filename);
          isset_filename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_imagecoll)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_filename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Image_Array::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Image_Array");

  xfer += oprot->writeFieldBegin("imagecoll", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->imagecoll.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->filename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Image_Array &a, Image_Array &b) {
  using ::std::swap;
  swap(a.imagecoll, b.imagecoll);
  swap(a.filename, b.filename);
}

Image_Array::Image_Array(const Image_Array& other160) {
  imagecoll = other160.imagecoll;
  filename = other160.filename;
}
Image_Array& Image_Array::operator=(const Image_Array& other161) {
  imagecoll = other161.imagecoll;
  filename = other161.filename;
  return *this;
}
void Image_Array::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Image_Array(";
  out << "imagecoll=" << to_string(imagecoll);
  out << ", " << "filename=" << to_string(filename);
  out << ")";
}


Point_Cloud::~Point_Cloud() noexcept {
}


void Point_Cloud::__set_pset(const point_set_double& val) {
  this->pset = val;
}
std::ostream& operator<<(std::ostream& out, const Point_Cloud& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Point_Cloud::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pset = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pset.read(iprot);
          isset_pset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Point_Cloud::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Point_Cloud");

  xfer += oprot->writeFieldBegin("pset", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pset.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Point_Cloud &a, Point_Cloud &b) {
  using ::std::swap;
  swap(a.pset, b.pset);
}

Point_Cloud::Point_Cloud(const Point_Cloud& other162) {
  pset = other162.pset;
}
Point_Cloud& Point_Cloud::operator=(const Point_Cloud& other163) {
  pset = other163.pset;
  return *this;
}
void Point_Cloud::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Point_Cloud(";
  out << "pset=" << to_string(pset);
  out << ")";
}


Surface_Mesh::~Surface_Mesh() noexcept {
}


void Surface_Mesh::__set_meshes(const fv_surface_mesh_double_int64& val) {
  this->meshes = val;
}
std::ostream& operator<<(std::ostream& out, const Surface_Mesh& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Surface_Mesh::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_meshes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->meshes.read(iprot);
          isset_meshes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_meshes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Surface_Mesh::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Surface_Mesh");

  xfer += oprot->writeFieldBegin("meshes", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->meshes.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Surface_Mesh &a, Surface_Mesh &b) {
  using ::std::swap;
  swap(a.meshes, b.meshes);
}

Surface_Mesh::Surface_Mesh(const Surface_Mesh& other164) {
  meshes = other164.meshes;
}
Surface_Mesh& Surface_Mesh::operator=(const Surface_Mesh& other165) {
  meshes = other165.meshes;
  return *this;
}
void Surface_Mesh::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Surface_Mesh(";
  out << "meshes=" << to_string(meshes);
  out << ")";
}


Static_Machine_State::~Static_Machine_State() noexcept {
}


void Static_Machine_State::__set_CumulativeMetersetWeight(const double val) {
  this->CumulativeMetersetWeight = val;
}

void Static_Machine_State::__set_ControlPointIndex(const int64_t val) {
  this->ControlPointIndex = val;
}

void Static_Machine_State::__set_GantryAngle(const double val) {
  this->GantryAngle = val;
}

void Static_Machine_State::__set_GantryRotationDirection(const double val) {
  this->GantryRotationDirection = val;
}

void Static_Machine_State::__set_BeamLimitingDeviceAngle(const double val) {
  this->BeamLimitingDeviceAngle = val;
}

void Static_Machine_State::__set_BeamLimitingDeviceRotationDirection(const double val) {
  this->BeamLimitingDeviceRotationDirection = val;
}

void Static_Machine_State::__set_PatientSupportAngle(const double val) {
  this->PatientSupportAngle = val;
}

void Static_Machine_State::__set_PatientSupportRotationDirection(const double val) {
  this->PatientSupportRotationDirection = val;
}

void Static_Machine_State::__set_TableTopEccentricAngle(const double val) {
  this->TableTopEccentricAngle = val;
}

void Static_Machine_State::__set_TableTopEccentricRotationDirection(const double val) {
  this->TableTopEccentricRotationDirection = val;
}

void Static_Machine_State::__set_TableTopVerticalPosition(const double val) {
  this->TableTopVerticalPosition = val;
}

void Static_Machine_State::__set_TableTopLongitudinalPosition(const double val) {
  this->TableTopLongitudinalPosition = val;
}

void Static_Machine_State::__set_TableTopLateralPosition(const double val) {
  this->TableTopLateralPosition = val;
}

void Static_Machine_State::__set_TableTopPitchAngle(const double val) {
  this->TableTopPitchAngle = val;
}

void Static_Machine_State::__set_TableTopPitchRotationDirection(const double val) {
  this->TableTopPitchRotationDirection = val;
}

void Static_Machine_State::__set_TableTopRollAngle(const double val) {
  this->TableTopRollAngle = val;
}

void Static_Machine_State::__set_TableTopRollRotationDirection(const double val) {
  this->TableTopRollRotationDirection = val;
}

void Static_Machine_State::__set_IsocentrePosition(const vec3_double& val) {
  this->IsocentrePosition = val;
}

void Static_Machine_State::__set_JawPositionsX(const std::vector<double> & val) {
  this->JawPositionsX = val;
}

void Static_Machine_State::__set_JawPositionsY(const std::vector<double> & val) {
  this->JawPositionsY = val;
}

void Static_Machine_State::__set_MLCPositionsX(const std::vector<double> & val) {
  this->MLCPositionsX = val;
}

void Static_Machine_State::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const Static_Machine_State& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Static_Machine_State::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_CumulativeMetersetWeight = false;
  bool isset_ControlPointIndex = false;
  bool isset_GantryAngle = false;
  bool isset_GantryRotationDirection = false;
  bool isset_BeamLimitingDeviceAngle = false;
  bool isset_BeamLimitingDeviceRotationDirection = false;
  bool isset_PatientSupportAngle = false;
  bool isset_PatientSupportRotationDirection = false;
  bool isset_TableTopEccentricAngle = false;
  bool isset_TableTopEccentricRotationDirection = false;
  bool isset_TableTopVerticalPosition = false;
  bool isset_TableTopLongitudinalPosition = false;
  bool isset_TableTopLateralPosition = false;
  bool isset_TableTopPitchAngle = false;
  bool isset_TableTopPitchRotationDirection = false;
  bool isset_TableTopRollAngle = false;
  bool isset_TableTopRollRotationDirection = false;
  bool isset_IsocentrePosition = false;
  bool isset_JawPositionsX = false;
  bool isset_JawPositionsY = false;
  bool isset_MLCPositionsX = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->CumulativeMetersetWeight);
          isset_CumulativeMetersetWeight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ControlPointIndex);
          isset_ControlPointIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->GantryAngle);
          isset_GantryAngle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->GantryRotationDirection);
          isset_GantryRotationDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->BeamLimitingDeviceAngle);
          isset_BeamLimitingDeviceAngle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->BeamLimitingDeviceRotationDirection);
          isset_BeamLimitingDeviceRotationDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->PatientSupportAngle);
          isset_PatientSupportAngle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->PatientSupportRotationDirection);
          isset_PatientSupportRotationDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopEccentricAngle);
          isset_TableTopEccentricAngle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopEccentricRotationDirection);
          isset_TableTopEccentricRotationDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopVerticalPosition);
          isset_TableTopVerticalPosition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopLongitudinalPosition);
          isset_TableTopLongitudinalPosition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopLateralPosition);
          isset_TableTopLateralPosition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopPitchAngle);
          isset_TableTopPitchAngle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopPitchRotationDirection);
          isset_TableTopPitchRotationDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopRollAngle);
          isset_TableTopRollAngle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopRollRotationDirection);
          isset_TableTopRollRotationDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->IsocentrePosition.read(iprot);
          isset_IsocentrePosition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->JawPositionsX.clear();
            uint32_t _size166;
            ::apache::thrift::protocol::TType _etype169;
            xfer += iprot->readListBegin(_etype169, _size166);
            this->JawPositionsX.resize(_size166);
            uint32_t _i170;
            for (_i170 = 0; _i170 < _size166; ++_i170)
            {
              xfer += iprot->readDouble(this->JawPositionsX[_i170]);
            }
            xfer += iprot->readListEnd();
          }
          isset_JawPositionsX = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->JawPositionsY.clear();
            uint32_t _size171;
            ::apache::thrift::protocol::TType _etype174;
            xfer += iprot->readListBegin(_etype174, _size171);
            this->JawPositionsY.resize(_size171);
            uint32_t _i175;
            for (_i175 = 0; _i175 < _size171; ++_i175)
            {
              xfer += iprot->readDouble(this->JawPositionsY[_i175]);
            }
            xfer += iprot->readListEnd();
          }
          isset_JawPositionsY = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->MLCPositionsX.clear();
            uint32_t _size176;
            ::apache::thrift::protocol::TType _etype179;
            xfer += iprot->readListBegin(_etype179, _size176);
            this->MLCPositionsX.resize(_size176);
            uint32_t _i180;
            for (_i180 = 0; _i180 < _size176; ++_i180)
            {
              xfer += iprot->readDouble(this->MLCPositionsX[_i180]);
            }
            xfer += iprot->readListEnd();
          }
          isset_MLCPositionsX = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size181;
            ::apache::thrift::protocol::TType _ktype182;
            ::apache::thrift::protocol::TType _vtype183;
            xfer += iprot->readMapBegin(_ktype182, _vtype183, _size181);
            uint32_t _i185;
            for (_i185 = 0; _i185 < _size181; ++_i185)
            {
              std::string _key186;
              xfer += iprot->readString(_key186);
              std::string& _val187 = this->metadata[_key186];
              xfer += iprot->readString(_val187);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_CumulativeMetersetWeight)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ControlPointIndex)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_GantryAngle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_GantryRotationDirection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_BeamLimitingDeviceAngle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_BeamLimitingDeviceRotationDirection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_PatientSupportAngle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_PatientSupportRotationDirection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopEccentricAngle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopEccentricRotationDirection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopVerticalPosition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopLongitudinalPosition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopLateralPosition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopPitchAngle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopPitchRotationDirection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopRollAngle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopRollRotationDirection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_IsocentrePosition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_JawPositionsX)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_JawPositionsY)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_MLCPositionsX)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Static_Machine_State::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Static_Machine_State");

  xfer += oprot->writeFieldBegin("CumulativeMetersetWeight", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->CumulativeMetersetWeight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ControlPointIndex", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ControlPointIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("GantryAngle", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->GantryAngle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("GantryRotationDirection", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->GantryRotationDirection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("BeamLimitingDeviceAngle", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->BeamLimitingDeviceAngle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("BeamLimitingDeviceRotationDirection", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->BeamLimitingDeviceRotationDirection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("PatientSupportAngle", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->PatientSupportAngle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("PatientSupportRotationDirection", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->PatientSupportRotationDirection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopEccentricAngle", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->TableTopEccentricAngle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopEccentricRotationDirection", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->TableTopEccentricRotationDirection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopVerticalPosition", ::apache::thrift::protocol::T_DOUBLE, 11);
  xfer += oprot->writeDouble(this->TableTopVerticalPosition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopLongitudinalPosition", ::apache::thrift::protocol::T_DOUBLE, 12);
  xfer += oprot->writeDouble(this->TableTopLongitudinalPosition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopLateralPosition", ::apache::thrift::protocol::T_DOUBLE, 13);
  xfer += oprot->writeDouble(this->TableTopLateralPosition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopPitchAngle", ::apache::thrift::protocol::T_DOUBLE, 14);
  xfer += oprot->writeDouble(this->TableTopPitchAngle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopPitchRotationDirection", ::apache::thrift::protocol::T_DOUBLE, 15);
  xfer += oprot->writeDouble(this->TableTopPitchRotationDirection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopRollAngle", ::apache::thrift::protocol::T_DOUBLE, 16);
  xfer += oprot->writeDouble(this->TableTopRollAngle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopRollRotationDirection", ::apache::thrift::protocol::T_DOUBLE, 17);
  xfer += oprot->writeDouble(this->TableTopRollRotationDirection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("IsocentrePosition", ::apache::thrift::protocol::T_STRUCT, 18);
  xfer += this->IsocentrePosition.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("JawPositionsX", ::apache::thrift::protocol::T_LIST, 19);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->JawPositionsX.size()));
    std::vector<double> ::const_iterator _iter188;
    for (_iter188 = this->JawPositionsX.begin(); _iter188 != this->JawPositionsX.end(); ++_iter188)
    {
      xfer += oprot->writeDouble((*_iter188));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("JawPositionsY", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->JawPositionsY.size()));
    std::vector<double> ::const_iterator _iter189;
    for (_iter189 = this->JawPositionsY.begin(); _iter189 != this->JawPositionsY.end(); ++_iter189)
    {
      xfer += oprot->writeDouble((*_iter189));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MLCPositionsX", ::apache::thrift::protocol::T_LIST, 21);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->MLCPositionsX.size()));
    std::vector<double> ::const_iterator _iter190;
    for (_iter190 = this->MLCPositionsX.begin(); _iter190 != this->MLCPositionsX.end(); ++_iter190)
    {
      xfer += oprot->writeDouble((*_iter190));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 22);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter191;
    for (_iter191 = this->metadata.begin(); _iter191 != this->metadata.end(); ++_iter191)
    {
      xfer += oprot->writeString(_iter191->first);
      xfer += oprot->writeString(_iter191->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Static_Machine_State &a, Static_Machine_State &b) {
  using ::std::swap;
  swap(a.CumulativeMetersetWeight, b.CumulativeMetersetWeight);
  swap(a.ControlPointIndex, b.ControlPointIndex);
  swap(a.GantryAngle, b.GantryAngle);
  swap(a.GantryRotationDirection, b.GantryRotationDirection);
  swap(a.BeamLimitingDeviceAngle, b.BeamLimitingDeviceAngle);
  swap(a.BeamLimitingDeviceRotationDirection, b.BeamLimitingDeviceRotationDirection);
  swap(a.PatientSupportAngle, b.PatientSupportAngle);
  swap(a.PatientSupportRotationDirection, b.PatientSupportRotationDirection);
  swap(a.TableTopEccentricAngle, b.TableTopEccentricAngle);
  swap(a.TableTopEccentricRotationDirection, b.TableTopEccentricRotationDirection);
  swap(a.TableTopVerticalPosition, b.TableTopVerticalPosition);
  swap(a.TableTopLongitudinalPosition, b.TableTopLongitudinalPosition);
  swap(a.TableTopLateralPosition, b.TableTopLateralPosition);
  swap(a.TableTopPitchAngle, b.TableTopPitchAngle);
  swap(a.TableTopPitchRotationDirection, b.TableTopPitchRotationDirection);
  swap(a.TableTopRollAngle, b.TableTopRollAngle);
  swap(a.TableTopRollRotationDirection, b.TableTopRollRotationDirection);
  swap(a.IsocentrePosition, b.IsocentrePosition);
  swap(a.JawPositionsX, b.JawPositionsX);
  swap(a.JawPositionsY, b.JawPositionsY);
  swap(a.MLCPositionsX, b.MLCPositionsX);
  swap(a.metadata, b.metadata);
}

Static_Machine_State::Static_Machine_State(const Static_Machine_State& other192) {
  CumulativeMetersetWeight = other192.CumulativeMetersetWeight;
  ControlPointIndex = other192.ControlPointIndex;
  GantryAngle = other192.GantryAngle;
  GantryRotationDirection = other192.GantryRotationDirection;
  BeamLimitingDeviceAngle = other192.BeamLimitingDeviceAngle;
  BeamLimitingDeviceRotationDirection = other192.BeamLimitingDeviceRotationDirection;
  PatientSupportAngle = other192.PatientSupportAngle;
  PatientSupportRotationDirection = other192.PatientSupportRotationDirection;
  TableTopEccentricAngle = other192.TableTopEccentricAngle;
  TableTopEccentricRotationDirection = other192.TableTopEccentricRotationDirection;
  TableTopVerticalPosition = other192.TableTopVerticalPosition;
  TableTopLongitudinalPosition = other192.TableTopLongitudinalPosition;
  TableTopLateralPosition = other192.TableTopLateralPosition;
  TableTopPitchAngle = other192.TableTopPitchAngle;
  TableTopPitchRotationDirection = other192.TableTopPitchRotationDirection;
  TableTopRollAngle = other192.TableTopRollAngle;
  TableTopRollRotationDirection = other192.TableTopRollRotationDirection;
  IsocentrePosition = other192.IsocentrePosition;
  JawPositionsX = other192.JawPositionsX;
  JawPositionsY = other192.JawPositionsY;
  MLCPositionsX = other192.MLCPositionsX;
  metadata = other192.metadata;
}
Static_Machine_State& Static_Machine_State::operator=(const Static_Machine_State& other193) {
  CumulativeMetersetWeight = other193.CumulativeMetersetWeight;
  ControlPointIndex = other193.ControlPointIndex;
  GantryAngle = other193.GantryAngle;
  GantryRotationDirection = other193.GantryRotationDirection;
  BeamLimitingDeviceAngle = other193.BeamLimitingDeviceAngle;
  BeamLimitingDeviceRotationDirection = other193.BeamLimitingDeviceRotationDirection;
  PatientSupportAngle = other193.PatientSupportAngle;
  PatientSupportRotationDirection = other193.PatientSupportRotationDirection;
  TableTopEccentricAngle = other193.TableTopEccentricAngle;
  TableTopEccentricRotationDirection = other193.TableTopEccentricRotationDirection;
  TableTopVerticalPosition = other193.TableTopVerticalPosition;
  TableTopLongitudinalPosition = other193.TableTopLongitudinalPosition;
  TableTopLateralPosition = other193.TableTopLateralPosition;
  TableTopPitchAngle = other193.TableTopPitchAngle;
  TableTopPitchRotationDirection = other193.TableTopPitchRotationDirection;
  TableTopRollAngle = other193.TableTopRollAngle;
  TableTopRollRotationDirection = other193.TableTopRollRotationDirection;
  IsocentrePosition = other193.IsocentrePosition;
  JawPositionsX = other193.JawPositionsX;
  JawPositionsY = other193.JawPositionsY;
  MLCPositionsX = other193.MLCPositionsX;
  metadata = other193.metadata;
  return *this;
}
void Static_Machine_State::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Static_Machine_State(";
  out << "CumulativeMetersetWeight=" << to_string(CumulativeMetersetWeight);
  out << ", " << "ControlPointIndex=" << to_string(ControlPointIndex);
  out << ", " << "GantryAngle=" << to_string(GantryAngle);
  out << ", " << "GantryRotationDirection=" << to_string(GantryRotationDirection);
  out << ", " << "BeamLimitingDeviceAngle=" << to_string(BeamLimitingDeviceAngle);
  out << ", " << "BeamLimitingDeviceRotationDirection=" << to_string(BeamLimitingDeviceRotationDirection);
  out << ", " << "PatientSupportAngle=" << to_string(PatientSupportAngle);
  out << ", " << "PatientSupportRotationDirection=" << to_string(PatientSupportRotationDirection);
  out << ", " << "TableTopEccentricAngle=" << to_string(TableTopEccentricAngle);
  out << ", " << "TableTopEccentricRotationDirection=" << to_string(TableTopEccentricRotationDirection);
  out << ", " << "TableTopVerticalPosition=" << to_string(TableTopVerticalPosition);
  out << ", " << "TableTopLongitudinalPosition=" << to_string(TableTopLongitudinalPosition);
  out << ", " << "TableTopLateralPosition=" << to_string(TableTopLateralPosition);
  out << ", " << "TableTopPitchAngle=" << to_string(TableTopPitchAngle);
  out << ", " << "TableTopPitchRotationDirection=" << to_string(TableTopPitchRotationDirection);
  out << ", " << "TableTopRollAngle=" << to_string(TableTopRollAngle);
  out << ", " << "TableTopRollRotationDirection=" << to_string(TableTopRollRotationDirection);
  out << ", " << "IsocentrePosition=" << to_string(IsocentrePosition);
  out << ", " << "JawPositionsX=" << to_string(JawPositionsX);
  out << ", " << "JawPositionsY=" << to_string(JawPositionsY);
  out << ", " << "MLCPositionsX=" << to_string(MLCPositionsX);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


Dynamic_Machine_State::~Dynamic_Machine_State() noexcept {
}


void Dynamic_Machine_State::__set_BeamNumber(const int64_t val) {
  this->BeamNumber = val;
}

void Dynamic_Machine_State::__set_FinalCumulativeMetersetWeight(const double val) {
  this->FinalCumulativeMetersetWeight = val;
}

void Dynamic_Machine_State::__set_static_states(const std::vector<Static_Machine_State> & val) {
  this->static_states = val;
}

void Dynamic_Machine_State::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const Dynamic_Machine_State& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Dynamic_Machine_State::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_BeamNumber = false;
  bool isset_FinalCumulativeMetersetWeight = false;
  bool isset_static_states = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->BeamNumber);
          isset_BeamNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->FinalCumulativeMetersetWeight);
          isset_FinalCumulativeMetersetWeight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->static_states.clear();
            uint32_t _size194;
            ::apache::thrift::protocol::TType _etype197;
            xfer += iprot->readListBegin(_etype197, _size194);
            this->static_states.resize(_size194);
            uint32_t _i198;
            for (_i198 = 0; _i198 < _size194; ++_i198)
            {
              xfer += this->static_states[_i198].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_static_states = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size199;
            ::apache::thrift::protocol::TType _ktype200;
            ::apache::thrift::protocol::TType _vtype201;
            xfer += iprot->readMapBegin(_ktype200, _vtype201, _size199);
            uint32_t _i203;
            for (_i203 = 0; _i203 < _size199; ++_i203)
            {
              std::string _key204;
              xfer += iprot->readString(_key204);
              std::string& _val205 = this->metadata[_key204];
              xfer += iprot->readString(_val205);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_BeamNumber)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_FinalCumulativeMetersetWeight)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_static_states)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Dynamic_Machine_State::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Dynamic_Machine_State");

  xfer += oprot->writeFieldBegin("BeamNumber", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->BeamNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("FinalCumulativeMetersetWeight", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->FinalCumulativeMetersetWeight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("static_states", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->static_states.size()));
    std::vector<Static_Machine_State> ::const_iterator _iter206;
    for (_iter206 = this->static_states.begin(); _iter206 != this->static_states.end(); ++_iter206)
    {
      xfer += (*_iter206).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter207;
    for (_iter207 = this->metadata.begin(); _iter207 != this->metadata.end(); ++_iter207)
    {
      xfer += oprot->writeString(_iter207->first);
      xfer += oprot->writeString(_iter207->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Dynamic_Machine_State &a, Dynamic_Machine_State &b) {
  using ::std::swap;
  swap(a.BeamNumber, b.BeamNumber);
  swap(a.FinalCumulativeMetersetWeight, b.FinalCumulativeMetersetWeight);
  swap(a.static_states, b.static_states);
  swap(a.metadata, b.metadata);
}

Dynamic_Machine_State::Dynamic_Machine_State(const Dynamic_Machine_State& other208) {
  BeamNumber = other208.BeamNumber;
  FinalCumulativeMetersetWeight = other208.FinalCumulativeMetersetWeight;
  static_states = other208.static_states;
  metadata = other208.metadata;
}
Dynamic_Machine_State& Dynamic_Machine_State::operator=(const Dynamic_Machine_State& other209) {
  BeamNumber = other209.BeamNumber;
  FinalCumulativeMetersetWeight = other209.FinalCumulativeMetersetWeight;
  static_states = other209.static_states;
  metadata = other209.metadata;
  return *this;
}
void Dynamic_Machine_State::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Dynamic_Machine_State(";
  out << "BeamNumber=" << to_string(BeamNumber);
  out << ", " << "FinalCumulativeMetersetWeight=" << to_string(FinalCumulativeMetersetWeight);
  out << ", " << "static_states=" << to_string(static_states);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


RTPlan::~RTPlan() noexcept {
}


void RTPlan::__set_dynamic_states(const std::vector<Dynamic_Machine_State> & val) {
  this->dynamic_states = val;
}

void RTPlan::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const RTPlan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RTPlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dynamic_states = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dynamic_states.clear();
            uint32_t _size210;
            ::apache::thrift::protocol::TType _etype213;
            xfer += iprot->readListBegin(_etype213, _size210);
            this->dynamic_states.resize(_size210);
            uint32_t _i214;
            for (_i214 = 0; _i214 < _size210; ++_i214)
            {
              xfer += this->dynamic_states[_i214].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_dynamic_states = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size215;
            ::apache::thrift::protocol::TType _ktype216;
            ::apache::thrift::protocol::TType _vtype217;
            xfer += iprot->readMapBegin(_ktype216, _vtype217, _size215);
            uint32_t _i219;
            for (_i219 = 0; _i219 < _size215; ++_i219)
            {
              std::string _key220;
              xfer += iprot->readString(_key220);
              std::string& _val221 = this->metadata[_key220];
              xfer += iprot->readString(_val221);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dynamic_states)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RTPlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RTPlan");

  xfer += oprot->writeFieldBegin("dynamic_states", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dynamic_states.size()));
    std::vector<Dynamic_Machine_State> ::const_iterator _iter222;
    for (_iter222 = this->dynamic_states.begin(); _iter222 != this->dynamic_states.end(); ++_iter222)
    {
      xfer += (*_iter222).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter223;
    for (_iter223 = this->metadata.begin(); _iter223 != this->metadata.end(); ++_iter223)
    {
      xfer += oprot->writeString(_iter223->first);
      xfer += oprot->writeString(_iter223->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RTPlan &a, RTPlan &b) {
  using ::std::swap;
  swap(a.dynamic_states, b.dynamic_states);
  swap(a.metadata, b.metadata);
}

RTPlan::RTPlan(const RTPlan& other224) {
  dynamic_states = other224.dynamic_states;
  metadata = other224.metadata;
}
RTPlan& RTPlan::operator=(const RTPlan& other225) {
  dynamic_states = other225.dynamic_states;
  metadata = other225.metadata;
  return *this;
}
void RTPlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RTPlan(";
  out << "dynamic_states=" << to_string(dynamic_states);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


Line_Sample::~Line_Sample() noexcept {
}


void Line_Sample::__set_line(const samples_1D_double& val) {
  this->line = val;
}
std::ostream& operator<<(std::ostream& out, const Line_Sample& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Line_Sample::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_line = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->line.read(iprot);
          isset_line = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_line)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Line_Sample::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Line_Sample");

  xfer += oprot->writeFieldBegin("line", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->line.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Line_Sample &a, Line_Sample &b) {
  using ::std::swap;
  swap(a.line, b.line);
}

Line_Sample::Line_Sample(const Line_Sample& other226) {
  line = other226.line;
}
Line_Sample& Line_Sample::operator=(const Line_Sample& other227) {
  line = other227.line;
  return *this;
}
void Line_Sample::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Line_Sample(";
  out << "line=" << to_string(line);
  out << ")";
}


Transform3::~Transform3() noexcept {
}

std::ostream& operator<<(std::ostream& out, const Transform3& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Transform3::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Transform3::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Transform3");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Transform3 &a, Transform3 &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

Transform3::Transform3(const Transform3& other228) noexcept {
  (void) other228;
}
Transform3& Transform3::operator=(const Transform3& other229) noexcept {
  (void) other229;
  return *this;
}
void Transform3::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Transform3(";
  out << ")";
}


Sparse_Table::~Sparse_Table() noexcept {
}


void Sparse_Table::__set_table(const table2& val) {
  this->table = val;
}
std::ostream& operator<<(std::ostream& out, const Sparse_Table& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Sparse_Table::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Sparse_Table::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Sparse_Table");

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Sparse_Table &a, Sparse_Table &b) {
  using ::std::swap;
  swap(a.table, b.table);
}

Sparse_Table::Sparse_Table(const Sparse_Table& other230) noexcept {
  table = other230.table;
}
Sparse_Table& Sparse_Table::operator=(const Sparse_Table& other231) noexcept {
  table = other231.table;
  return *this;
}
void Sparse_Table::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Sparse_Table(";
  out << "table=" << to_string(table);
  out << ")";
}


Drover::~Drover() noexcept {
}


void Drover::__set_contour_data(const std::vector<Contour_Data> & val) {
  this->contour_data = val;
__isset.contour_data = true;
}

void Drover::__set_image_data(const std::vector<Image_Array> & val) {
  this->image_data = val;
__isset.image_data = true;
}

void Drover::__set_point_data(const std::vector<Point_Cloud> & val) {
  this->point_data = val;
__isset.point_data = true;
}

void Drover::__set_smesh_data(const std::vector<Surface_Mesh> & val) {
  this->smesh_data = val;
__isset.smesh_data = true;
}

void Drover::__set_rtplan_data(const std::vector<RTPlan> & val) {
  this->rtplan_data = val;
__isset.rtplan_data = true;
}

void Drover::__set_lsamp_data(const std::vector<Line_Sample> & val) {
  this->lsamp_data = val;
__isset.lsamp_data = true;
}

void Drover::__set_trans_data(const std::vector<Transform3> & val) {
  this->trans_data = val;
__isset.trans_data = true;
}

void Drover::__set_table_data(const std::vector<Sparse_Table> & val) {
  this->table_data = val;
__isset.table_data = true;
}
std::ostream& operator<<(std::ostream& out, const Drover& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Drover::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->contour_data.clear();
            uint32_t _size232;
            ::apache::thrift::protocol::TType _etype235;
            xfer += iprot->readListBegin(_etype235, _size232);
            this->contour_data.resize(_size232);
            uint32_t _i236;
            for (_i236 = 0; _i236 < _size232; ++_i236)
            {
              xfer += this->contour_data[_i236].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.contour_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->image_data.clear();
            uint32_t _size237;
            ::apache::thrift::protocol::TType _etype240;
            xfer += iprot->readListBegin(_etype240, _size237);
            this->image_data.resize(_size237);
            uint32_t _i241;
            for (_i241 = 0; _i241 < _size237; ++_i241)
            {
              xfer += this->image_data[_i241].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.image_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->point_data.clear();
            uint32_t _size242;
            ::apache::thrift::protocol::TType _etype245;
            xfer += iprot->readListBegin(_etype245, _size242);
            this->point_data.resize(_size242);
            uint32_t _i246;
            for (_i246 = 0; _i246 < _size242; ++_i246)
            {
              xfer += this->point_data[_i246].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.point_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->smesh_data.clear();
            uint32_t _size247;
            ::apache::thrift::protocol::TType _etype250;
            xfer += iprot->readListBegin(_etype250, _size247);
            this->smesh_data.resize(_size247);
            uint32_t _i251;
            for (_i251 = 0; _i251 < _size247; ++_i251)
            {
              xfer += this->smesh_data[_i251].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.smesh_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rtplan_data.clear();
            uint32_t _size252;
            ::apache::thrift::protocol::TType _etype255;
            xfer += iprot->readListBegin(_etype255, _size252);
            this->rtplan_data.resize(_size252);
            uint32_t _i256;
            for (_i256 = 0; _i256 < _size252; ++_i256)
            {
              xfer += this->rtplan_data[_i256].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rtplan_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lsamp_data.clear();
            uint32_t _size257;
            ::apache::thrift::protocol::TType _etype260;
            xfer += iprot->readListBegin(_etype260, _size257);
            this->lsamp_data.resize(_size257);
            uint32_t _i261;
            for (_i261 = 0; _i261 < _size257; ++_i261)
            {
              xfer += this->lsamp_data[_i261].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lsamp_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->trans_data.clear();
            uint32_t _size262;
            ::apache::thrift::protocol::TType _etype265;
            xfer += iprot->readListBegin(_etype265, _size262);
            this->trans_data.resize(_size262);
            uint32_t _i266;
            for (_i266 = 0; _i266 < _size262; ++_i266)
            {
              xfer += this->trans_data[_i266].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.trans_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_data.clear();
            uint32_t _size267;
            ::apache::thrift::protocol::TType _etype270;
            xfer += iprot->readListBegin(_etype270, _size267);
            this->table_data.resize(_size267);
            uint32_t _i271;
            for (_i271 = 0; _i271 < _size267; ++_i271)
            {
              xfer += this->table_data[_i271].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Drover::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Drover");

  if (this->__isset.contour_data) {
    xfer += oprot->writeFieldBegin("contour_data", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->contour_data.size()));
      std::vector<Contour_Data> ::const_iterator _iter272;
      for (_iter272 = this->contour_data.begin(); _iter272 != this->contour_data.end(); ++_iter272)
      {
        xfer += (*_iter272).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.image_data) {
    xfer += oprot->writeFieldBegin("image_data", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->image_data.size()));
      std::vector<Image_Array> ::const_iterator _iter273;
      for (_iter273 = this->image_data.begin(); _iter273 != this->image_data.end(); ++_iter273)
      {
        xfer += (*_iter273).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.point_data) {
    xfer += oprot->writeFieldBegin("point_data", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->point_data.size()));
      std::vector<Point_Cloud> ::const_iterator _iter274;
      for (_iter274 = this->point_data.begin(); _iter274 != this->point_data.end(); ++_iter274)
      {
        xfer += (*_iter274).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.smesh_data) {
    xfer += oprot->writeFieldBegin("smesh_data", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->smesh_data.size()));
      std::vector<Surface_Mesh> ::const_iterator _iter275;
      for (_iter275 = this->smesh_data.begin(); _iter275 != this->smesh_data.end(); ++_iter275)
      {
        xfer += (*_iter275).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rtplan_data) {
    xfer += oprot->writeFieldBegin("rtplan_data", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rtplan_data.size()));
      std::vector<RTPlan> ::const_iterator _iter276;
      for (_iter276 = this->rtplan_data.begin(); _iter276 != this->rtplan_data.end(); ++_iter276)
      {
        xfer += (*_iter276).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lsamp_data) {
    xfer += oprot->writeFieldBegin("lsamp_data", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lsamp_data.size()));
      std::vector<Line_Sample> ::const_iterator _iter277;
      for (_iter277 = this->lsamp_data.begin(); _iter277 != this->lsamp_data.end(); ++_iter277)
      {
        xfer += (*_iter277).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.trans_data) {
    xfer += oprot->writeFieldBegin("trans_data", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->trans_data.size()));
      std::vector<Transform3> ::const_iterator _iter278;
      for (_iter278 = this->trans_data.begin(); _iter278 != this->trans_data.end(); ++_iter278)
      {
        xfer += (*_iter278).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_data) {
    xfer += oprot->writeFieldBegin("table_data", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->table_data.size()));
      std::vector<Sparse_Table> ::const_iterator _iter279;
      for (_iter279 = this->table_data.begin(); _iter279 != this->table_data.end(); ++_iter279)
      {
        xfer += (*_iter279).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Drover &a, Drover &b) {
  using ::std::swap;
  swap(a.contour_data, b.contour_data);
  swap(a.image_data, b.image_data);
  swap(a.point_data, b.point_data);
  swap(a.smesh_data, b.smesh_data);
  swap(a.rtplan_data, b.rtplan_data);
  swap(a.lsamp_data, b.lsamp_data);
  swap(a.trans_data, b.trans_data);
  swap(a.table_data, b.table_data);
  swap(a.__isset, b.__isset);
}

Drover::Drover(const Drover& other280) {
  contour_data = other280.contour_data;
  image_data = other280.image_data;
  point_data = other280.point_data;
  smesh_data = other280.smesh_data;
  rtplan_data = other280.rtplan_data;
  lsamp_data = other280.lsamp_data;
  trans_data = other280.trans_data;
  table_data = other280.table_data;
  __isset = other280.__isset;
}
Drover& Drover::operator=(const Drover& other281) {
  contour_data = other281.contour_data;
  image_data = other281.image_data;
  point_data = other281.point_data;
  smesh_data = other281.smesh_data;
  rtplan_data = other281.rtplan_data;
  lsamp_data = other281.lsamp_data;
  trans_data = other281.trans_data;
  table_data = other281.table_data;
  __isset = other281.__isset;
  return *this;
}
void Drover::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Drover(";
  out << "contour_data="; (__isset.contour_data ? (out << to_string(contour_data)) : (out << "<null>"));
  out << ", " << "image_data="; (__isset.image_data ? (out << to_string(image_data)) : (out << "<null>"));
  out << ", " << "point_data="; (__isset.point_data ? (out << to_string(point_data)) : (out << "<null>"));
  out << ", " << "smesh_data="; (__isset.smesh_data ? (out << to_string(smesh_data)) : (out << "<null>"));
  out << ", " << "rtplan_data="; (__isset.rtplan_data ? (out << to_string(rtplan_data)) : (out << "<null>"));
  out << ", " << "lsamp_data="; (__isset.lsamp_data ? (out << to_string(lsamp_data)) : (out << "<null>"));
  out << ", " << "trans_data="; (__isset.trans_data ? (out << to_string(trans_data)) : (out << "<null>"));
  out << ", " << "table_data="; (__isset.table_data ? (out << to_string(table_data)) : (out << "<null>"));
  out << ")";
}


OperationsQuery::~OperationsQuery() noexcept {
}

std::ostream& operator<<(std::ostream& out, const OperationsQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OperationsQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OperationsQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OperationsQuery");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OperationsQuery &a, OperationsQuery &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

OperationsQuery::OperationsQuery(const OperationsQuery& other282) noexcept {
  (void) other282;
}
OperationsQuery& OperationsQuery::operator=(const OperationsQuery& other283) noexcept {
  (void) other283;
  return *this;
}
void OperationsQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OperationsQuery(";
  out << ")";
}


KnownOperation::~KnownOperation() noexcept {
}


void KnownOperation::__set_name(const std::string& val) {
  this->name = val;
}
std::ostream& operator<<(std::ostream& out, const KnownOperation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KnownOperation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KnownOperation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KnownOperation");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KnownOperation &a, KnownOperation &b) {
  using ::std::swap;
  swap(a.name, b.name);
}

KnownOperation::KnownOperation(const KnownOperation& other284) {
  name = other284.name;
}
KnownOperation& KnownOperation::operator=(const KnownOperation& other285) {
  name = other285.name;
  return *this;
}
void KnownOperation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KnownOperation(";
  out << "name=" << to_string(name);
  out << ")";
}


LoadFilesQuery::~LoadFilesQuery() noexcept {
}


void LoadFilesQuery::__set_server_filename(const std::string& val) {
  this->server_filename = val;
}
std::ostream& operator<<(std::ostream& out, const LoadFilesQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LoadFilesQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_server_filename = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_filename);
          isset_server_filename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_server_filename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LoadFilesQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LoadFilesQuery");

  xfer += oprot->writeFieldBegin("server_filename", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->server_filename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LoadFilesQuery &a, LoadFilesQuery &b) {
  using ::std::swap;
  swap(a.server_filename, b.server_filename);
}

LoadFilesQuery::LoadFilesQuery(const LoadFilesQuery& other286) {
  server_filename = other286.server_filename;
}
LoadFilesQuery& LoadFilesQuery::operator=(const LoadFilesQuery& other287) {
  server_filename = other287.server_filename;
  return *this;
}
void LoadFilesQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LoadFilesQuery(";
  out << "server_filename=" << to_string(server_filename);
  out << ")";
}


LoadFilesResponse::~LoadFilesResponse() noexcept {
}


void LoadFilesResponse::__set_success(const bool val) {
  this->success = val;
}

void LoadFilesResponse::__set_drover(const Drover& val) {
  this->drover = val;
__isset.drover = true;
}
std::ostream& operator<<(std::ostream& out, const LoadFilesResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LoadFilesResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_success = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          isset_success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drover.read(iprot);
          this->__isset.drover = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_success)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LoadFilesResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LoadFilesResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.drover) {
    xfer += oprot->writeFieldBegin("drover", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->drover.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LoadFilesResponse &a, LoadFilesResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.drover, b.drover);
  swap(a.__isset, b.__isset);
}

LoadFilesResponse::LoadFilesResponse(const LoadFilesResponse& other288) {
  success = other288.success;
  drover = other288.drover;
  __isset = other288.__isset;
}
LoadFilesResponse& LoadFilesResponse::operator=(const LoadFilesResponse& other289) {
  success = other289.success;
  drover = other289.drover;
  __isset = other289.__isset;
  return *this;
}
void LoadFilesResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LoadFilesResponse(";
  out << "success=" << to_string(success);
  out << ", " << "drover="; (__isset.drover ? (out << to_string(drover)) : (out << "<null>"));
  out << ")";
}

}} // namespace
