/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "DCMA_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dcma { namespace rpc {


vec3_double::~vec3_double() noexcept {
}


void vec3_double::__set_x(const double val) {
  this->x = val;
}

void vec3_double::__set_y(const double val) {
  this->y = val;
}

void vec3_double::__set_z(const double val) {
  this->z = val;
}
std::ostream& operator<<(std::ostream& out, const vec3_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t vec3_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_x = false;
  bool isset_y = false;
  bool isset_z = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          isset_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          isset_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          isset_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_x)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_y)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_z)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t vec3_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("vec3_double");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(vec3_double &a, vec3_double &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
}

vec3_double::vec3_double(const vec3_double& other0) noexcept {
  x = other0.x;
  y = other0.y;
  z = other0.z;
}
vec3_double& vec3_double::operator=(const vec3_double& other1) noexcept {
  x = other1.x;
  y = other1.y;
  z = other1.z;
  return *this;
}
void vec3_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "vec3_double(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z=" << to_string(z);
  out << ")";
}


contour_of_points_double::~contour_of_points_double() noexcept {
}


void contour_of_points_double::__set_points(const std::vector<vec3_double> & val) {
  this->points = val;
}

void contour_of_points_double::__set_closed(const bool val) {
  this->closed = val;
}

void contour_of_points_double::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const contour_of_points_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t contour_of_points_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_points = false;
  bool isset_closed = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->points.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->points.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->points[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_points = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->closed);
          isset_closed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _ktype8;
            ::apache::thrift::protocol::TType _vtype9;
            xfer += iprot->readMapBegin(_ktype8, _vtype9, _size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              std::string _key12;
              xfer += iprot->readString(_key12);
              std::string& _val13 = this->metadata[_key12];
              xfer += iprot->readString(_val13);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_points)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_closed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t contour_of_points_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("contour_of_points_double");

  xfer += oprot->writeFieldBegin("points", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->points.size()));
    std::vector<vec3_double> ::const_iterator _iter14;
    for (_iter14 = this->points.begin(); _iter14 != this->points.end(); ++_iter14)
    {
      xfer += (*_iter14).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("closed", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->closed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter15;
    for (_iter15 = this->metadata.begin(); _iter15 != this->metadata.end(); ++_iter15)
    {
      xfer += oprot->writeString(_iter15->first);
      xfer += oprot->writeString(_iter15->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(contour_of_points_double &a, contour_of_points_double &b) {
  using ::std::swap;
  swap(a.points, b.points);
  swap(a.closed, b.closed);
  swap(a.metadata, b.metadata);
}

contour_of_points_double::contour_of_points_double(const contour_of_points_double& other16) {
  points = other16.points;
  closed = other16.closed;
  metadata = other16.metadata;
}
contour_of_points_double& contour_of_points_double::operator=(const contour_of_points_double& other17) {
  points = other17.points;
  closed = other17.closed;
  metadata = other17.metadata;
  return *this;
}
void contour_of_points_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "contour_of_points_double(";
  out << "points=" << to_string(points);
  out << ", " << "closed=" << to_string(closed);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


contour_collection_double::~contour_collection_double() noexcept {
}


void contour_collection_double::__set_contours(const std::vector<contour_of_points_double> & val) {
  this->contours = val;
}
std::ostream& operator<<(std::ostream& out, const contour_collection_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t contour_collection_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_contours = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->contours.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->contours.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += this->contours[_i22].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_contours = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_contours)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t contour_collection_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("contour_collection_double");

  xfer += oprot->writeFieldBegin("contours", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->contours.size()));
    std::vector<contour_of_points_double> ::const_iterator _iter23;
    for (_iter23 = this->contours.begin(); _iter23 != this->contours.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(contour_collection_double &a, contour_collection_double &b) {
  using ::std::swap;
  swap(a.contours, b.contours);
}

contour_collection_double::contour_collection_double(const contour_collection_double& other24) {
  contours = other24.contours;
}
contour_collection_double& contour_collection_double::operator=(const contour_collection_double& other25) {
  contours = other25.contours;
  return *this;
}
void contour_collection_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "contour_collection_double(";
  out << "contours=" << to_string(contours);
  out << ")";
}


point_set_double::~point_set_double() noexcept {
}


void point_set_double::__set_points(const std::vector<vec3_double> & val) {
  this->points = val;
}

void point_set_double::__set_normals(const std::vector<vec3_double> & val) {
  this->normals = val;
}

void point_set_double::__set_colours(const std::vector<int64_t> & val) {
  this->colours = val;
}

void point_set_double::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const point_set_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t point_set_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_points = false;
  bool isset_normals = false;
  bool isset_colours = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->points.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->points.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->points[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_points = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->normals.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->normals.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->normals[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_normals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colours.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->colours.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readI64(this->colours[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          isset_colours = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _ktype42;
            ::apache::thrift::protocol::TType _vtype43;
            xfer += iprot->readMapBegin(_ktype42, _vtype43, _size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              std::string _key46;
              xfer += iprot->readString(_key46);
              std::string& _val47 = this->metadata[_key46];
              xfer += iprot->readString(_val47);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_points)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_normals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colours)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t point_set_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("point_set_double");

  xfer += oprot->writeFieldBegin("points", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->points.size()));
    std::vector<vec3_double> ::const_iterator _iter48;
    for (_iter48 = this->points.begin(); _iter48 != this->points.end(); ++_iter48)
    {
      xfer += (*_iter48).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("normals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->normals.size()));
    std::vector<vec3_double> ::const_iterator _iter49;
    for (_iter49 = this->normals.begin(); _iter49 != this->normals.end(); ++_iter49)
    {
      xfer += (*_iter49).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colours", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->colours.size()));
    std::vector<int64_t> ::const_iterator _iter50;
    for (_iter50 = this->colours.begin(); _iter50 != this->colours.end(); ++_iter50)
    {
      xfer += oprot->writeI64((*_iter50));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter51;
    for (_iter51 = this->metadata.begin(); _iter51 != this->metadata.end(); ++_iter51)
    {
      xfer += oprot->writeString(_iter51->first);
      xfer += oprot->writeString(_iter51->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(point_set_double &a, point_set_double &b) {
  using ::std::swap;
  swap(a.points, b.points);
  swap(a.normals, b.normals);
  swap(a.colours, b.colours);
  swap(a.metadata, b.metadata);
}

point_set_double::point_set_double(const point_set_double& other52) {
  points = other52.points;
  normals = other52.normals;
  colours = other52.colours;
  metadata = other52.metadata;
}
point_set_double& point_set_double::operator=(const point_set_double& other53) {
  points = other53.points;
  normals = other53.normals;
  colours = other53.colours;
  metadata = other53.metadata;
  return *this;
}
void point_set_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "point_set_double(";
  out << "points=" << to_string(points);
  out << ", " << "normals=" << to_string(normals);
  out << ", " << "colours=" << to_string(colours);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


sample4_double::~sample4_double() noexcept {
}


void sample4_double::__set_x(const double val) {
  this->x = val;
}

void sample4_double::__set_sigma_x(const double val) {
  this->sigma_x = val;
}

void sample4_double::__set_f(const double val) {
  this->f = val;
}

void sample4_double::__set_sigma_f(const double val) {
  this->sigma_f = val;
}
std::ostream& operator<<(std::ostream& out, const sample4_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t sample4_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_x = false;
  bool isset_sigma_x = false;
  bool isset_f = false;
  bool isset_sigma_f = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          isset_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->sigma_x);
          isset_sigma_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->f);
          isset_f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->sigma_f);
          isset_sigma_f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_x)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sigma_x)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_f)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sigma_f)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t sample4_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("sample4_double");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sigma_x", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->sigma_x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->f);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sigma_f", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->sigma_f);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(sample4_double &a, sample4_double &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.sigma_x, b.sigma_x);
  swap(a.f, b.f);
  swap(a.sigma_f, b.sigma_f);
}

sample4_double::sample4_double(const sample4_double& other54) noexcept {
  x = other54.x;
  sigma_x = other54.sigma_x;
  f = other54.f;
  sigma_f = other54.sigma_f;
}
sample4_double& sample4_double::operator=(const sample4_double& other55) noexcept {
  x = other55.x;
  sigma_x = other55.sigma_x;
  f = other55.f;
  sigma_f = other55.sigma_f;
  return *this;
}
void sample4_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "sample4_double(";
  out << "x=" << to_string(x);
  out << ", " << "sigma_x=" << to_string(sigma_x);
  out << ", " << "f=" << to_string(f);
  out << ", " << "sigma_f=" << to_string(sigma_f);
  out << ")";
}


samples_1D_double::~samples_1D_double() noexcept {
}


void samples_1D_double::__set_samples(const std::vector<sample4_double> & val) {
  this->samples = val;
}

void samples_1D_double::__set_uncertainties_known_to_be_independent_and_random(const bool val) {
  this->uncertainties_known_to_be_independent_and_random = val;
}

void samples_1D_double::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const samples_1D_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t samples_1D_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_samples = false;
  bool isset_uncertainties_known_to_be_independent_and_random = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->samples.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->samples.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += this->samples[_i60].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_samples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->uncertainties_known_to_be_independent_and_random);
          isset_uncertainties_known_to_be_independent_and_random = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _ktype62;
            ::apache::thrift::protocol::TType _vtype63;
            xfer += iprot->readMapBegin(_ktype62, _vtype63, _size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              std::string _key66;
              xfer += iprot->readString(_key66);
              std::string& _val67 = this->metadata[_key66];
              xfer += iprot->readString(_val67);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_samples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_uncertainties_known_to_be_independent_and_random)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t samples_1D_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("samples_1D_double");

  xfer += oprot->writeFieldBegin("samples", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->samples.size()));
    std::vector<sample4_double> ::const_iterator _iter68;
    for (_iter68 = this->samples.begin(); _iter68 != this->samples.end(); ++_iter68)
    {
      xfer += (*_iter68).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uncertainties_known_to_be_independent_and_random", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->uncertainties_known_to_be_independent_and_random);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter69;
    for (_iter69 = this->metadata.begin(); _iter69 != this->metadata.end(); ++_iter69)
    {
      xfer += oprot->writeString(_iter69->first);
      xfer += oprot->writeString(_iter69->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(samples_1D_double &a, samples_1D_double &b) {
  using ::std::swap;
  swap(a.samples, b.samples);
  swap(a.uncertainties_known_to_be_independent_and_random, b.uncertainties_known_to_be_independent_and_random);
  swap(a.metadata, b.metadata);
}

samples_1D_double::samples_1D_double(const samples_1D_double& other70) {
  samples = other70.samples;
  uncertainties_known_to_be_independent_and_random = other70.uncertainties_known_to_be_independent_and_random;
  metadata = other70.metadata;
}
samples_1D_double& samples_1D_double::operator=(const samples_1D_double& other71) {
  samples = other71.samples;
  uncertainties_known_to_be_independent_and_random = other71.uncertainties_known_to_be_independent_and_random;
  metadata = other71.metadata;
  return *this;
}
void samples_1D_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "samples_1D_double(";
  out << "samples=" << to_string(samples);
  out << ", " << "uncertainties_known_to_be_independent_and_random=" << to_string(uncertainties_known_to_be_independent_and_random);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


fv_surface_mesh_double_int64::~fv_surface_mesh_double_int64() noexcept {
}


void fv_surface_mesh_double_int64::__set_vertices(const std::vector<vec3_double> & val) {
  this->vertices = val;
}

void fv_surface_mesh_double_int64::__set_vertex_normals(const std::vector<vec3_double> & val) {
  this->vertex_normals = val;
}

void fv_surface_mesh_double_int64::__set_vertex_colours(const std::vector<int64_t> & val) {
  this->vertex_colours = val;
}

void fv_surface_mesh_double_int64::__set_faces(const std::vector<std::vector<int64_t> > & val) {
  this->faces = val;
}

void fv_surface_mesh_double_int64::__set_involved_faces(const std::vector<std::vector<int64_t> > & val) {
  this->involved_faces = val;
}

void fv_surface_mesh_double_int64::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const fv_surface_mesh_double_int64& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t fv_surface_mesh_double_int64::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_vertices = false;
  bool isset_vertex_normals = false;
  bool isset_vertex_colours = false;
  bool isset_faces = false;
  bool isset_involved_faces = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vertices.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->vertices.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += this->vertices[_i76].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_vertices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vertex_normals.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->vertex_normals.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->vertex_normals[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_vertex_normals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vertex_colours.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _etype85;
            xfer += iprot->readListBegin(_etype85, _size82);
            this->vertex_colours.resize(_size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              xfer += iprot->readI64(this->vertex_colours[_i86]);
            }
            xfer += iprot->readListEnd();
          }
          isset_vertex_colours = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->faces.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            this->faces.resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              {
                this->faces[_i91].clear();
                uint32_t _size92;
                ::apache::thrift::protocol::TType _etype95;
                xfer += iprot->readListBegin(_etype95, _size92);
                this->faces[_i91].resize(_size92);
                uint32_t _i96;
                for (_i96 = 0; _i96 < _size92; ++_i96)
                {
                  xfer += iprot->readI64(this->faces[_i91][_i96]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_faces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->involved_faces.clear();
            uint32_t _size97;
            ::apache::thrift::protocol::TType _etype100;
            xfer += iprot->readListBegin(_etype100, _size97);
            this->involved_faces.resize(_size97);
            uint32_t _i101;
            for (_i101 = 0; _i101 < _size97; ++_i101)
            {
              {
                this->involved_faces[_i101].clear();
                uint32_t _size102;
                ::apache::thrift::protocol::TType _etype105;
                xfer += iprot->readListBegin(_etype105, _size102);
                this->involved_faces[_i101].resize(_size102);
                uint32_t _i106;
                for (_i106 = 0; _i106 < _size102; ++_i106)
                {
                  xfer += iprot->readI64(this->involved_faces[_i101][_i106]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_involved_faces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size107;
            ::apache::thrift::protocol::TType _ktype108;
            ::apache::thrift::protocol::TType _vtype109;
            xfer += iprot->readMapBegin(_ktype108, _vtype109, _size107);
            uint32_t _i111;
            for (_i111 = 0; _i111 < _size107; ++_i111)
            {
              std::string _key112;
              xfer += iprot->readString(_key112);
              std::string& _val113 = this->metadata[_key112];
              xfer += iprot->readString(_val113);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_vertices)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_vertex_normals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_vertex_colours)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_faces)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_involved_faces)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t fv_surface_mesh_double_int64::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("fv_surface_mesh_double_int64");

  xfer += oprot->writeFieldBegin("vertices", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vertices.size()));
    std::vector<vec3_double> ::const_iterator _iter114;
    for (_iter114 = this->vertices.begin(); _iter114 != this->vertices.end(); ++_iter114)
    {
      xfer += (*_iter114).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vertex_normals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vertex_normals.size()));
    std::vector<vec3_double> ::const_iterator _iter115;
    for (_iter115 = this->vertex_normals.begin(); _iter115 != this->vertex_normals.end(); ++_iter115)
    {
      xfer += (*_iter115).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vertex_colours", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->vertex_colours.size()));
    std::vector<int64_t> ::const_iterator _iter116;
    for (_iter116 = this->vertex_colours.begin(); _iter116 != this->vertex_colours.end(); ++_iter116)
    {
      xfer += oprot->writeI64((*_iter116));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("faces", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->faces.size()));
    std::vector<std::vector<int64_t> > ::const_iterator _iter117;
    for (_iter117 = this->faces.begin(); _iter117 != this->faces.end(); ++_iter117)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*_iter117).size()));
        std::vector<int64_t> ::const_iterator _iter118;
        for (_iter118 = (*_iter117).begin(); _iter118 != (*_iter117).end(); ++_iter118)
        {
          xfer += oprot->writeI64((*_iter118));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("involved_faces", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->involved_faces.size()));
    std::vector<std::vector<int64_t> > ::const_iterator _iter119;
    for (_iter119 = this->involved_faces.begin(); _iter119 != this->involved_faces.end(); ++_iter119)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*_iter119).size()));
        std::vector<int64_t> ::const_iterator _iter120;
        for (_iter120 = (*_iter119).begin(); _iter120 != (*_iter119).end(); ++_iter120)
        {
          xfer += oprot->writeI64((*_iter120));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter121;
    for (_iter121 = this->metadata.begin(); _iter121 != this->metadata.end(); ++_iter121)
    {
      xfer += oprot->writeString(_iter121->first);
      xfer += oprot->writeString(_iter121->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(fv_surface_mesh_double_int64 &a, fv_surface_mesh_double_int64 &b) {
  using ::std::swap;
  swap(a.vertices, b.vertices);
  swap(a.vertex_normals, b.vertex_normals);
  swap(a.vertex_colours, b.vertex_colours);
  swap(a.faces, b.faces);
  swap(a.involved_faces, b.involved_faces);
  swap(a.metadata, b.metadata);
}

fv_surface_mesh_double_int64::fv_surface_mesh_double_int64(const fv_surface_mesh_double_int64& other122) {
  vertices = other122.vertices;
  vertex_normals = other122.vertex_normals;
  vertex_colours = other122.vertex_colours;
  faces = other122.faces;
  involved_faces = other122.involved_faces;
  metadata = other122.metadata;
}
fv_surface_mesh_double_int64& fv_surface_mesh_double_int64::operator=(const fv_surface_mesh_double_int64& other123) {
  vertices = other123.vertices;
  vertex_normals = other123.vertex_normals;
  vertex_colours = other123.vertex_colours;
  faces = other123.faces;
  involved_faces = other123.involved_faces;
  metadata = other123.metadata;
  return *this;
}
void fv_surface_mesh_double_int64::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "fv_surface_mesh_double_int64(";
  out << "vertices=" << to_string(vertices);
  out << ", " << "vertex_normals=" << to_string(vertex_normals);
  out << ", " << "vertex_colours=" << to_string(vertex_colours);
  out << ", " << "faces=" << to_string(faces);
  out << ", " << "involved_faces=" << to_string(involved_faces);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


planar_image_double_double::~planar_image_double_double() noexcept {
}


void planar_image_double_double::__set_data(const std::vector<double> & val) {
  this->data = val;
}

void planar_image_double_double::__set_rows(const int64_t val) {
  this->rows = val;
}

void planar_image_double_double::__set_columns(const int64_t val) {
  this->columns = val;
}

void planar_image_double_double::__set_channels(const int64_t val) {
  this->channels = val;
}

void planar_image_double_double::__set_pxl_dx(const double val) {
  this->pxl_dx = val;
}

void planar_image_double_double::__set_pxl_dy(const double val) {
  this->pxl_dy = val;
}

void planar_image_double_double::__set_pxl_dz(const double val) {
  this->pxl_dz = val;
}

void planar_image_double_double::__set_anchor(const vec3_double& val) {
  this->anchor = val;
}

void planar_image_double_double::__set_offset(const vec3_double& val) {
  this->offset = val;
}

void planar_image_double_double::__set_row_unit(const vec3_double& val) {
  this->row_unit = val;
}

void planar_image_double_double::__set_col_unit(const vec3_double& val) {
  this->col_unit = val;
}

void planar_image_double_double::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const planar_image_double_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t planar_image_double_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;
  bool isset_rows = false;
  bool isset_columns = false;
  bool isset_channels = false;
  bool isset_pxl_dx = false;
  bool isset_pxl_dy = false;
  bool isset_pxl_dz = false;
  bool isset_anchor = false;
  bool isset_offset = false;
  bool isset_row_unit = false;
  bool isset_col_unit = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _etype127;
            xfer += iprot->readListBegin(_etype127, _size124);
            this->data.resize(_size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              xfer += iprot->readDouble(this->data[_i128]);
            }
            xfer += iprot->readListEnd();
          }
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows);
          isset_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->columns);
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->channels);
          isset_channels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pxl_dx);
          isset_pxl_dx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pxl_dy);
          isset_pxl_dy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pxl_dz);
          isset_pxl_dz = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->anchor.read(iprot);
          isset_anchor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->offset.read(iprot);
          isset_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_unit.read(iprot);
          isset_row_unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->col_unit.read(iprot);
          isset_col_unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size129;
            ::apache::thrift::protocol::TType _ktype130;
            ::apache::thrift::protocol::TType _vtype131;
            xfer += iprot->readMapBegin(_ktype130, _vtype131, _size129);
            uint32_t _i133;
            for (_i133 = 0; _i133 < _size129; ++_i133)
            {
              std::string _key134;
              xfer += iprot->readString(_key134);
              std::string& _val135 = this->metadata[_key134];
              xfer += iprot->readString(_val135);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_channels)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pxl_dx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pxl_dy)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pxl_dz)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_anchor)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_offset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_row_unit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_col_unit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t planar_image_double_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("planar_image_double_double");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->data.size()));
    std::vector<double> ::const_iterator _iter136;
    for (_iter136 = this->data.begin(); _iter136 != this->data.end(); ++_iter136)
    {
      xfer += oprot->writeDouble((*_iter136));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->columns);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("channels", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->channels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pxl_dx", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->pxl_dx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pxl_dy", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->pxl_dy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pxl_dz", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->pxl_dz);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("anchor", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->anchor.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->offset.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_unit", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->row_unit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_unit", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->col_unit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 12);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter137;
    for (_iter137 = this->metadata.begin(); _iter137 != this->metadata.end(); ++_iter137)
    {
      xfer += oprot->writeString(_iter137->first);
      xfer += oprot->writeString(_iter137->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(planar_image_double_double &a, planar_image_double_double &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.rows, b.rows);
  swap(a.columns, b.columns);
  swap(a.channels, b.channels);
  swap(a.pxl_dx, b.pxl_dx);
  swap(a.pxl_dy, b.pxl_dy);
  swap(a.pxl_dz, b.pxl_dz);
  swap(a.anchor, b.anchor);
  swap(a.offset, b.offset);
  swap(a.row_unit, b.row_unit);
  swap(a.col_unit, b.col_unit);
  swap(a.metadata, b.metadata);
}

planar_image_double_double::planar_image_double_double(const planar_image_double_double& other138) {
  data = other138.data;
  rows = other138.rows;
  columns = other138.columns;
  channels = other138.channels;
  pxl_dx = other138.pxl_dx;
  pxl_dy = other138.pxl_dy;
  pxl_dz = other138.pxl_dz;
  anchor = other138.anchor;
  offset = other138.offset;
  row_unit = other138.row_unit;
  col_unit = other138.col_unit;
  metadata = other138.metadata;
}
planar_image_double_double& planar_image_double_double::operator=(const planar_image_double_double& other139) {
  data = other139.data;
  rows = other139.rows;
  columns = other139.columns;
  channels = other139.channels;
  pxl_dx = other139.pxl_dx;
  pxl_dy = other139.pxl_dy;
  pxl_dz = other139.pxl_dz;
  anchor = other139.anchor;
  offset = other139.offset;
  row_unit = other139.row_unit;
  col_unit = other139.col_unit;
  metadata = other139.metadata;
  return *this;
}
void planar_image_double_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "planar_image_double_double(";
  out << "data=" << to_string(data);
  out << ", " << "rows=" << to_string(rows);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "channels=" << to_string(channels);
  out << ", " << "pxl_dx=" << to_string(pxl_dx);
  out << ", " << "pxl_dy=" << to_string(pxl_dy);
  out << ", " << "pxl_dz=" << to_string(pxl_dz);
  out << ", " << "anchor=" << to_string(anchor);
  out << ", " << "offset=" << to_string(offset);
  out << ", " << "row_unit=" << to_string(row_unit);
  out << ", " << "col_unit=" << to_string(col_unit);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


planar_image_collection_double_double::~planar_image_collection_double_double() noexcept {
}


void planar_image_collection_double_double::__set_images(const std::vector<planar_image_double_double> & val) {
  this->images = val;
}
std::ostream& operator<<(std::ostream& out, const planar_image_collection_double_double& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t planar_image_collection_double_double::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_images = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->images.clear();
            uint32_t _size140;
            ::apache::thrift::protocol::TType _etype143;
            xfer += iprot->readListBegin(_etype143, _size140);
            this->images.resize(_size140);
            uint32_t _i144;
            for (_i144 = 0; _i144 < _size140; ++_i144)
            {
              xfer += this->images[_i144].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_images = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_images)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t planar_image_collection_double_double::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("planar_image_collection_double_double");

  xfer += oprot->writeFieldBegin("images", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->images.size()));
    std::vector<planar_image_double_double> ::const_iterator _iter145;
    for (_iter145 = this->images.begin(); _iter145 != this->images.end(); ++_iter145)
    {
      xfer += (*_iter145).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(planar_image_collection_double_double &a, planar_image_collection_double_double &b) {
  using ::std::swap;
  swap(a.images, b.images);
}

planar_image_collection_double_double::planar_image_collection_double_double(const planar_image_collection_double_double& other146) {
  images = other146.images;
}
planar_image_collection_double_double& planar_image_collection_double_double::operator=(const planar_image_collection_double_double& other147) {
  images = other147.images;
  return *this;
}
void planar_image_collection_double_double::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "planar_image_collection_double_double(";
  out << "images=" << to_string(images);
  out << ")";
}


cell_string::~cell_string() noexcept {
}


void cell_string::__set_row(const int64_t val) {
  this->row = val;
}

void cell_string::__set_col(const int64_t val) {
  this->col = val;
}

void cell_string::__set_val(const std::string& val) {
  this->val = val;
}
std::ostream& operator<<(std::ostream& out, const cell_string& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t cell_string::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_col = false;
  bool isset_val = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->col);
          isset_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->val);
          isset_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_col)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_val)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t cell_string::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cell_string");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->col);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cell_string &a, cell_string &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.col, b.col);
  swap(a.val, b.val);
}

cell_string::cell_string(const cell_string& other148) {
  row = other148.row;
  col = other148.col;
  val = other148.val;
}
cell_string& cell_string::operator=(const cell_string& other149) {
  row = other149.row;
  col = other149.col;
  val = other149.val;
  return *this;
}
void cell_string::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cell_string(";
  out << "row=" << to_string(row);
  out << ", " << "col=" << to_string(col);
  out << ", " << "val=" << to_string(val);
  out << ")";
}


table2::~table2() noexcept {
}


void table2::__set_data(const std::vector<cell_string> & val) {
  this->data = val;
}

void table2::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const table2& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t table2::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size150;
            ::apache::thrift::protocol::TType _etype153;
            xfer += iprot->readListBegin(_etype153, _size150);
            this->data.resize(_size150);
            uint32_t _i154;
            for (_i154 = 0; _i154 < _size150; ++_i154)
            {
              xfer += this->data[_i154].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size155;
            ::apache::thrift::protocol::TType _ktype156;
            ::apache::thrift::protocol::TType _vtype157;
            xfer += iprot->readMapBegin(_ktype156, _vtype157, _size155);
            uint32_t _i159;
            for (_i159 = 0; _i159 < _size155; ++_i159)
            {
              std::string _key160;
              xfer += iprot->readString(_key160);
              std::string& _val161 = this->metadata[_key160];
              xfer += iprot->readString(_val161);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t table2::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("table2");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
    std::vector<cell_string> ::const_iterator _iter162;
    for (_iter162 = this->data.begin(); _iter162 != this->data.end(); ++_iter162)
    {
      xfer += (*_iter162).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter163;
    for (_iter163 = this->metadata.begin(); _iter163 != this->metadata.end(); ++_iter163)
    {
      xfer += oprot->writeString(_iter163->first);
      xfer += oprot->writeString(_iter163->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(table2 &a, table2 &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.metadata, b.metadata);
}

table2::table2(const table2& other164) {
  data = other164.data;
  metadata = other164.metadata;
}
table2& table2::operator=(const table2& other165) {
  data = other165.data;
  metadata = other165.metadata;
  return *this;
}
void table2::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "table2(";
  out << "data=" << to_string(data);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


Contour_Data::~Contour_Data() noexcept {
}


void Contour_Data::__set_ccs(const std::vector<contour_collection_double> & val) {
  this->ccs = val;
}
std::ostream& operator<<(std::ostream& out, const Contour_Data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Contour_Data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ccs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ccs.clear();
            uint32_t _size166;
            ::apache::thrift::protocol::TType _etype169;
            xfer += iprot->readListBegin(_etype169, _size166);
            this->ccs.resize(_size166);
            uint32_t _i170;
            for (_i170 = 0; _i170 < _size166; ++_i170)
            {
              xfer += this->ccs[_i170].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_ccs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ccs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Contour_Data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Contour_Data");

  xfer += oprot->writeFieldBegin("ccs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ccs.size()));
    std::vector<contour_collection_double> ::const_iterator _iter171;
    for (_iter171 = this->ccs.begin(); _iter171 != this->ccs.end(); ++_iter171)
    {
      xfer += (*_iter171).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Contour_Data &a, Contour_Data &b) {
  using ::std::swap;
  swap(a.ccs, b.ccs);
}

Contour_Data::Contour_Data(const Contour_Data& other172) {
  ccs = other172.ccs;
}
Contour_Data& Contour_Data::operator=(const Contour_Data& other173) {
  ccs = other173.ccs;
  return *this;
}
void Contour_Data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Contour_Data(";
  out << "ccs=" << to_string(ccs);
  out << ")";
}


Image_Array::~Image_Array() noexcept {
}


void Image_Array::__set_imagecoll(const planar_image_collection_double_double& val) {
  this->imagecoll = val;
}

void Image_Array::__set_filename(const std::string& val) {
  this->filename = val;
}
std::ostream& operator<<(std::ostream& out, const Image_Array& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Image_Array::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_imagecoll = false;
  bool isset_filename = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->imagecoll.read(iprot);
          isset_imagecoll = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filename);
          isset_filename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_imagecoll)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_filename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Image_Array::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Image_Array");

  xfer += oprot->writeFieldBegin("imagecoll", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->imagecoll.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->filename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Image_Array &a, Image_Array &b) {
  using ::std::swap;
  swap(a.imagecoll, b.imagecoll);
  swap(a.filename, b.filename);
}

Image_Array::Image_Array(const Image_Array& other174) {
  imagecoll = other174.imagecoll;
  filename = other174.filename;
}
Image_Array& Image_Array::operator=(const Image_Array& other175) {
  imagecoll = other175.imagecoll;
  filename = other175.filename;
  return *this;
}
void Image_Array::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Image_Array(";
  out << "imagecoll=" << to_string(imagecoll);
  out << ", " << "filename=" << to_string(filename);
  out << ")";
}


Point_Cloud::~Point_Cloud() noexcept {
}


void Point_Cloud::__set_pset(const point_set_double& val) {
  this->pset = val;
}
std::ostream& operator<<(std::ostream& out, const Point_Cloud& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Point_Cloud::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pset = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pset.read(iprot);
          isset_pset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Point_Cloud::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Point_Cloud");

  xfer += oprot->writeFieldBegin("pset", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pset.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Point_Cloud &a, Point_Cloud &b) {
  using ::std::swap;
  swap(a.pset, b.pset);
}

Point_Cloud::Point_Cloud(const Point_Cloud& other176) {
  pset = other176.pset;
}
Point_Cloud& Point_Cloud::operator=(const Point_Cloud& other177) {
  pset = other177.pset;
  return *this;
}
void Point_Cloud::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Point_Cloud(";
  out << "pset=" << to_string(pset);
  out << ")";
}


Surface_Mesh::~Surface_Mesh() noexcept {
}


void Surface_Mesh::__set_meshes(const fv_surface_mesh_double_int64& val) {
  this->meshes = val;
}
std::ostream& operator<<(std::ostream& out, const Surface_Mesh& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Surface_Mesh::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_meshes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->meshes.read(iprot);
          isset_meshes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_meshes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Surface_Mesh::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Surface_Mesh");

  xfer += oprot->writeFieldBegin("meshes", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->meshes.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Surface_Mesh &a, Surface_Mesh &b) {
  using ::std::swap;
  swap(a.meshes, b.meshes);
}

Surface_Mesh::Surface_Mesh(const Surface_Mesh& other178) {
  meshes = other178.meshes;
}
Surface_Mesh& Surface_Mesh::operator=(const Surface_Mesh& other179) {
  meshes = other179.meshes;
  return *this;
}
void Surface_Mesh::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Surface_Mesh(";
  out << "meshes=" << to_string(meshes);
  out << ")";
}


Static_Machine_State::~Static_Machine_State() noexcept {
}


void Static_Machine_State::__set_CumulativeMetersetWeight(const double val) {
  this->CumulativeMetersetWeight = val;
}

void Static_Machine_State::__set_ControlPointIndex(const int64_t val) {
  this->ControlPointIndex = val;
}

void Static_Machine_State::__set_GantryAngle(const double val) {
  this->GantryAngle = val;
}

void Static_Machine_State::__set_GantryRotationDirection(const double val) {
  this->GantryRotationDirection = val;
}

void Static_Machine_State::__set_BeamLimitingDeviceAngle(const double val) {
  this->BeamLimitingDeviceAngle = val;
}

void Static_Machine_State::__set_BeamLimitingDeviceRotationDirection(const double val) {
  this->BeamLimitingDeviceRotationDirection = val;
}

void Static_Machine_State::__set_PatientSupportAngle(const double val) {
  this->PatientSupportAngle = val;
}

void Static_Machine_State::__set_PatientSupportRotationDirection(const double val) {
  this->PatientSupportRotationDirection = val;
}

void Static_Machine_State::__set_TableTopEccentricAngle(const double val) {
  this->TableTopEccentricAngle = val;
}

void Static_Machine_State::__set_TableTopEccentricRotationDirection(const double val) {
  this->TableTopEccentricRotationDirection = val;
}

void Static_Machine_State::__set_TableTopVerticalPosition(const double val) {
  this->TableTopVerticalPosition = val;
}

void Static_Machine_State::__set_TableTopLongitudinalPosition(const double val) {
  this->TableTopLongitudinalPosition = val;
}

void Static_Machine_State::__set_TableTopLateralPosition(const double val) {
  this->TableTopLateralPosition = val;
}

void Static_Machine_State::__set_TableTopPitchAngle(const double val) {
  this->TableTopPitchAngle = val;
}

void Static_Machine_State::__set_TableTopPitchRotationDirection(const double val) {
  this->TableTopPitchRotationDirection = val;
}

void Static_Machine_State::__set_TableTopRollAngle(const double val) {
  this->TableTopRollAngle = val;
}

void Static_Machine_State::__set_TableTopRollRotationDirection(const double val) {
  this->TableTopRollRotationDirection = val;
}

void Static_Machine_State::__set_IsocentrePosition(const vec3_double& val) {
  this->IsocentrePosition = val;
}

void Static_Machine_State::__set_JawPositionsX(const std::vector<double> & val) {
  this->JawPositionsX = val;
}

void Static_Machine_State::__set_JawPositionsY(const std::vector<double> & val) {
  this->JawPositionsY = val;
}

void Static_Machine_State::__set_MLCPositionsX(const std::vector<double> & val) {
  this->MLCPositionsX = val;
}

void Static_Machine_State::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const Static_Machine_State& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Static_Machine_State::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_CumulativeMetersetWeight = false;
  bool isset_ControlPointIndex = false;
  bool isset_GantryAngle = false;
  bool isset_GantryRotationDirection = false;
  bool isset_BeamLimitingDeviceAngle = false;
  bool isset_BeamLimitingDeviceRotationDirection = false;
  bool isset_PatientSupportAngle = false;
  bool isset_PatientSupportRotationDirection = false;
  bool isset_TableTopEccentricAngle = false;
  bool isset_TableTopEccentricRotationDirection = false;
  bool isset_TableTopVerticalPosition = false;
  bool isset_TableTopLongitudinalPosition = false;
  bool isset_TableTopLateralPosition = false;
  bool isset_TableTopPitchAngle = false;
  bool isset_TableTopPitchRotationDirection = false;
  bool isset_TableTopRollAngle = false;
  bool isset_TableTopRollRotationDirection = false;
  bool isset_IsocentrePosition = false;
  bool isset_JawPositionsX = false;
  bool isset_JawPositionsY = false;
  bool isset_MLCPositionsX = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->CumulativeMetersetWeight);
          isset_CumulativeMetersetWeight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ControlPointIndex);
          isset_ControlPointIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->GantryAngle);
          isset_GantryAngle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->GantryRotationDirection);
          isset_GantryRotationDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->BeamLimitingDeviceAngle);
          isset_BeamLimitingDeviceAngle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->BeamLimitingDeviceRotationDirection);
          isset_BeamLimitingDeviceRotationDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->PatientSupportAngle);
          isset_PatientSupportAngle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->PatientSupportRotationDirection);
          isset_PatientSupportRotationDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopEccentricAngle);
          isset_TableTopEccentricAngle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopEccentricRotationDirection);
          isset_TableTopEccentricRotationDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopVerticalPosition);
          isset_TableTopVerticalPosition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopLongitudinalPosition);
          isset_TableTopLongitudinalPosition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopLateralPosition);
          isset_TableTopLateralPosition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopPitchAngle);
          isset_TableTopPitchAngle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopPitchRotationDirection);
          isset_TableTopPitchRotationDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopRollAngle);
          isset_TableTopRollAngle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TableTopRollRotationDirection);
          isset_TableTopRollRotationDirection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->IsocentrePosition.read(iprot);
          isset_IsocentrePosition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->JawPositionsX.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _etype183;
            xfer += iprot->readListBegin(_etype183, _size180);
            this->JawPositionsX.resize(_size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              xfer += iprot->readDouble(this->JawPositionsX[_i184]);
            }
            xfer += iprot->readListEnd();
          }
          isset_JawPositionsX = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->JawPositionsY.clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readListBegin(_etype188, _size185);
            this->JawPositionsY.resize(_size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              xfer += iprot->readDouble(this->JawPositionsY[_i189]);
            }
            xfer += iprot->readListEnd();
          }
          isset_JawPositionsY = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->MLCPositionsX.clear();
            uint32_t _size190;
            ::apache::thrift::protocol::TType _etype193;
            xfer += iprot->readListBegin(_etype193, _size190);
            this->MLCPositionsX.resize(_size190);
            uint32_t _i194;
            for (_i194 = 0; _i194 < _size190; ++_i194)
            {
              xfer += iprot->readDouble(this->MLCPositionsX[_i194]);
            }
            xfer += iprot->readListEnd();
          }
          isset_MLCPositionsX = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size195;
            ::apache::thrift::protocol::TType _ktype196;
            ::apache::thrift::protocol::TType _vtype197;
            xfer += iprot->readMapBegin(_ktype196, _vtype197, _size195);
            uint32_t _i199;
            for (_i199 = 0; _i199 < _size195; ++_i199)
            {
              std::string _key200;
              xfer += iprot->readString(_key200);
              std::string& _val201 = this->metadata[_key200];
              xfer += iprot->readString(_val201);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_CumulativeMetersetWeight)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ControlPointIndex)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_GantryAngle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_GantryRotationDirection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_BeamLimitingDeviceAngle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_BeamLimitingDeviceRotationDirection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_PatientSupportAngle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_PatientSupportRotationDirection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopEccentricAngle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopEccentricRotationDirection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopVerticalPosition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopLongitudinalPosition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopLateralPosition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopPitchAngle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopPitchRotationDirection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopRollAngle)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TableTopRollRotationDirection)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_IsocentrePosition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_JawPositionsX)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_JawPositionsY)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_MLCPositionsX)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Static_Machine_State::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Static_Machine_State");

  xfer += oprot->writeFieldBegin("CumulativeMetersetWeight", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->CumulativeMetersetWeight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ControlPointIndex", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ControlPointIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("GantryAngle", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->GantryAngle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("GantryRotationDirection", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->GantryRotationDirection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("BeamLimitingDeviceAngle", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->BeamLimitingDeviceAngle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("BeamLimitingDeviceRotationDirection", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->BeamLimitingDeviceRotationDirection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("PatientSupportAngle", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->PatientSupportAngle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("PatientSupportRotationDirection", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->PatientSupportRotationDirection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopEccentricAngle", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->TableTopEccentricAngle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopEccentricRotationDirection", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->TableTopEccentricRotationDirection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopVerticalPosition", ::apache::thrift::protocol::T_DOUBLE, 11);
  xfer += oprot->writeDouble(this->TableTopVerticalPosition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopLongitudinalPosition", ::apache::thrift::protocol::T_DOUBLE, 12);
  xfer += oprot->writeDouble(this->TableTopLongitudinalPosition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopLateralPosition", ::apache::thrift::protocol::T_DOUBLE, 13);
  xfer += oprot->writeDouble(this->TableTopLateralPosition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopPitchAngle", ::apache::thrift::protocol::T_DOUBLE, 14);
  xfer += oprot->writeDouble(this->TableTopPitchAngle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopPitchRotationDirection", ::apache::thrift::protocol::T_DOUBLE, 15);
  xfer += oprot->writeDouble(this->TableTopPitchRotationDirection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopRollAngle", ::apache::thrift::protocol::T_DOUBLE, 16);
  xfer += oprot->writeDouble(this->TableTopRollAngle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TableTopRollRotationDirection", ::apache::thrift::protocol::T_DOUBLE, 17);
  xfer += oprot->writeDouble(this->TableTopRollRotationDirection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("IsocentrePosition", ::apache::thrift::protocol::T_STRUCT, 18);
  xfer += this->IsocentrePosition.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("JawPositionsX", ::apache::thrift::protocol::T_LIST, 19);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->JawPositionsX.size()));
    std::vector<double> ::const_iterator _iter202;
    for (_iter202 = this->JawPositionsX.begin(); _iter202 != this->JawPositionsX.end(); ++_iter202)
    {
      xfer += oprot->writeDouble((*_iter202));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("JawPositionsY", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->JawPositionsY.size()));
    std::vector<double> ::const_iterator _iter203;
    for (_iter203 = this->JawPositionsY.begin(); _iter203 != this->JawPositionsY.end(); ++_iter203)
    {
      xfer += oprot->writeDouble((*_iter203));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MLCPositionsX", ::apache::thrift::protocol::T_LIST, 21);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->MLCPositionsX.size()));
    std::vector<double> ::const_iterator _iter204;
    for (_iter204 = this->MLCPositionsX.begin(); _iter204 != this->MLCPositionsX.end(); ++_iter204)
    {
      xfer += oprot->writeDouble((*_iter204));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 22);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter205;
    for (_iter205 = this->metadata.begin(); _iter205 != this->metadata.end(); ++_iter205)
    {
      xfer += oprot->writeString(_iter205->first);
      xfer += oprot->writeString(_iter205->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Static_Machine_State &a, Static_Machine_State &b) {
  using ::std::swap;
  swap(a.CumulativeMetersetWeight, b.CumulativeMetersetWeight);
  swap(a.ControlPointIndex, b.ControlPointIndex);
  swap(a.GantryAngle, b.GantryAngle);
  swap(a.GantryRotationDirection, b.GantryRotationDirection);
  swap(a.BeamLimitingDeviceAngle, b.BeamLimitingDeviceAngle);
  swap(a.BeamLimitingDeviceRotationDirection, b.BeamLimitingDeviceRotationDirection);
  swap(a.PatientSupportAngle, b.PatientSupportAngle);
  swap(a.PatientSupportRotationDirection, b.PatientSupportRotationDirection);
  swap(a.TableTopEccentricAngle, b.TableTopEccentricAngle);
  swap(a.TableTopEccentricRotationDirection, b.TableTopEccentricRotationDirection);
  swap(a.TableTopVerticalPosition, b.TableTopVerticalPosition);
  swap(a.TableTopLongitudinalPosition, b.TableTopLongitudinalPosition);
  swap(a.TableTopLateralPosition, b.TableTopLateralPosition);
  swap(a.TableTopPitchAngle, b.TableTopPitchAngle);
  swap(a.TableTopPitchRotationDirection, b.TableTopPitchRotationDirection);
  swap(a.TableTopRollAngle, b.TableTopRollAngle);
  swap(a.TableTopRollRotationDirection, b.TableTopRollRotationDirection);
  swap(a.IsocentrePosition, b.IsocentrePosition);
  swap(a.JawPositionsX, b.JawPositionsX);
  swap(a.JawPositionsY, b.JawPositionsY);
  swap(a.MLCPositionsX, b.MLCPositionsX);
  swap(a.metadata, b.metadata);
}

Static_Machine_State::Static_Machine_State(const Static_Machine_State& other206) {
  CumulativeMetersetWeight = other206.CumulativeMetersetWeight;
  ControlPointIndex = other206.ControlPointIndex;
  GantryAngle = other206.GantryAngle;
  GantryRotationDirection = other206.GantryRotationDirection;
  BeamLimitingDeviceAngle = other206.BeamLimitingDeviceAngle;
  BeamLimitingDeviceRotationDirection = other206.BeamLimitingDeviceRotationDirection;
  PatientSupportAngle = other206.PatientSupportAngle;
  PatientSupportRotationDirection = other206.PatientSupportRotationDirection;
  TableTopEccentricAngle = other206.TableTopEccentricAngle;
  TableTopEccentricRotationDirection = other206.TableTopEccentricRotationDirection;
  TableTopVerticalPosition = other206.TableTopVerticalPosition;
  TableTopLongitudinalPosition = other206.TableTopLongitudinalPosition;
  TableTopLateralPosition = other206.TableTopLateralPosition;
  TableTopPitchAngle = other206.TableTopPitchAngle;
  TableTopPitchRotationDirection = other206.TableTopPitchRotationDirection;
  TableTopRollAngle = other206.TableTopRollAngle;
  TableTopRollRotationDirection = other206.TableTopRollRotationDirection;
  IsocentrePosition = other206.IsocentrePosition;
  JawPositionsX = other206.JawPositionsX;
  JawPositionsY = other206.JawPositionsY;
  MLCPositionsX = other206.MLCPositionsX;
  metadata = other206.metadata;
}
Static_Machine_State& Static_Machine_State::operator=(const Static_Machine_State& other207) {
  CumulativeMetersetWeight = other207.CumulativeMetersetWeight;
  ControlPointIndex = other207.ControlPointIndex;
  GantryAngle = other207.GantryAngle;
  GantryRotationDirection = other207.GantryRotationDirection;
  BeamLimitingDeviceAngle = other207.BeamLimitingDeviceAngle;
  BeamLimitingDeviceRotationDirection = other207.BeamLimitingDeviceRotationDirection;
  PatientSupportAngle = other207.PatientSupportAngle;
  PatientSupportRotationDirection = other207.PatientSupportRotationDirection;
  TableTopEccentricAngle = other207.TableTopEccentricAngle;
  TableTopEccentricRotationDirection = other207.TableTopEccentricRotationDirection;
  TableTopVerticalPosition = other207.TableTopVerticalPosition;
  TableTopLongitudinalPosition = other207.TableTopLongitudinalPosition;
  TableTopLateralPosition = other207.TableTopLateralPosition;
  TableTopPitchAngle = other207.TableTopPitchAngle;
  TableTopPitchRotationDirection = other207.TableTopPitchRotationDirection;
  TableTopRollAngle = other207.TableTopRollAngle;
  TableTopRollRotationDirection = other207.TableTopRollRotationDirection;
  IsocentrePosition = other207.IsocentrePosition;
  JawPositionsX = other207.JawPositionsX;
  JawPositionsY = other207.JawPositionsY;
  MLCPositionsX = other207.MLCPositionsX;
  metadata = other207.metadata;
  return *this;
}
void Static_Machine_State::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Static_Machine_State(";
  out << "CumulativeMetersetWeight=" << to_string(CumulativeMetersetWeight);
  out << ", " << "ControlPointIndex=" << to_string(ControlPointIndex);
  out << ", " << "GantryAngle=" << to_string(GantryAngle);
  out << ", " << "GantryRotationDirection=" << to_string(GantryRotationDirection);
  out << ", " << "BeamLimitingDeviceAngle=" << to_string(BeamLimitingDeviceAngle);
  out << ", " << "BeamLimitingDeviceRotationDirection=" << to_string(BeamLimitingDeviceRotationDirection);
  out << ", " << "PatientSupportAngle=" << to_string(PatientSupportAngle);
  out << ", " << "PatientSupportRotationDirection=" << to_string(PatientSupportRotationDirection);
  out << ", " << "TableTopEccentricAngle=" << to_string(TableTopEccentricAngle);
  out << ", " << "TableTopEccentricRotationDirection=" << to_string(TableTopEccentricRotationDirection);
  out << ", " << "TableTopVerticalPosition=" << to_string(TableTopVerticalPosition);
  out << ", " << "TableTopLongitudinalPosition=" << to_string(TableTopLongitudinalPosition);
  out << ", " << "TableTopLateralPosition=" << to_string(TableTopLateralPosition);
  out << ", " << "TableTopPitchAngle=" << to_string(TableTopPitchAngle);
  out << ", " << "TableTopPitchRotationDirection=" << to_string(TableTopPitchRotationDirection);
  out << ", " << "TableTopRollAngle=" << to_string(TableTopRollAngle);
  out << ", " << "TableTopRollRotationDirection=" << to_string(TableTopRollRotationDirection);
  out << ", " << "IsocentrePosition=" << to_string(IsocentrePosition);
  out << ", " << "JawPositionsX=" << to_string(JawPositionsX);
  out << ", " << "JawPositionsY=" << to_string(JawPositionsY);
  out << ", " << "MLCPositionsX=" << to_string(MLCPositionsX);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


Dynamic_Machine_State::~Dynamic_Machine_State() noexcept {
}


void Dynamic_Machine_State::__set_BeamNumber(const int64_t val) {
  this->BeamNumber = val;
}

void Dynamic_Machine_State::__set_FinalCumulativeMetersetWeight(const double val) {
  this->FinalCumulativeMetersetWeight = val;
}

void Dynamic_Machine_State::__set_static_states(const std::vector<Static_Machine_State> & val) {
  this->static_states = val;
}

void Dynamic_Machine_State::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const Dynamic_Machine_State& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Dynamic_Machine_State::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_BeamNumber = false;
  bool isset_FinalCumulativeMetersetWeight = false;
  bool isset_static_states = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->BeamNumber);
          isset_BeamNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->FinalCumulativeMetersetWeight);
          isset_FinalCumulativeMetersetWeight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->static_states.clear();
            uint32_t _size208;
            ::apache::thrift::protocol::TType _etype211;
            xfer += iprot->readListBegin(_etype211, _size208);
            this->static_states.resize(_size208);
            uint32_t _i212;
            for (_i212 = 0; _i212 < _size208; ++_i212)
            {
              xfer += this->static_states[_i212].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_static_states = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size213;
            ::apache::thrift::protocol::TType _ktype214;
            ::apache::thrift::protocol::TType _vtype215;
            xfer += iprot->readMapBegin(_ktype214, _vtype215, _size213);
            uint32_t _i217;
            for (_i217 = 0; _i217 < _size213; ++_i217)
            {
              std::string _key218;
              xfer += iprot->readString(_key218);
              std::string& _val219 = this->metadata[_key218];
              xfer += iprot->readString(_val219);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_BeamNumber)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_FinalCumulativeMetersetWeight)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_static_states)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Dynamic_Machine_State::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Dynamic_Machine_State");

  xfer += oprot->writeFieldBegin("BeamNumber", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->BeamNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("FinalCumulativeMetersetWeight", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->FinalCumulativeMetersetWeight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("static_states", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->static_states.size()));
    std::vector<Static_Machine_State> ::const_iterator _iter220;
    for (_iter220 = this->static_states.begin(); _iter220 != this->static_states.end(); ++_iter220)
    {
      xfer += (*_iter220).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter221;
    for (_iter221 = this->metadata.begin(); _iter221 != this->metadata.end(); ++_iter221)
    {
      xfer += oprot->writeString(_iter221->first);
      xfer += oprot->writeString(_iter221->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Dynamic_Machine_State &a, Dynamic_Machine_State &b) {
  using ::std::swap;
  swap(a.BeamNumber, b.BeamNumber);
  swap(a.FinalCumulativeMetersetWeight, b.FinalCumulativeMetersetWeight);
  swap(a.static_states, b.static_states);
  swap(a.metadata, b.metadata);
}

Dynamic_Machine_State::Dynamic_Machine_State(const Dynamic_Machine_State& other222) {
  BeamNumber = other222.BeamNumber;
  FinalCumulativeMetersetWeight = other222.FinalCumulativeMetersetWeight;
  static_states = other222.static_states;
  metadata = other222.metadata;
}
Dynamic_Machine_State& Dynamic_Machine_State::operator=(const Dynamic_Machine_State& other223) {
  BeamNumber = other223.BeamNumber;
  FinalCumulativeMetersetWeight = other223.FinalCumulativeMetersetWeight;
  static_states = other223.static_states;
  metadata = other223.metadata;
  return *this;
}
void Dynamic_Machine_State::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Dynamic_Machine_State(";
  out << "BeamNumber=" << to_string(BeamNumber);
  out << ", " << "FinalCumulativeMetersetWeight=" << to_string(FinalCumulativeMetersetWeight);
  out << ", " << "static_states=" << to_string(static_states);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


RTPlan::~RTPlan() noexcept {
}


void RTPlan::__set_dynamic_states(const std::vector<Dynamic_Machine_State> & val) {
  this->dynamic_states = val;
}

void RTPlan::__set_metadata(const metadata_t& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const RTPlan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RTPlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dynamic_states = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dynamic_states.clear();
            uint32_t _size224;
            ::apache::thrift::protocol::TType _etype227;
            xfer += iprot->readListBegin(_etype227, _size224);
            this->dynamic_states.resize(_size224);
            uint32_t _i228;
            for (_i228 = 0; _i228 < _size224; ++_i228)
            {
              xfer += this->dynamic_states[_i228].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_dynamic_states = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size229;
            ::apache::thrift::protocol::TType _ktype230;
            ::apache::thrift::protocol::TType _vtype231;
            xfer += iprot->readMapBegin(_ktype230, _vtype231, _size229);
            uint32_t _i233;
            for (_i233 = 0; _i233 < _size229; ++_i233)
            {
              std::string _key234;
              xfer += iprot->readString(_key234);
              std::string& _val235 = this->metadata[_key234];
              xfer += iprot->readString(_val235);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dynamic_states)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RTPlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RTPlan");

  xfer += oprot->writeFieldBegin("dynamic_states", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dynamic_states.size()));
    std::vector<Dynamic_Machine_State> ::const_iterator _iter236;
    for (_iter236 = this->dynamic_states.begin(); _iter236 != this->dynamic_states.end(); ++_iter236)
    {
      xfer += (*_iter236).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter237;
    for (_iter237 = this->metadata.begin(); _iter237 != this->metadata.end(); ++_iter237)
    {
      xfer += oprot->writeString(_iter237->first);
      xfer += oprot->writeString(_iter237->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RTPlan &a, RTPlan &b) {
  using ::std::swap;
  swap(a.dynamic_states, b.dynamic_states);
  swap(a.metadata, b.metadata);
}

RTPlan::RTPlan(const RTPlan& other238) {
  dynamic_states = other238.dynamic_states;
  metadata = other238.metadata;
}
RTPlan& RTPlan::operator=(const RTPlan& other239) {
  dynamic_states = other239.dynamic_states;
  metadata = other239.metadata;
  return *this;
}
void RTPlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RTPlan(";
  out << "dynamic_states=" << to_string(dynamic_states);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}


Line_Sample::~Line_Sample() noexcept {
}


void Line_Sample::__set_line(const samples_1D_double& val) {
  this->line = val;
}
std::ostream& operator<<(std::ostream& out, const Line_Sample& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Line_Sample::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_line = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->line.read(iprot);
          isset_line = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_line)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Line_Sample::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Line_Sample");

  xfer += oprot->writeFieldBegin("line", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->line.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Line_Sample &a, Line_Sample &b) {
  using ::std::swap;
  swap(a.line, b.line);
}

Line_Sample::Line_Sample(const Line_Sample& other240) {
  line = other240.line;
}
Line_Sample& Line_Sample::operator=(const Line_Sample& other241) {
  line = other241.line;
  return *this;
}
void Line_Sample::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Line_Sample(";
  out << "line=" << to_string(line);
  out << ")";
}


Transform3::~Transform3() noexcept {
}

std::ostream& operator<<(std::ostream& out, const Transform3& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Transform3::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Transform3::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Transform3");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Transform3 &a, Transform3 &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

Transform3::Transform3(const Transform3& other242) noexcept {
  (void) other242;
}
Transform3& Transform3::operator=(const Transform3& other243) noexcept {
  (void) other243;
  return *this;
}
void Transform3::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Transform3(";
  out << ")";
}


Sparse_Table::~Sparse_Table() noexcept {
}


void Sparse_Table::__set_table(const table2& val) {
  this->table = val;
}
std::ostream& operator<<(std::ostream& out, const Sparse_Table& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Sparse_Table::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Sparse_Table::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Sparse_Table");

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Sparse_Table &a, Sparse_Table &b) {
  using ::std::swap;
  swap(a.table, b.table);
}

Sparse_Table::Sparse_Table(const Sparse_Table& other244) {
  table = other244.table;
}
Sparse_Table& Sparse_Table::operator=(const Sparse_Table& other245) {
  table = other245.table;
  return *this;
}
void Sparse_Table::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Sparse_Table(";
  out << "table=" << to_string(table);
  out << ")";
}


Drover::~Drover() noexcept {
}


void Drover::__set_contour_data(const std::vector<Contour_Data> & val) {
  this->contour_data = val;
__isset.contour_data = true;
}

void Drover::__set_image_data(const std::vector<Image_Array> & val) {
  this->image_data = val;
__isset.image_data = true;
}

void Drover::__set_point_data(const std::vector<Point_Cloud> & val) {
  this->point_data = val;
__isset.point_data = true;
}

void Drover::__set_smesh_data(const std::vector<Surface_Mesh> & val) {
  this->smesh_data = val;
__isset.smesh_data = true;
}

void Drover::__set_rtplan_data(const std::vector<RTPlan> & val) {
  this->rtplan_data = val;
__isset.rtplan_data = true;
}

void Drover::__set_lsamp_data(const std::vector<Line_Sample> & val) {
  this->lsamp_data = val;
__isset.lsamp_data = true;
}

void Drover::__set_trans_data(const std::vector<Transform3> & val) {
  this->trans_data = val;
__isset.trans_data = true;
}

void Drover::__set_table_data(const std::vector<Sparse_Table> & val) {
  this->table_data = val;
__isset.table_data = true;
}
std::ostream& operator<<(std::ostream& out, const Drover& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Drover::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->contour_data.clear();
            uint32_t _size246;
            ::apache::thrift::protocol::TType _etype249;
            xfer += iprot->readListBegin(_etype249, _size246);
            this->contour_data.resize(_size246);
            uint32_t _i250;
            for (_i250 = 0; _i250 < _size246; ++_i250)
            {
              xfer += this->contour_data[_i250].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.contour_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->image_data.clear();
            uint32_t _size251;
            ::apache::thrift::protocol::TType _etype254;
            xfer += iprot->readListBegin(_etype254, _size251);
            this->image_data.resize(_size251);
            uint32_t _i255;
            for (_i255 = 0; _i255 < _size251; ++_i255)
            {
              xfer += this->image_data[_i255].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.image_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->point_data.clear();
            uint32_t _size256;
            ::apache::thrift::protocol::TType _etype259;
            xfer += iprot->readListBegin(_etype259, _size256);
            this->point_data.resize(_size256);
            uint32_t _i260;
            for (_i260 = 0; _i260 < _size256; ++_i260)
            {
              xfer += this->point_data[_i260].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.point_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->smesh_data.clear();
            uint32_t _size261;
            ::apache::thrift::protocol::TType _etype264;
            xfer += iprot->readListBegin(_etype264, _size261);
            this->smesh_data.resize(_size261);
            uint32_t _i265;
            for (_i265 = 0; _i265 < _size261; ++_i265)
            {
              xfer += this->smesh_data[_i265].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.smesh_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rtplan_data.clear();
            uint32_t _size266;
            ::apache::thrift::protocol::TType _etype269;
            xfer += iprot->readListBegin(_etype269, _size266);
            this->rtplan_data.resize(_size266);
            uint32_t _i270;
            for (_i270 = 0; _i270 < _size266; ++_i270)
            {
              xfer += this->rtplan_data[_i270].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rtplan_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lsamp_data.clear();
            uint32_t _size271;
            ::apache::thrift::protocol::TType _etype274;
            xfer += iprot->readListBegin(_etype274, _size271);
            this->lsamp_data.resize(_size271);
            uint32_t _i275;
            for (_i275 = 0; _i275 < _size271; ++_i275)
            {
              xfer += this->lsamp_data[_i275].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lsamp_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->trans_data.clear();
            uint32_t _size276;
            ::apache::thrift::protocol::TType _etype279;
            xfer += iprot->readListBegin(_etype279, _size276);
            this->trans_data.resize(_size276);
            uint32_t _i280;
            for (_i280 = 0; _i280 < _size276; ++_i280)
            {
              xfer += this->trans_data[_i280].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.trans_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_data.clear();
            uint32_t _size281;
            ::apache::thrift::protocol::TType _etype284;
            xfer += iprot->readListBegin(_etype284, _size281);
            this->table_data.resize(_size281);
            uint32_t _i285;
            for (_i285 = 0; _i285 < _size281; ++_i285)
            {
              xfer += this->table_data[_i285].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Drover::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Drover");

  if (this->__isset.contour_data) {
    xfer += oprot->writeFieldBegin("contour_data", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->contour_data.size()));
      std::vector<Contour_Data> ::const_iterator _iter286;
      for (_iter286 = this->contour_data.begin(); _iter286 != this->contour_data.end(); ++_iter286)
      {
        xfer += (*_iter286).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.image_data) {
    xfer += oprot->writeFieldBegin("image_data", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->image_data.size()));
      std::vector<Image_Array> ::const_iterator _iter287;
      for (_iter287 = this->image_data.begin(); _iter287 != this->image_data.end(); ++_iter287)
      {
        xfer += (*_iter287).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.point_data) {
    xfer += oprot->writeFieldBegin("point_data", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->point_data.size()));
      std::vector<Point_Cloud> ::const_iterator _iter288;
      for (_iter288 = this->point_data.begin(); _iter288 != this->point_data.end(); ++_iter288)
      {
        xfer += (*_iter288).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.smesh_data) {
    xfer += oprot->writeFieldBegin("smesh_data", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->smesh_data.size()));
      std::vector<Surface_Mesh> ::const_iterator _iter289;
      for (_iter289 = this->smesh_data.begin(); _iter289 != this->smesh_data.end(); ++_iter289)
      {
        xfer += (*_iter289).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rtplan_data) {
    xfer += oprot->writeFieldBegin("rtplan_data", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rtplan_data.size()));
      std::vector<RTPlan> ::const_iterator _iter290;
      for (_iter290 = this->rtplan_data.begin(); _iter290 != this->rtplan_data.end(); ++_iter290)
      {
        xfer += (*_iter290).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lsamp_data) {
    xfer += oprot->writeFieldBegin("lsamp_data", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lsamp_data.size()));
      std::vector<Line_Sample> ::const_iterator _iter291;
      for (_iter291 = this->lsamp_data.begin(); _iter291 != this->lsamp_data.end(); ++_iter291)
      {
        xfer += (*_iter291).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.trans_data) {
    xfer += oprot->writeFieldBegin("trans_data", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->trans_data.size()));
      std::vector<Transform3> ::const_iterator _iter292;
      for (_iter292 = this->trans_data.begin(); _iter292 != this->trans_data.end(); ++_iter292)
      {
        xfer += (*_iter292).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_data) {
    xfer += oprot->writeFieldBegin("table_data", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->table_data.size()));
      std::vector<Sparse_Table> ::const_iterator _iter293;
      for (_iter293 = this->table_data.begin(); _iter293 != this->table_data.end(); ++_iter293)
      {
        xfer += (*_iter293).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Drover &a, Drover &b) {
  using ::std::swap;
  swap(a.contour_data, b.contour_data);
  swap(a.image_data, b.image_data);
  swap(a.point_data, b.point_data);
  swap(a.smesh_data, b.smesh_data);
  swap(a.rtplan_data, b.rtplan_data);
  swap(a.lsamp_data, b.lsamp_data);
  swap(a.trans_data, b.trans_data);
  swap(a.table_data, b.table_data);
  swap(a.__isset, b.__isset);
}

Drover::Drover(const Drover& other294) {
  contour_data = other294.contour_data;
  image_data = other294.image_data;
  point_data = other294.point_data;
  smesh_data = other294.smesh_data;
  rtplan_data = other294.rtplan_data;
  lsamp_data = other294.lsamp_data;
  trans_data = other294.trans_data;
  table_data = other294.table_data;
  __isset = other294.__isset;
}
Drover& Drover::operator=(const Drover& other295) {
  contour_data = other295.contour_data;
  image_data = other295.image_data;
  point_data = other295.point_data;
  smesh_data = other295.smesh_data;
  rtplan_data = other295.rtplan_data;
  lsamp_data = other295.lsamp_data;
  trans_data = other295.trans_data;
  table_data = other295.table_data;
  __isset = other295.__isset;
  return *this;
}
void Drover::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Drover(";
  out << "contour_data="; (__isset.contour_data ? (out << to_string(contour_data)) : (out << "<null>"));
  out << ", " << "image_data="; (__isset.image_data ? (out << to_string(image_data)) : (out << "<null>"));
  out << ", " << "point_data="; (__isset.point_data ? (out << to_string(point_data)) : (out << "<null>"));
  out << ", " << "smesh_data="; (__isset.smesh_data ? (out << to_string(smesh_data)) : (out << "<null>"));
  out << ", " << "rtplan_data="; (__isset.rtplan_data ? (out << to_string(rtplan_data)) : (out << "<null>"));
  out << ", " << "lsamp_data="; (__isset.lsamp_data ? (out << to_string(lsamp_data)) : (out << "<null>"));
  out << ", " << "trans_data="; (__isset.trans_data ? (out << to_string(trans_data)) : (out << "<null>"));
  out << ", " << "table_data="; (__isset.table_data ? (out << to_string(table_data)) : (out << "<null>"));
  out << ")";
}


OperationsQuery::~OperationsQuery() noexcept {
}

std::ostream& operator<<(std::ostream& out, const OperationsQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OperationsQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OperationsQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OperationsQuery");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OperationsQuery &a, OperationsQuery &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

OperationsQuery::OperationsQuery(const OperationsQuery& other296) noexcept {
  (void) other296;
}
OperationsQuery& OperationsQuery::operator=(const OperationsQuery& other297) noexcept {
  (void) other297;
  return *this;
}
void OperationsQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OperationsQuery(";
  out << ")";
}


KnownOperation::~KnownOperation() noexcept {
}


void KnownOperation::__set_name(const std::string& val) {
  this->name = val;
}
std::ostream& operator<<(std::ostream& out, const KnownOperation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KnownOperation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KnownOperation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KnownOperation");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KnownOperation &a, KnownOperation &b) {
  using ::std::swap;
  swap(a.name, b.name);
}

KnownOperation::KnownOperation(const KnownOperation& other298) {
  name = other298.name;
}
KnownOperation& KnownOperation::operator=(const KnownOperation& other299) {
  name = other299.name;
  return *this;
}
void KnownOperation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KnownOperation(";
  out << "name=" << to_string(name);
  out << ")";
}


LoadFilesQuery::~LoadFilesQuery() noexcept {
}


void LoadFilesQuery::__set_server_filename(const std::string& val) {
  this->server_filename = val;
}
std::ostream& operator<<(std::ostream& out, const LoadFilesQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LoadFilesQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_server_filename = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_filename);
          isset_server_filename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_server_filename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LoadFilesQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LoadFilesQuery");

  xfer += oprot->writeFieldBegin("server_filename", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->server_filename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LoadFilesQuery &a, LoadFilesQuery &b) {
  using ::std::swap;
  swap(a.server_filename, b.server_filename);
}

LoadFilesQuery::LoadFilesQuery(const LoadFilesQuery& other300) {
  server_filename = other300.server_filename;
}
LoadFilesQuery& LoadFilesQuery::operator=(const LoadFilesQuery& other301) {
  server_filename = other301.server_filename;
  return *this;
}
void LoadFilesQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LoadFilesQuery(";
  out << "server_filename=" << to_string(server_filename);
  out << ")";
}


LoadFilesResponse::~LoadFilesResponse() noexcept {
}


void LoadFilesResponse::__set_success(const bool val) {
  this->success = val;
}

void LoadFilesResponse::__set_drover(const Drover& val) {
  this->drover = val;
__isset.drover = true;
}
std::ostream& operator<<(std::ostream& out, const LoadFilesResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LoadFilesResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_success = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          isset_success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drover.read(iprot);
          this->__isset.drover = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_success)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LoadFilesResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LoadFilesResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.drover) {
    xfer += oprot->writeFieldBegin("drover", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->drover.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LoadFilesResponse &a, LoadFilesResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.drover, b.drover);
  swap(a.__isset, b.__isset);
}

LoadFilesResponse::LoadFilesResponse(const LoadFilesResponse& other302) {
  success = other302.success;
  drover = other302.drover;
  __isset = other302.__isset;
}
LoadFilesResponse& LoadFilesResponse::operator=(const LoadFilesResponse& other303) {
  success = other303.success;
  drover = other303.drover;
  __isset = other303.__isset;
  return *this;
}
void LoadFilesResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LoadFilesResponse(";
  out << "success=" << to_string(success);
  out << ", " << "drover="; (__isset.drover ? (out << to_string(drover)) : (out << "<null>"));
  out << ")";
}


ExecuteScriptQuery::~ExecuteScriptQuery() noexcept {
}


void ExecuteScriptQuery::__set_drover(const Drover& val) {
  this->drover = val;
}

void ExecuteScriptQuery::__set_invocation_metadata(const metadata_t& val) {
  this->invocation_metadata = val;
}

void ExecuteScriptQuery::__set_filename_lex(const std::string& val) {
  this->filename_lex = val;
}
std::ostream& operator<<(std::ostream& out, const ExecuteScriptQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExecuteScriptQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_drover = false;
  bool isset_invocation_metadata = false;
  bool isset_filename_lex = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drover.read(iprot);
          isset_drover = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->invocation_metadata.clear();
            uint32_t _size304;
            ::apache::thrift::protocol::TType _ktype305;
            ::apache::thrift::protocol::TType _vtype306;
            xfer += iprot->readMapBegin(_ktype305, _vtype306, _size304);
            uint32_t _i308;
            for (_i308 = 0; _i308 < _size304; ++_i308)
            {
              std::string _key309;
              xfer += iprot->readString(_key309);
              std::string& _val310 = this->invocation_metadata[_key309];
              xfer += iprot->readString(_val310);
            }
            xfer += iprot->readMapEnd();
          }
          isset_invocation_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filename_lex);
          isset_filename_lex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_drover)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_invocation_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_filename_lex)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ExecuteScriptQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExecuteScriptQuery");

  xfer += oprot->writeFieldBegin("drover", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->drover.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("invocation_metadata", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->invocation_metadata.size()));
    std::map<std::string, std::string> ::const_iterator _iter311;
    for (_iter311 = this->invocation_metadata.begin(); _iter311 != this->invocation_metadata.end(); ++_iter311)
    {
      xfer += oprot->writeString(_iter311->first);
      xfer += oprot->writeString(_iter311->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filename_lex", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->filename_lex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExecuteScriptQuery &a, ExecuteScriptQuery &b) {
  using ::std::swap;
  swap(a.drover, b.drover);
  swap(a.invocation_metadata, b.invocation_metadata);
  swap(a.filename_lex, b.filename_lex);
}

ExecuteScriptQuery::ExecuteScriptQuery(const ExecuteScriptQuery& other312) {
  drover = other312.drover;
  invocation_metadata = other312.invocation_metadata;
  filename_lex = other312.filename_lex;
}
ExecuteScriptQuery& ExecuteScriptQuery::operator=(const ExecuteScriptQuery& other313) {
  drover = other313.drover;
  invocation_metadata = other313.invocation_metadata;
  filename_lex = other313.filename_lex;
  return *this;
}
void ExecuteScriptQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExecuteScriptQuery(";
  out << "drover=" << to_string(drover);
  out << ", " << "invocation_metadata=" << to_string(invocation_metadata);
  out << ", " << "filename_lex=" << to_string(filename_lex);
  out << ")";
}


ExecuteScriptResponse::~ExecuteScriptResponse() noexcept {
}


void ExecuteScriptResponse::__set_success(const bool val) {
  this->success = val;
}

void ExecuteScriptResponse::__set_drover(const Drover& val) {
  this->drover = val;
__isset.drover = true;
}

void ExecuteScriptResponse::__set_invocation_metadata(const metadata_t& val) {
  this->invocation_metadata = val;
__isset.invocation_metadata = true;
}

void ExecuteScriptResponse::__set_filename_lex(const std::string& val) {
  this->filename_lex = val;
__isset.filename_lex = true;
}
std::ostream& operator<<(std::ostream& out, const ExecuteScriptResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExecuteScriptResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_success = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          isset_success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drover.read(iprot);
          this->__isset.drover = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->invocation_metadata.clear();
            uint32_t _size314;
            ::apache::thrift::protocol::TType _ktype315;
            ::apache::thrift::protocol::TType _vtype316;
            xfer += iprot->readMapBegin(_ktype315, _vtype316, _size314);
            uint32_t _i318;
            for (_i318 = 0; _i318 < _size314; ++_i318)
            {
              std::string _key319;
              xfer += iprot->readString(_key319);
              std::string& _val320 = this->invocation_metadata[_key319];
              xfer += iprot->readString(_val320);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.invocation_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filename_lex);
          this->__isset.filename_lex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_success)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ExecuteScriptResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExecuteScriptResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.drover) {
    xfer += oprot->writeFieldBegin("drover", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->drover.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.invocation_metadata) {
    xfer += oprot->writeFieldBegin("invocation_metadata", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->invocation_metadata.size()));
      std::map<std::string, std::string> ::const_iterator _iter321;
      for (_iter321 = this->invocation_metadata.begin(); _iter321 != this->invocation_metadata.end(); ++_iter321)
      {
        xfer += oprot->writeString(_iter321->first);
        xfer += oprot->writeString(_iter321->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filename_lex) {
    xfer += oprot->writeFieldBegin("filename_lex", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->filename_lex);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExecuteScriptResponse &a, ExecuteScriptResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.drover, b.drover);
  swap(a.invocation_metadata, b.invocation_metadata);
  swap(a.filename_lex, b.filename_lex);
  swap(a.__isset, b.__isset);
}

ExecuteScriptResponse::ExecuteScriptResponse(const ExecuteScriptResponse& other322) {
  success = other322.success;
  drover = other322.drover;
  invocation_metadata = other322.invocation_metadata;
  filename_lex = other322.filename_lex;
  __isset = other322.__isset;
}
ExecuteScriptResponse& ExecuteScriptResponse::operator=(const ExecuteScriptResponse& other323) {
  success = other323.success;
  drover = other323.drover;
  invocation_metadata = other323.invocation_metadata;
  filename_lex = other323.filename_lex;
  __isset = other323.__isset;
  return *this;
}
void ExecuteScriptResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExecuteScriptResponse(";
  out << "success=" << to_string(success);
  out << ", " << "drover="; (__isset.drover ? (out << to_string(drover)) : (out << "<null>"));
  out << ", " << "invocation_metadata="; (__isset.invocation_metadata ? (out << to_string(invocation_metadata)) : (out << "<null>"));
  out << ", " << "filename_lex="; (__isset.filename_lex ? (out << to_string(filename_lex)) : (out << "<null>"));
  out << ")";
}

}} // namespace
