/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef DCMA_TYPES_H
#define DCMA_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace dcma { namespace rpc {

typedef std::map<std::string, std::string>  metadata_t;

class vec3_double;

class contour_of_points_double;

class contour_collection_double;

class point_set_double;

class sample4_double;

class samples_1D_double;

class fv_surface_mesh_double_int64;

class planar_image_double_double;

class planar_image_collection_double_double;

class cell_string;

class table2;

class Contour_Data;

class Image_Array;

class Point_Cloud;

class Surface_Mesh;

class Static_Machine_State;

class Dynamic_Machine_State;

class RTPlan;

class Line_Sample;

class Transform3;

class Sparse_Table;

class Drover;

class OperationsQuery;

class KnownOperation;

class LoadFilesQuery;

class LoadFilesResponse;

class ExecuteScriptQuery;

class ExecuteScriptResponse;


class vec3_double : public virtual ::apache::thrift::TBase {
 public:

  vec3_double(const vec3_double&) noexcept;
  vec3_double& operator=(const vec3_double&) noexcept;
  vec3_double() noexcept
              : x(0),
                y(0),
                z(0) {
  }

  virtual ~vec3_double() noexcept;
  double x;
  double y;
  double z;

  void __set_x(const double val);

  void __set_y(const double val);

  void __set_z(const double val);

  bool operator == (const vec3_double & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    if (!(z == rhs.z))
      return false;
    return true;
  }
  bool operator != (const vec3_double &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const vec3_double & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(vec3_double &a, vec3_double &b);

std::ostream& operator<<(std::ostream& out, const vec3_double& obj);


class contour_of_points_double : public virtual ::apache::thrift::TBase {
 public:

  contour_of_points_double(const contour_of_points_double&);
  contour_of_points_double& operator=(const contour_of_points_double&);
  contour_of_points_double() noexcept
                           : closed(0) {
  }

  virtual ~contour_of_points_double() noexcept;
  std::vector<vec3_double>  points;
  bool closed;
  metadata_t metadata;

  void __set_points(const std::vector<vec3_double> & val);

  void __set_closed(const bool val);

  void __set_metadata(const metadata_t& val);

  bool operator == (const contour_of_points_double & rhs) const
  {
    if (!(points == rhs.points))
      return false;
    if (!(closed == rhs.closed))
      return false;
    if (!(metadata == rhs.metadata))
      return false;
    return true;
  }
  bool operator != (const contour_of_points_double &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const contour_of_points_double & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(contour_of_points_double &a, contour_of_points_double &b);

std::ostream& operator<<(std::ostream& out, const contour_of_points_double& obj);


class contour_collection_double : public virtual ::apache::thrift::TBase {
 public:

  contour_collection_double(const contour_collection_double&);
  contour_collection_double& operator=(const contour_collection_double&);
  contour_collection_double() noexcept {
  }

  virtual ~contour_collection_double() noexcept;
  std::vector<contour_of_points_double>  contours;

  void __set_contours(const std::vector<contour_of_points_double> & val);

  bool operator == (const contour_collection_double & rhs) const
  {
    if (!(contours == rhs.contours))
      return false;
    return true;
  }
  bool operator != (const contour_collection_double &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const contour_collection_double & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(contour_collection_double &a, contour_collection_double &b);

std::ostream& operator<<(std::ostream& out, const contour_collection_double& obj);


class point_set_double : public virtual ::apache::thrift::TBase {
 public:

  point_set_double(const point_set_double&);
  point_set_double& operator=(const point_set_double&);
  point_set_double() noexcept {
  }

  virtual ~point_set_double() noexcept;
  std::vector<vec3_double>  points;
  std::vector<vec3_double>  normals;
  std::vector<int64_t>  colours;
  metadata_t metadata;

  void __set_points(const std::vector<vec3_double> & val);

  void __set_normals(const std::vector<vec3_double> & val);

  void __set_colours(const std::vector<int64_t> & val);

  void __set_metadata(const metadata_t& val);

  bool operator == (const point_set_double & rhs) const
  {
    if (!(points == rhs.points))
      return false;
    if (!(normals == rhs.normals))
      return false;
    if (!(colours == rhs.colours))
      return false;
    if (!(metadata == rhs.metadata))
      return false;
    return true;
  }
  bool operator != (const point_set_double &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const point_set_double & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(point_set_double &a, point_set_double &b);

std::ostream& operator<<(std::ostream& out, const point_set_double& obj);


class sample4_double : public virtual ::apache::thrift::TBase {
 public:

  sample4_double(const sample4_double&) noexcept;
  sample4_double& operator=(const sample4_double&) noexcept;
  sample4_double() noexcept
                 : x(0),
                   sigma_x(0),
                   f(0),
                   sigma_f(0) {
  }

  virtual ~sample4_double() noexcept;
  double x;
  double sigma_x;
  double f;
  double sigma_f;

  void __set_x(const double val);

  void __set_sigma_x(const double val);

  void __set_f(const double val);

  void __set_sigma_f(const double val);

  bool operator == (const sample4_double & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(sigma_x == rhs.sigma_x))
      return false;
    if (!(f == rhs.f))
      return false;
    if (!(sigma_f == rhs.sigma_f))
      return false;
    return true;
  }
  bool operator != (const sample4_double &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const sample4_double & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(sample4_double &a, sample4_double &b);

std::ostream& operator<<(std::ostream& out, const sample4_double& obj);


class samples_1D_double : public virtual ::apache::thrift::TBase {
 public:

  samples_1D_double(const samples_1D_double&);
  samples_1D_double& operator=(const samples_1D_double&);
  samples_1D_double() noexcept
                    : uncertainties_known_to_be_independent_and_random(0) {
  }

  virtual ~samples_1D_double() noexcept;
  std::vector<sample4_double>  samples;
  bool uncertainties_known_to_be_independent_and_random;
  metadata_t metadata;

  void __set_samples(const std::vector<sample4_double> & val);

  void __set_uncertainties_known_to_be_independent_and_random(const bool val);

  void __set_metadata(const metadata_t& val);

  bool operator == (const samples_1D_double & rhs) const
  {
    if (!(samples == rhs.samples))
      return false;
    if (!(uncertainties_known_to_be_independent_and_random == rhs.uncertainties_known_to_be_independent_and_random))
      return false;
    if (!(metadata == rhs.metadata))
      return false;
    return true;
  }
  bool operator != (const samples_1D_double &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const samples_1D_double & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(samples_1D_double &a, samples_1D_double &b);

std::ostream& operator<<(std::ostream& out, const samples_1D_double& obj);


class fv_surface_mesh_double_int64 : public virtual ::apache::thrift::TBase {
 public:

  fv_surface_mesh_double_int64(const fv_surface_mesh_double_int64&);
  fv_surface_mesh_double_int64& operator=(const fv_surface_mesh_double_int64&);
  fv_surface_mesh_double_int64() noexcept {
  }

  virtual ~fv_surface_mesh_double_int64() noexcept;
  std::vector<vec3_double>  vertices;
  std::vector<vec3_double>  vertex_normals;
  std::vector<int64_t>  vertex_colours;
  std::vector<std::vector<int64_t> >  faces;
  std::vector<std::vector<int64_t> >  involved_faces;
  metadata_t metadata;

  void __set_vertices(const std::vector<vec3_double> & val);

  void __set_vertex_normals(const std::vector<vec3_double> & val);

  void __set_vertex_colours(const std::vector<int64_t> & val);

  void __set_faces(const std::vector<std::vector<int64_t> > & val);

  void __set_involved_faces(const std::vector<std::vector<int64_t> > & val);

  void __set_metadata(const metadata_t& val);

  bool operator == (const fv_surface_mesh_double_int64 & rhs) const
  {
    if (!(vertices == rhs.vertices))
      return false;
    if (!(vertex_normals == rhs.vertex_normals))
      return false;
    if (!(vertex_colours == rhs.vertex_colours))
      return false;
    if (!(faces == rhs.faces))
      return false;
    if (!(involved_faces == rhs.involved_faces))
      return false;
    if (!(metadata == rhs.metadata))
      return false;
    return true;
  }
  bool operator != (const fv_surface_mesh_double_int64 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const fv_surface_mesh_double_int64 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(fv_surface_mesh_double_int64 &a, fv_surface_mesh_double_int64 &b);

std::ostream& operator<<(std::ostream& out, const fv_surface_mesh_double_int64& obj);


class planar_image_double_double : public virtual ::apache::thrift::TBase {
 public:

  planar_image_double_double(const planar_image_double_double&);
  planar_image_double_double& operator=(const planar_image_double_double&);
  planar_image_double_double() noexcept
                             : rows(0),
                               columns(0),
                               channels(0),
                               pxl_dx(0),
                               pxl_dy(0),
                               pxl_dz(0) {
  }

  virtual ~planar_image_double_double() noexcept;
  std::vector<double>  data;
  int64_t rows;
  int64_t columns;
  int64_t channels;
  double pxl_dx;
  double pxl_dy;
  double pxl_dz;
  vec3_double anchor;
  vec3_double offset;
  vec3_double row_unit;
  vec3_double col_unit;
  metadata_t metadata;

  void __set_data(const std::vector<double> & val);

  void __set_rows(const int64_t val);

  void __set_columns(const int64_t val);

  void __set_channels(const int64_t val);

  void __set_pxl_dx(const double val);

  void __set_pxl_dy(const double val);

  void __set_pxl_dz(const double val);

  void __set_anchor(const vec3_double& val);

  void __set_offset(const vec3_double& val);

  void __set_row_unit(const vec3_double& val);

  void __set_col_unit(const vec3_double& val);

  void __set_metadata(const metadata_t& val);

  bool operator == (const planar_image_double_double & rhs) const
  {
    if (!(data == rhs.data))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(channels == rhs.channels))
      return false;
    if (!(pxl_dx == rhs.pxl_dx))
      return false;
    if (!(pxl_dy == rhs.pxl_dy))
      return false;
    if (!(pxl_dz == rhs.pxl_dz))
      return false;
    if (!(anchor == rhs.anchor))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(row_unit == rhs.row_unit))
      return false;
    if (!(col_unit == rhs.col_unit))
      return false;
    if (!(metadata == rhs.metadata))
      return false;
    return true;
  }
  bool operator != (const planar_image_double_double &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const planar_image_double_double & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(planar_image_double_double &a, planar_image_double_double &b);

std::ostream& operator<<(std::ostream& out, const planar_image_double_double& obj);


class planar_image_collection_double_double : public virtual ::apache::thrift::TBase {
 public:

  planar_image_collection_double_double(const planar_image_collection_double_double&);
  planar_image_collection_double_double& operator=(const planar_image_collection_double_double&);
  planar_image_collection_double_double() noexcept {
  }

  virtual ~planar_image_collection_double_double() noexcept;
  std::vector<planar_image_double_double>  images;

  void __set_images(const std::vector<planar_image_double_double> & val);

  bool operator == (const planar_image_collection_double_double & rhs) const
  {
    if (!(images == rhs.images))
      return false;
    return true;
  }
  bool operator != (const planar_image_collection_double_double &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const planar_image_collection_double_double & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(planar_image_collection_double_double &a, planar_image_collection_double_double &b);

std::ostream& operator<<(std::ostream& out, const planar_image_collection_double_double& obj);


class cell_string : public virtual ::apache::thrift::TBase {
 public:

  cell_string(const cell_string&) noexcept;
  cell_string& operator=(const cell_string&) noexcept;
  cell_string() noexcept {
  }

  virtual ~cell_string() noexcept;

  bool operator == (const cell_string & /* rhs */) const
  {
    return true;
  }
  bool operator != (const cell_string &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const cell_string & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(cell_string &a, cell_string &b);

std::ostream& operator<<(std::ostream& out, const cell_string& obj);


class table2 : public virtual ::apache::thrift::TBase {
 public:

  table2(const table2&) noexcept;
  table2& operator=(const table2&) noexcept;
  table2() noexcept {
  }

  virtual ~table2() noexcept;

  bool operator == (const table2 & /* rhs */) const
  {
    return true;
  }
  bool operator != (const table2 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const table2 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(table2 &a, table2 &b);

std::ostream& operator<<(std::ostream& out, const table2& obj);


class Contour_Data : public virtual ::apache::thrift::TBase {
 public:

  Contour_Data(const Contour_Data&);
  Contour_Data& operator=(const Contour_Data&);
  Contour_Data() noexcept {
  }

  virtual ~Contour_Data() noexcept;
  std::vector<contour_collection_double>  ccs;

  void __set_ccs(const std::vector<contour_collection_double> & val);

  bool operator == (const Contour_Data & rhs) const
  {
    if (!(ccs == rhs.ccs))
      return false;
    return true;
  }
  bool operator != (const Contour_Data &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Contour_Data & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Contour_Data &a, Contour_Data &b);

std::ostream& operator<<(std::ostream& out, const Contour_Data& obj);


class Image_Array : public virtual ::apache::thrift::TBase {
 public:

  Image_Array(const Image_Array&);
  Image_Array& operator=(const Image_Array&);
  Image_Array() noexcept
              : filename() {
  }

  virtual ~Image_Array() noexcept;
  planar_image_collection_double_double imagecoll;
  std::string filename;

  void __set_imagecoll(const planar_image_collection_double_double& val);

  void __set_filename(const std::string& val);

  bool operator == (const Image_Array & rhs) const
  {
    if (!(imagecoll == rhs.imagecoll))
      return false;
    if (!(filename == rhs.filename))
      return false;
    return true;
  }
  bool operator != (const Image_Array &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Image_Array & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Image_Array &a, Image_Array &b);

std::ostream& operator<<(std::ostream& out, const Image_Array& obj);


class Point_Cloud : public virtual ::apache::thrift::TBase {
 public:

  Point_Cloud(const Point_Cloud&);
  Point_Cloud& operator=(const Point_Cloud&);
  Point_Cloud() noexcept {
  }

  virtual ~Point_Cloud() noexcept;
  point_set_double pset;

  void __set_pset(const point_set_double& val);

  bool operator == (const Point_Cloud & rhs) const
  {
    if (!(pset == rhs.pset))
      return false;
    return true;
  }
  bool operator != (const Point_Cloud &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Point_Cloud & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Point_Cloud &a, Point_Cloud &b);

std::ostream& operator<<(std::ostream& out, const Point_Cloud& obj);


class Surface_Mesh : public virtual ::apache::thrift::TBase {
 public:

  Surface_Mesh(const Surface_Mesh&);
  Surface_Mesh& operator=(const Surface_Mesh&);
  Surface_Mesh() noexcept {
  }

  virtual ~Surface_Mesh() noexcept;
  fv_surface_mesh_double_int64 meshes;

  void __set_meshes(const fv_surface_mesh_double_int64& val);

  bool operator == (const Surface_Mesh & rhs) const
  {
    if (!(meshes == rhs.meshes))
      return false;
    return true;
  }
  bool operator != (const Surface_Mesh &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Surface_Mesh & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Surface_Mesh &a, Surface_Mesh &b);

std::ostream& operator<<(std::ostream& out, const Surface_Mesh& obj);


class Static_Machine_State : public virtual ::apache::thrift::TBase {
 public:

  Static_Machine_State(const Static_Machine_State&);
  Static_Machine_State& operator=(const Static_Machine_State&);
  Static_Machine_State() noexcept
                       : CumulativeMetersetWeight(0),
                         ControlPointIndex(0),
                         GantryAngle(0),
                         GantryRotationDirection(0),
                         BeamLimitingDeviceAngle(0),
                         BeamLimitingDeviceRotationDirection(0),
                         PatientSupportAngle(0),
                         PatientSupportRotationDirection(0),
                         TableTopEccentricAngle(0),
                         TableTopEccentricRotationDirection(0),
                         TableTopVerticalPosition(0),
                         TableTopLongitudinalPosition(0),
                         TableTopLateralPosition(0),
                         TableTopPitchAngle(0),
                         TableTopPitchRotationDirection(0),
                         TableTopRollAngle(0),
                         TableTopRollRotationDirection(0) {
  }

  virtual ~Static_Machine_State() noexcept;
  double CumulativeMetersetWeight;
  int64_t ControlPointIndex;
  double GantryAngle;
  double GantryRotationDirection;
  double BeamLimitingDeviceAngle;
  double BeamLimitingDeviceRotationDirection;
  double PatientSupportAngle;
  double PatientSupportRotationDirection;
  double TableTopEccentricAngle;
  double TableTopEccentricRotationDirection;
  double TableTopVerticalPosition;
  double TableTopLongitudinalPosition;
  double TableTopLateralPosition;
  double TableTopPitchAngle;
  double TableTopPitchRotationDirection;
  double TableTopRollAngle;
  double TableTopRollRotationDirection;
  vec3_double IsocentrePosition;
  std::vector<double>  JawPositionsX;
  std::vector<double>  JawPositionsY;
  std::vector<double>  MLCPositionsX;
  metadata_t metadata;

  void __set_CumulativeMetersetWeight(const double val);

  void __set_ControlPointIndex(const int64_t val);

  void __set_GantryAngle(const double val);

  void __set_GantryRotationDirection(const double val);

  void __set_BeamLimitingDeviceAngle(const double val);

  void __set_BeamLimitingDeviceRotationDirection(const double val);

  void __set_PatientSupportAngle(const double val);

  void __set_PatientSupportRotationDirection(const double val);

  void __set_TableTopEccentricAngle(const double val);

  void __set_TableTopEccentricRotationDirection(const double val);

  void __set_TableTopVerticalPosition(const double val);

  void __set_TableTopLongitudinalPosition(const double val);

  void __set_TableTopLateralPosition(const double val);

  void __set_TableTopPitchAngle(const double val);

  void __set_TableTopPitchRotationDirection(const double val);

  void __set_TableTopRollAngle(const double val);

  void __set_TableTopRollRotationDirection(const double val);

  void __set_IsocentrePosition(const vec3_double& val);

  void __set_JawPositionsX(const std::vector<double> & val);

  void __set_JawPositionsY(const std::vector<double> & val);

  void __set_MLCPositionsX(const std::vector<double> & val);

  void __set_metadata(const metadata_t& val);

  bool operator == (const Static_Machine_State & rhs) const
  {
    if (!(CumulativeMetersetWeight == rhs.CumulativeMetersetWeight))
      return false;
    if (!(ControlPointIndex == rhs.ControlPointIndex))
      return false;
    if (!(GantryAngle == rhs.GantryAngle))
      return false;
    if (!(GantryRotationDirection == rhs.GantryRotationDirection))
      return false;
    if (!(BeamLimitingDeviceAngle == rhs.BeamLimitingDeviceAngle))
      return false;
    if (!(BeamLimitingDeviceRotationDirection == rhs.BeamLimitingDeviceRotationDirection))
      return false;
    if (!(PatientSupportAngle == rhs.PatientSupportAngle))
      return false;
    if (!(PatientSupportRotationDirection == rhs.PatientSupportRotationDirection))
      return false;
    if (!(TableTopEccentricAngle == rhs.TableTopEccentricAngle))
      return false;
    if (!(TableTopEccentricRotationDirection == rhs.TableTopEccentricRotationDirection))
      return false;
    if (!(TableTopVerticalPosition == rhs.TableTopVerticalPosition))
      return false;
    if (!(TableTopLongitudinalPosition == rhs.TableTopLongitudinalPosition))
      return false;
    if (!(TableTopLateralPosition == rhs.TableTopLateralPosition))
      return false;
    if (!(TableTopPitchAngle == rhs.TableTopPitchAngle))
      return false;
    if (!(TableTopPitchRotationDirection == rhs.TableTopPitchRotationDirection))
      return false;
    if (!(TableTopRollAngle == rhs.TableTopRollAngle))
      return false;
    if (!(TableTopRollRotationDirection == rhs.TableTopRollRotationDirection))
      return false;
    if (!(IsocentrePosition == rhs.IsocentrePosition))
      return false;
    if (!(JawPositionsX == rhs.JawPositionsX))
      return false;
    if (!(JawPositionsY == rhs.JawPositionsY))
      return false;
    if (!(MLCPositionsX == rhs.MLCPositionsX))
      return false;
    if (!(metadata == rhs.metadata))
      return false;
    return true;
  }
  bool operator != (const Static_Machine_State &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Static_Machine_State & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Static_Machine_State &a, Static_Machine_State &b);

std::ostream& operator<<(std::ostream& out, const Static_Machine_State& obj);


class Dynamic_Machine_State : public virtual ::apache::thrift::TBase {
 public:

  Dynamic_Machine_State(const Dynamic_Machine_State&);
  Dynamic_Machine_State& operator=(const Dynamic_Machine_State&);
  Dynamic_Machine_State() noexcept
                        : BeamNumber(0),
                          FinalCumulativeMetersetWeight(0) {
  }

  virtual ~Dynamic_Machine_State() noexcept;
  int64_t BeamNumber;
  double FinalCumulativeMetersetWeight;
  std::vector<Static_Machine_State>  static_states;
  metadata_t metadata;

  void __set_BeamNumber(const int64_t val);

  void __set_FinalCumulativeMetersetWeight(const double val);

  void __set_static_states(const std::vector<Static_Machine_State> & val);

  void __set_metadata(const metadata_t& val);

  bool operator == (const Dynamic_Machine_State & rhs) const
  {
    if (!(BeamNumber == rhs.BeamNumber))
      return false;
    if (!(FinalCumulativeMetersetWeight == rhs.FinalCumulativeMetersetWeight))
      return false;
    if (!(static_states == rhs.static_states))
      return false;
    if (!(metadata == rhs.metadata))
      return false;
    return true;
  }
  bool operator != (const Dynamic_Machine_State &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Dynamic_Machine_State & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Dynamic_Machine_State &a, Dynamic_Machine_State &b);

std::ostream& operator<<(std::ostream& out, const Dynamic_Machine_State& obj);


class RTPlan : public virtual ::apache::thrift::TBase {
 public:

  RTPlan(const RTPlan&);
  RTPlan& operator=(const RTPlan&);
  RTPlan() noexcept {
  }

  virtual ~RTPlan() noexcept;
  std::vector<Dynamic_Machine_State>  dynamic_states;
  metadata_t metadata;

  void __set_dynamic_states(const std::vector<Dynamic_Machine_State> & val);

  void __set_metadata(const metadata_t& val);

  bool operator == (const RTPlan & rhs) const
  {
    if (!(dynamic_states == rhs.dynamic_states))
      return false;
    if (!(metadata == rhs.metadata))
      return false;
    return true;
  }
  bool operator != (const RTPlan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RTPlan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RTPlan &a, RTPlan &b);

std::ostream& operator<<(std::ostream& out, const RTPlan& obj);


class Line_Sample : public virtual ::apache::thrift::TBase {
 public:

  Line_Sample(const Line_Sample&);
  Line_Sample& operator=(const Line_Sample&);
  Line_Sample() noexcept {
  }

  virtual ~Line_Sample() noexcept;
  samples_1D_double line;

  void __set_line(const samples_1D_double& val);

  bool operator == (const Line_Sample & rhs) const
  {
    if (!(line == rhs.line))
      return false;
    return true;
  }
  bool operator != (const Line_Sample &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Line_Sample & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Line_Sample &a, Line_Sample &b);

std::ostream& operator<<(std::ostream& out, const Line_Sample& obj);


class Transform3 : public virtual ::apache::thrift::TBase {
 public:

  Transform3(const Transform3&) noexcept;
  Transform3& operator=(const Transform3&) noexcept;
  Transform3() noexcept {
  }

  virtual ~Transform3() noexcept;

  bool operator == (const Transform3 & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Transform3 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Transform3 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Transform3 &a, Transform3 &b);

std::ostream& operator<<(std::ostream& out, const Transform3& obj);


class Sparse_Table : public virtual ::apache::thrift::TBase {
 public:

  Sparse_Table(const Sparse_Table&) noexcept;
  Sparse_Table& operator=(const Sparse_Table&) noexcept;
  Sparse_Table() noexcept {
  }

  virtual ~Sparse_Table() noexcept;
  table2 table;

  void __set_table(const table2& val);

  bool operator == (const Sparse_Table & rhs) const
  {
    if (!(table == rhs.table))
      return false;
    return true;
  }
  bool operator != (const Sparse_Table &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Sparse_Table & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Sparse_Table &a, Sparse_Table &b);

std::ostream& operator<<(std::ostream& out, const Sparse_Table& obj);

typedef struct _Drover__isset {
  _Drover__isset() : contour_data(false), image_data(false), point_data(false), smesh_data(false), rtplan_data(false), lsamp_data(false), trans_data(false), table_data(false) {}
  bool contour_data :1;
  bool image_data :1;
  bool point_data :1;
  bool smesh_data :1;
  bool rtplan_data :1;
  bool lsamp_data :1;
  bool trans_data :1;
  bool table_data :1;
} _Drover__isset;

class Drover : public virtual ::apache::thrift::TBase {
 public:

  Drover(const Drover&);
  Drover& operator=(const Drover&);
  Drover() noexcept {
  }

  virtual ~Drover() noexcept;
  std::vector<Contour_Data>  contour_data;
  std::vector<Image_Array>  image_data;
  std::vector<Point_Cloud>  point_data;
  std::vector<Surface_Mesh>  smesh_data;
  std::vector<RTPlan>  rtplan_data;
  std::vector<Line_Sample>  lsamp_data;
  std::vector<Transform3>  trans_data;
  std::vector<Sparse_Table>  table_data;

  _Drover__isset __isset;

  void __set_contour_data(const std::vector<Contour_Data> & val);

  void __set_image_data(const std::vector<Image_Array> & val);

  void __set_point_data(const std::vector<Point_Cloud> & val);

  void __set_smesh_data(const std::vector<Surface_Mesh> & val);

  void __set_rtplan_data(const std::vector<RTPlan> & val);

  void __set_lsamp_data(const std::vector<Line_Sample> & val);

  void __set_trans_data(const std::vector<Transform3> & val);

  void __set_table_data(const std::vector<Sparse_Table> & val);

  bool operator == (const Drover & rhs) const
  {
    if (__isset.contour_data != rhs.__isset.contour_data)
      return false;
    else if (__isset.contour_data && !(contour_data == rhs.contour_data))
      return false;
    if (__isset.image_data != rhs.__isset.image_data)
      return false;
    else if (__isset.image_data && !(image_data == rhs.image_data))
      return false;
    if (__isset.point_data != rhs.__isset.point_data)
      return false;
    else if (__isset.point_data && !(point_data == rhs.point_data))
      return false;
    if (__isset.smesh_data != rhs.__isset.smesh_data)
      return false;
    else if (__isset.smesh_data && !(smesh_data == rhs.smesh_data))
      return false;
    if (__isset.rtplan_data != rhs.__isset.rtplan_data)
      return false;
    else if (__isset.rtplan_data && !(rtplan_data == rhs.rtplan_data))
      return false;
    if (__isset.lsamp_data != rhs.__isset.lsamp_data)
      return false;
    else if (__isset.lsamp_data && !(lsamp_data == rhs.lsamp_data))
      return false;
    if (__isset.trans_data != rhs.__isset.trans_data)
      return false;
    else if (__isset.trans_data && !(trans_data == rhs.trans_data))
      return false;
    if (__isset.table_data != rhs.__isset.table_data)
      return false;
    else if (__isset.table_data && !(table_data == rhs.table_data))
      return false;
    return true;
  }
  bool operator != (const Drover &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Drover & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Drover &a, Drover &b);

std::ostream& operator<<(std::ostream& out, const Drover& obj);


class OperationsQuery : public virtual ::apache::thrift::TBase {
 public:

  OperationsQuery(const OperationsQuery&) noexcept;
  OperationsQuery& operator=(const OperationsQuery&) noexcept;
  OperationsQuery() noexcept {
  }

  virtual ~OperationsQuery() noexcept;

  bool operator == (const OperationsQuery & /* rhs */) const
  {
    return true;
  }
  bool operator != (const OperationsQuery &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OperationsQuery & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(OperationsQuery &a, OperationsQuery &b);

std::ostream& operator<<(std::ostream& out, const OperationsQuery& obj);


class KnownOperation : public virtual ::apache::thrift::TBase {
 public:

  KnownOperation(const KnownOperation&);
  KnownOperation& operator=(const KnownOperation&);
  KnownOperation() noexcept
                 : name() {
  }

  virtual ~KnownOperation() noexcept;
  std::string name;

  void __set_name(const std::string& val);

  bool operator == (const KnownOperation & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const KnownOperation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KnownOperation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(KnownOperation &a, KnownOperation &b);

std::ostream& operator<<(std::ostream& out, const KnownOperation& obj);


class LoadFilesQuery : public virtual ::apache::thrift::TBase {
 public:

  LoadFilesQuery(const LoadFilesQuery&);
  LoadFilesQuery& operator=(const LoadFilesQuery&);
  LoadFilesQuery() noexcept
                 : server_filename() {
  }

  virtual ~LoadFilesQuery() noexcept;
  std::string server_filename;

  void __set_server_filename(const std::string& val);

  bool operator == (const LoadFilesQuery & rhs) const
  {
    if (!(server_filename == rhs.server_filename))
      return false;
    return true;
  }
  bool operator != (const LoadFilesQuery &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LoadFilesQuery & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(LoadFilesQuery &a, LoadFilesQuery &b);

std::ostream& operator<<(std::ostream& out, const LoadFilesQuery& obj);

typedef struct _LoadFilesResponse__isset {
  _LoadFilesResponse__isset() : drover(false) {}
  bool drover :1;
} _LoadFilesResponse__isset;

class LoadFilesResponse : public virtual ::apache::thrift::TBase {
 public:

  LoadFilesResponse(const LoadFilesResponse&);
  LoadFilesResponse& operator=(const LoadFilesResponse&);
  LoadFilesResponse() noexcept
                    : success(0) {
  }

  virtual ~LoadFilesResponse() noexcept;
  bool success;
  Drover drover;

  _LoadFilesResponse__isset __isset;

  void __set_success(const bool val);

  void __set_drover(const Drover& val);

  bool operator == (const LoadFilesResponse & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (__isset.drover != rhs.__isset.drover)
      return false;
    else if (__isset.drover && !(drover == rhs.drover))
      return false;
    return true;
  }
  bool operator != (const LoadFilesResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LoadFilesResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(LoadFilesResponse &a, LoadFilesResponse &b);

std::ostream& operator<<(std::ostream& out, const LoadFilesResponse& obj);


class ExecuteScriptQuery : public virtual ::apache::thrift::TBase {
 public:

  ExecuteScriptQuery(const ExecuteScriptQuery&);
  ExecuteScriptQuery& operator=(const ExecuteScriptQuery&);
  ExecuteScriptQuery() noexcept
                     : filename_lex() {
  }

  virtual ~ExecuteScriptQuery() noexcept;
  Drover drover;
  metadata_t invocation_metadata;
  std::string filename_lex;

  void __set_drover(const Drover& val);

  void __set_invocation_metadata(const metadata_t& val);

  void __set_filename_lex(const std::string& val);

  bool operator == (const ExecuteScriptQuery & rhs) const
  {
    if (!(drover == rhs.drover))
      return false;
    if (!(invocation_metadata == rhs.invocation_metadata))
      return false;
    if (!(filename_lex == rhs.filename_lex))
      return false;
    return true;
  }
  bool operator != (const ExecuteScriptQuery &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ExecuteScriptQuery & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ExecuteScriptQuery &a, ExecuteScriptQuery &b);

std::ostream& operator<<(std::ostream& out, const ExecuteScriptQuery& obj);

typedef struct _ExecuteScriptResponse__isset {
  _ExecuteScriptResponse__isset() : drover(false), invocation_metadata(false), filename_lex(false) {}
  bool drover :1;
  bool invocation_metadata :1;
  bool filename_lex :1;
} _ExecuteScriptResponse__isset;

class ExecuteScriptResponse : public virtual ::apache::thrift::TBase {
 public:

  ExecuteScriptResponse(const ExecuteScriptResponse&);
  ExecuteScriptResponse& operator=(const ExecuteScriptResponse&);
  ExecuteScriptResponse() noexcept
                        : success(0),
                          filename_lex() {
  }

  virtual ~ExecuteScriptResponse() noexcept;
  bool success;
  Drover drover;
  metadata_t invocation_metadata;
  std::string filename_lex;

  _ExecuteScriptResponse__isset __isset;

  void __set_success(const bool val);

  void __set_drover(const Drover& val);

  void __set_invocation_metadata(const metadata_t& val);

  void __set_filename_lex(const std::string& val);

  bool operator == (const ExecuteScriptResponse & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (__isset.drover != rhs.__isset.drover)
      return false;
    else if (__isset.drover && !(drover == rhs.drover))
      return false;
    if (__isset.invocation_metadata != rhs.__isset.invocation_metadata)
      return false;
    else if (__isset.invocation_metadata && !(invocation_metadata == rhs.invocation_metadata))
      return false;
    if (__isset.filename_lex != rhs.__isset.filename_lex)
      return false;
    else if (__isset.filename_lex && !(filename_lex == rhs.filename_lex))
      return false;
    return true;
  }
  bool operator != (const ExecuteScriptResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ExecuteScriptResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ExecuteScriptResponse &a, ExecuteScriptResponse &b);

std::ostream& operator<<(std::ostream& out, const ExecuteScriptResponse& obj);

}} // namespace

#endif
