#
# Autogenerated by Thrift Compiler (0.17.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class vec3_double(object):
    """
    Attributes:
     - x
     - y
     - z

    """


    def __init__(self, x=None, y=None, z=None,):
        self.x = x
        self.y = y
        self.z = z

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('vec3_double')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.x is None:
            raise TProtocolException(message='Required field x is unset!')
        if self.y is None:
            raise TProtocolException(message='Required field y is unset!')
        if self.z is None:
            raise TProtocolException(message='Required field z is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class contour_of_points_double(object):
    """
    Attributes:
     - points
     - closed
     - metadata

    """


    def __init__(self, points=None, closed=None, metadata=None,):
        self.points = points
        self.closed = closed
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.points = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = vec3_double()
                        _elem5.read(iprot)
                        self.points.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.closed = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype7, _vtype8, _size6) = iprot.readMapBegin()
                    for _i10 in range(_size6):
                        _key11 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val12 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.metadata[_key11] = _val12
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('contour_of_points_double')
        if self.points is not None:
            oprot.writeFieldBegin('points', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.points))
            for iter13 in self.points:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.closed is not None:
            oprot.writeFieldBegin('closed', TType.BOOL, 2)
            oprot.writeBool(self.closed)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter14, viter15 in self.metadata.items():
                oprot.writeString(kiter14.encode('utf-8') if sys.version_info[0] == 2 else kiter14)
                oprot.writeString(viter15.encode('utf-8') if sys.version_info[0] == 2 else viter15)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.points is None:
            raise TProtocolException(message='Required field points is unset!')
        if self.closed is None:
            raise TProtocolException(message='Required field closed is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class contour_collection_double(object):
    """
    Attributes:
     - contours

    """


    def __init__(self, contours=None,):
        self.contours = contours

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.contours = []
                    (_etype19, _size16) = iprot.readListBegin()
                    for _i20 in range(_size16):
                        _elem21 = contour_of_points_double()
                        _elem21.read(iprot)
                        self.contours.append(_elem21)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('contour_collection_double')
        if self.contours is not None:
            oprot.writeFieldBegin('contours', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.contours))
            for iter22 in self.contours:
                iter22.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.contours is None:
            raise TProtocolException(message='Required field contours is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class point_set_double(object):
    """
    Attributes:
     - points
     - normals
     - colours
     - metadata

    """


    def __init__(self, points=None, normals=None, colours=None, metadata=None,):
        self.points = points
        self.normals = normals
        self.colours = colours
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.points = []
                    (_etype26, _size23) = iprot.readListBegin()
                    for _i27 in range(_size23):
                        _elem28 = vec3_double()
                        _elem28.read(iprot)
                        self.points.append(_elem28)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.normals = []
                    (_etype32, _size29) = iprot.readListBegin()
                    for _i33 in range(_size29):
                        _elem34 = vec3_double()
                        _elem34.read(iprot)
                        self.normals.append(_elem34)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.colours = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readI64()
                        self.colours.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype42, _vtype43, _size41) = iprot.readMapBegin()
                    for _i45 in range(_size41):
                        _key46 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val47 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.metadata[_key46] = _val47
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('point_set_double')
        if self.points is not None:
            oprot.writeFieldBegin('points', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.points))
            for iter48 in self.points:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.normals is not None:
            oprot.writeFieldBegin('normals', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.normals))
            for iter49 in self.normals:
                iter49.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.colours is not None:
            oprot.writeFieldBegin('colours', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.colours))
            for iter50 in self.colours:
                oprot.writeI64(iter50)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter51, viter52 in self.metadata.items():
                oprot.writeString(kiter51.encode('utf-8') if sys.version_info[0] == 2 else kiter51)
                oprot.writeString(viter52.encode('utf-8') if sys.version_info[0] == 2 else viter52)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.points is None:
            raise TProtocolException(message='Required field points is unset!')
        if self.normals is None:
            raise TProtocolException(message='Required field normals is unset!')
        if self.colours is None:
            raise TProtocolException(message='Required field colours is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class sample4_double(object):
    """
    Attributes:
     - x
     - sigma_x
     - f
     - sigma_f

    """


    def __init__(self, x=None, sigma_x=None, f=None, sigma_f=None,):
        self.x = x
        self.sigma_x = sigma_x
        self.f = f
        self.sigma_f = sigma_f

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.sigma_x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.f = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.sigma_f = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sample4_double')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.sigma_x is not None:
            oprot.writeFieldBegin('sigma_x', TType.DOUBLE, 2)
            oprot.writeDouble(self.sigma_x)
            oprot.writeFieldEnd()
        if self.f is not None:
            oprot.writeFieldBegin('f', TType.DOUBLE, 3)
            oprot.writeDouble(self.f)
            oprot.writeFieldEnd()
        if self.sigma_f is not None:
            oprot.writeFieldBegin('sigma_f', TType.DOUBLE, 4)
            oprot.writeDouble(self.sigma_f)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.x is None:
            raise TProtocolException(message='Required field x is unset!')
        if self.sigma_x is None:
            raise TProtocolException(message='Required field sigma_x is unset!')
        if self.f is None:
            raise TProtocolException(message='Required field f is unset!')
        if self.sigma_f is None:
            raise TProtocolException(message='Required field sigma_f is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class samples_1D_double(object):
    """
    Attributes:
     - samples
     - uncertainties_known_to_be_independent_and_random
     - metadata

    """


    def __init__(self, samples=None, uncertainties_known_to_be_independent_and_random=None, metadata=None,):
        self.samples = samples
        self.uncertainties_known_to_be_independent_and_random = uncertainties_known_to_be_independent_and_random
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.samples = []
                    (_etype56, _size53) = iprot.readListBegin()
                    for _i57 in range(_size53):
                        _elem58 = sample4_double()
                        _elem58.read(iprot)
                        self.samples.append(_elem58)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.uncertainties_known_to_be_independent_and_random = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype60, _vtype61, _size59) = iprot.readMapBegin()
                    for _i63 in range(_size59):
                        _key64 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val65 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.metadata[_key64] = _val65
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('samples_1D_double')
        if self.samples is not None:
            oprot.writeFieldBegin('samples', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.samples))
            for iter66 in self.samples:
                iter66.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.uncertainties_known_to_be_independent_and_random is not None:
            oprot.writeFieldBegin('uncertainties_known_to_be_independent_and_random', TType.BOOL, 2)
            oprot.writeBool(self.uncertainties_known_to_be_independent_and_random)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter67, viter68 in self.metadata.items():
                oprot.writeString(kiter67.encode('utf-8') if sys.version_info[0] == 2 else kiter67)
                oprot.writeString(viter68.encode('utf-8') if sys.version_info[0] == 2 else viter68)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.samples is None:
            raise TProtocolException(message='Required field samples is unset!')
        if self.uncertainties_known_to_be_independent_and_random is None:
            raise TProtocolException(message='Required field uncertainties_known_to_be_independent_and_random is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class fv_surface_mesh_double_int64(object):
    """
    Attributes:
     - vertices
     - vertex_normals
     - vertex_colours
     - faces
     - involved_faces
     - metadata

    """


    def __init__(self, vertices=None, vertex_normals=None, vertex_colours=None, faces=None, involved_faces=None, metadata=None,):
        self.vertices = vertices
        self.vertex_normals = vertex_normals
        self.vertex_colours = vertex_colours
        self.faces = faces
        self.involved_faces = involved_faces
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.vertices = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = vec3_double()
                        _elem74.read(iprot)
                        self.vertices.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.vertex_normals = []
                    (_etype78, _size75) = iprot.readListBegin()
                    for _i79 in range(_size75):
                        _elem80 = vec3_double()
                        _elem80.read(iprot)
                        self.vertex_normals.append(_elem80)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.vertex_colours = []
                    (_etype84, _size81) = iprot.readListBegin()
                    for _i85 in range(_size81):
                        _elem86 = iprot.readI64()
                        self.vertex_colours.append(_elem86)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.faces = []
                    (_etype90, _size87) = iprot.readListBegin()
                    for _i91 in range(_size87):
                        _elem92 = []
                        (_etype96, _size93) = iprot.readListBegin()
                        for _i97 in range(_size93):
                            _elem98 = iprot.readI64()
                            _elem92.append(_elem98)
                        iprot.readListEnd()
                        self.faces.append(_elem92)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.involved_faces = []
                    (_etype102, _size99) = iprot.readListBegin()
                    for _i103 in range(_size99):
                        _elem104 = []
                        (_etype108, _size105) = iprot.readListBegin()
                        for _i109 in range(_size105):
                            _elem110 = iprot.readI64()
                            _elem104.append(_elem110)
                        iprot.readListEnd()
                        self.involved_faces.append(_elem104)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype112, _vtype113, _size111) = iprot.readMapBegin()
                    for _i115 in range(_size111):
                        _key116 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val117 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.metadata[_key116] = _val117
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fv_surface_mesh_double_int64')
        if self.vertices is not None:
            oprot.writeFieldBegin('vertices', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.vertices))
            for iter118 in self.vertices:
                iter118.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vertex_normals is not None:
            oprot.writeFieldBegin('vertex_normals', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.vertex_normals))
            for iter119 in self.vertex_normals:
                iter119.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.vertex_colours is not None:
            oprot.writeFieldBegin('vertex_colours', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.vertex_colours))
            for iter120 in self.vertex_colours:
                oprot.writeI64(iter120)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.faces is not None:
            oprot.writeFieldBegin('faces', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.faces))
            for iter121 in self.faces:
                oprot.writeListBegin(TType.I64, len(iter121))
                for iter122 in iter121:
                    oprot.writeI64(iter122)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.involved_faces is not None:
            oprot.writeFieldBegin('involved_faces', TType.LIST, 5)
            oprot.writeListBegin(TType.LIST, len(self.involved_faces))
            for iter123 in self.involved_faces:
                oprot.writeListBegin(TType.I64, len(iter123))
                for iter124 in iter123:
                    oprot.writeI64(iter124)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter125, viter126 in self.metadata.items():
                oprot.writeString(kiter125.encode('utf-8') if sys.version_info[0] == 2 else kiter125)
                oprot.writeString(viter126.encode('utf-8') if sys.version_info[0] == 2 else viter126)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.vertices is None:
            raise TProtocolException(message='Required field vertices is unset!')
        if self.vertex_normals is None:
            raise TProtocolException(message='Required field vertex_normals is unset!')
        if self.vertex_colours is None:
            raise TProtocolException(message='Required field vertex_colours is unset!')
        if self.faces is None:
            raise TProtocolException(message='Required field faces is unset!')
        if self.involved_faces is None:
            raise TProtocolException(message='Required field involved_faces is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class planar_image_double_double(object):
    """
    Attributes:
     - data
     - rows
     - columns
     - channels
     - pxl_dx
     - pxl_dy
     - pxl_dz
     - anchor
     - offset
     - row_unit
     - col_unit
     - metadata

    """


    def __init__(self, data=None, rows=None, columns=None, channels=None, pxl_dx=None, pxl_dy=None, pxl_dz=None, anchor=None, offset=None, row_unit=None, col_unit=None, metadata=None,):
        self.data = data
        self.rows = rows
        self.columns = columns
        self.channels = channels
        self.pxl_dx = pxl_dx
        self.pxl_dy = pxl_dy
        self.pxl_dz = pxl_dz
        self.anchor = anchor
        self.offset = offset
        self.row_unit = row_unit
        self.col_unit = col_unit
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype130, _size127) = iprot.readListBegin()
                    for _i131 in range(_size127):
                        _elem132 = iprot.readDouble()
                        self.data.append(_elem132)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.rows = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.columns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.channels = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.pxl_dx = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.pxl_dy = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.pxl_dz = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.anchor = vec3_double()
                    self.anchor.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.offset = vec3_double()
                    self.offset.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.row_unit = vec3_double()
                    self.row_unit.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.col_unit = vec3_double()
                    self.col_unit.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype134, _vtype135, _size133) = iprot.readMapBegin()
                    for _i137 in range(_size133):
                        _key138 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val139 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.metadata[_key138] = _val139
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('planar_image_double_double')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.data))
            for iter140 in self.data:
                oprot.writeDouble(iter140)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rows is not None:
            oprot.writeFieldBegin('rows', TType.I64, 2)
            oprot.writeI64(self.rows)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.I64, 3)
            oprot.writeI64(self.columns)
            oprot.writeFieldEnd()
        if self.channels is not None:
            oprot.writeFieldBegin('channels', TType.I64, 4)
            oprot.writeI64(self.channels)
            oprot.writeFieldEnd()
        if self.pxl_dx is not None:
            oprot.writeFieldBegin('pxl_dx', TType.DOUBLE, 5)
            oprot.writeDouble(self.pxl_dx)
            oprot.writeFieldEnd()
        if self.pxl_dy is not None:
            oprot.writeFieldBegin('pxl_dy', TType.DOUBLE, 6)
            oprot.writeDouble(self.pxl_dy)
            oprot.writeFieldEnd()
        if self.pxl_dz is not None:
            oprot.writeFieldBegin('pxl_dz', TType.DOUBLE, 7)
            oprot.writeDouble(self.pxl_dz)
            oprot.writeFieldEnd()
        if self.anchor is not None:
            oprot.writeFieldBegin('anchor', TType.STRUCT, 8)
            self.anchor.write(oprot)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.STRUCT, 9)
            self.offset.write(oprot)
            oprot.writeFieldEnd()
        if self.row_unit is not None:
            oprot.writeFieldBegin('row_unit', TType.STRUCT, 10)
            self.row_unit.write(oprot)
            oprot.writeFieldEnd()
        if self.col_unit is not None:
            oprot.writeFieldBegin('col_unit', TType.STRUCT, 11)
            self.col_unit.write(oprot)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 12)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter141, viter142 in self.metadata.items():
                oprot.writeString(kiter141.encode('utf-8') if sys.version_info[0] == 2 else kiter141)
                oprot.writeString(viter142.encode('utf-8') if sys.version_info[0] == 2 else viter142)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.data is None:
            raise TProtocolException(message='Required field data is unset!')
        if self.rows is None:
            raise TProtocolException(message='Required field rows is unset!')
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        if self.channels is None:
            raise TProtocolException(message='Required field channels is unset!')
        if self.pxl_dx is None:
            raise TProtocolException(message='Required field pxl_dx is unset!')
        if self.pxl_dy is None:
            raise TProtocolException(message='Required field pxl_dy is unset!')
        if self.pxl_dz is None:
            raise TProtocolException(message='Required field pxl_dz is unset!')
        if self.anchor is None:
            raise TProtocolException(message='Required field anchor is unset!')
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.row_unit is None:
            raise TProtocolException(message='Required field row_unit is unset!')
        if self.col_unit is None:
            raise TProtocolException(message='Required field col_unit is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class planar_image_collection_double_double(object):
    """
    Attributes:
     - images

    """


    def __init__(self, images=None,):
        self.images = images

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.images = []
                    (_etype146, _size143) = iprot.readListBegin()
                    for _i147 in range(_size143):
                        _elem148 = planar_image_double_double()
                        _elem148.read(iprot)
                        self.images.append(_elem148)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('planar_image_collection_double_double')
        if self.images is not None:
            oprot.writeFieldBegin('images', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.images))
            for iter149 in self.images:
                iter149.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.images is None:
            raise TProtocolException(message='Required field images is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class cell_string(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cell_string')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class table2(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('table2')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Contour_Data(object):
    """
    Attributes:
     - ccs

    """


    def __init__(self, ccs=None,):
        self.ccs = ccs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.ccs = []
                    (_etype153, _size150) = iprot.readListBegin()
                    for _i154 in range(_size150):
                        _elem155 = contour_collection_double()
                        _elem155.read(iprot)
                        self.ccs.append(_elem155)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Contour_Data')
        if self.ccs is not None:
            oprot.writeFieldBegin('ccs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.ccs))
            for iter156 in self.ccs:
                iter156.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ccs is None:
            raise TProtocolException(message='Required field ccs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Image_Array(object):
    """
    Attributes:
     - imagecoll
     - filename

    """


    def __init__(self, imagecoll=None, filename=None,):
        self.imagecoll = imagecoll
        self.filename = filename

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.imagecoll = planar_image_collection_double_double()
                    self.imagecoll.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Image_Array')
        if self.imagecoll is not None:
            oprot.writeFieldBegin('imagecoll', TType.STRUCT, 1)
            self.imagecoll.write(oprot)
            oprot.writeFieldEnd()
        if self.filename is not None:
            oprot.writeFieldBegin('filename', TType.STRING, 2)
            oprot.writeString(self.filename.encode('utf-8') if sys.version_info[0] == 2 else self.filename)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.imagecoll is None:
            raise TProtocolException(message='Required field imagecoll is unset!')
        if self.filename is None:
            raise TProtocolException(message='Required field filename is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Point_Cloud(object):
    """
    Attributes:
     - pset

    """


    def __init__(self, pset=None,):
        self.pset = pset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.pset = point_set_double()
                    self.pset.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Point_Cloud')
        if self.pset is not None:
            oprot.writeFieldBegin('pset', TType.STRUCT, 1)
            self.pset.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pset is None:
            raise TProtocolException(message='Required field pset is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Surface_Mesh(object):
    """
    Attributes:
     - meshes

    """


    def __init__(self, meshes=None,):
        self.meshes = meshes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.meshes = fv_surface_mesh_double_int64()
                    self.meshes.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Surface_Mesh')
        if self.meshes is not None:
            oprot.writeFieldBegin('meshes', TType.STRUCT, 1)
            self.meshes.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.meshes is None:
            raise TProtocolException(message='Required field meshes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Static_Machine_State(object):
    """
    Attributes:
     - CumulativeMetersetWeight
     - ControlPointIndex
     - GantryAngle
     - GantryRotationDirection
     - BeamLimitingDeviceAngle
     - BeamLimitingDeviceRotationDirection
     - PatientSupportAngle
     - PatientSupportRotationDirection
     - TableTopEccentricAngle
     - TableTopEccentricRotationDirection
     - TableTopVerticalPosition
     - TableTopLongitudinalPosition
     - TableTopLateralPosition
     - TableTopPitchAngle
     - TableTopPitchRotationDirection
     - TableTopRollAngle
     - TableTopRollRotationDirection
     - IsocentrePosition
     - JawPositionsX
     - JawPositionsY
     - MLCPositionsX
     - metadata

    """


    def __init__(self, CumulativeMetersetWeight=None, ControlPointIndex=None, GantryAngle=None, GantryRotationDirection=None, BeamLimitingDeviceAngle=None, BeamLimitingDeviceRotationDirection=None, PatientSupportAngle=None, PatientSupportRotationDirection=None, TableTopEccentricAngle=None, TableTopEccentricRotationDirection=None, TableTopVerticalPosition=None, TableTopLongitudinalPosition=None, TableTopLateralPosition=None, TableTopPitchAngle=None, TableTopPitchRotationDirection=None, TableTopRollAngle=None, TableTopRollRotationDirection=None, IsocentrePosition=None, JawPositionsX=None, JawPositionsY=None, MLCPositionsX=None, metadata=None,):
        self.CumulativeMetersetWeight = CumulativeMetersetWeight
        self.ControlPointIndex = ControlPointIndex
        self.GantryAngle = GantryAngle
        self.GantryRotationDirection = GantryRotationDirection
        self.BeamLimitingDeviceAngle = BeamLimitingDeviceAngle
        self.BeamLimitingDeviceRotationDirection = BeamLimitingDeviceRotationDirection
        self.PatientSupportAngle = PatientSupportAngle
        self.PatientSupportRotationDirection = PatientSupportRotationDirection
        self.TableTopEccentricAngle = TableTopEccentricAngle
        self.TableTopEccentricRotationDirection = TableTopEccentricRotationDirection
        self.TableTopVerticalPosition = TableTopVerticalPosition
        self.TableTopLongitudinalPosition = TableTopLongitudinalPosition
        self.TableTopLateralPosition = TableTopLateralPosition
        self.TableTopPitchAngle = TableTopPitchAngle
        self.TableTopPitchRotationDirection = TableTopPitchRotationDirection
        self.TableTopRollAngle = TableTopRollAngle
        self.TableTopRollRotationDirection = TableTopRollRotationDirection
        self.IsocentrePosition = IsocentrePosition
        self.JawPositionsX = JawPositionsX
        self.JawPositionsY = JawPositionsY
        self.MLCPositionsX = MLCPositionsX
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.CumulativeMetersetWeight = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ControlPointIndex = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.GantryAngle = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.GantryRotationDirection = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.BeamLimitingDeviceAngle = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.BeamLimitingDeviceRotationDirection = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.PatientSupportAngle = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.PatientSupportRotationDirection = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.TableTopEccentricAngle = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.TableTopEccentricRotationDirection = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.TableTopVerticalPosition = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.DOUBLE:
                    self.TableTopLongitudinalPosition = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.DOUBLE:
                    self.TableTopLateralPosition = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.DOUBLE:
                    self.TableTopPitchAngle = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.DOUBLE:
                    self.TableTopPitchRotationDirection = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.DOUBLE:
                    self.TableTopRollAngle = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.DOUBLE:
                    self.TableTopRollRotationDirection = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.IsocentrePosition = vec3_double()
                    self.IsocentrePosition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.LIST:
                    self.JawPositionsX = []
                    (_etype160, _size157) = iprot.readListBegin()
                    for _i161 in range(_size157):
                        _elem162 = iprot.readDouble()
                        self.JawPositionsX.append(_elem162)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.LIST:
                    self.JawPositionsY = []
                    (_etype166, _size163) = iprot.readListBegin()
                    for _i167 in range(_size163):
                        _elem168 = iprot.readDouble()
                        self.JawPositionsY.append(_elem168)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.LIST:
                    self.MLCPositionsX = []
                    (_etype172, _size169) = iprot.readListBegin()
                    for _i173 in range(_size169):
                        _elem174 = iprot.readDouble()
                        self.MLCPositionsX.append(_elem174)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype176, _vtype177, _size175) = iprot.readMapBegin()
                    for _i179 in range(_size175):
                        _key180 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val181 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.metadata[_key180] = _val181
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Static_Machine_State')
        if self.CumulativeMetersetWeight is not None:
            oprot.writeFieldBegin('CumulativeMetersetWeight', TType.DOUBLE, 1)
            oprot.writeDouble(self.CumulativeMetersetWeight)
            oprot.writeFieldEnd()
        if self.ControlPointIndex is not None:
            oprot.writeFieldBegin('ControlPointIndex', TType.I64, 2)
            oprot.writeI64(self.ControlPointIndex)
            oprot.writeFieldEnd()
        if self.GantryAngle is not None:
            oprot.writeFieldBegin('GantryAngle', TType.DOUBLE, 3)
            oprot.writeDouble(self.GantryAngle)
            oprot.writeFieldEnd()
        if self.GantryRotationDirection is not None:
            oprot.writeFieldBegin('GantryRotationDirection', TType.DOUBLE, 4)
            oprot.writeDouble(self.GantryRotationDirection)
            oprot.writeFieldEnd()
        if self.BeamLimitingDeviceAngle is not None:
            oprot.writeFieldBegin('BeamLimitingDeviceAngle', TType.DOUBLE, 5)
            oprot.writeDouble(self.BeamLimitingDeviceAngle)
            oprot.writeFieldEnd()
        if self.BeamLimitingDeviceRotationDirection is not None:
            oprot.writeFieldBegin('BeamLimitingDeviceRotationDirection', TType.DOUBLE, 6)
            oprot.writeDouble(self.BeamLimitingDeviceRotationDirection)
            oprot.writeFieldEnd()
        if self.PatientSupportAngle is not None:
            oprot.writeFieldBegin('PatientSupportAngle', TType.DOUBLE, 7)
            oprot.writeDouble(self.PatientSupportAngle)
            oprot.writeFieldEnd()
        if self.PatientSupportRotationDirection is not None:
            oprot.writeFieldBegin('PatientSupportRotationDirection', TType.DOUBLE, 8)
            oprot.writeDouble(self.PatientSupportRotationDirection)
            oprot.writeFieldEnd()
        if self.TableTopEccentricAngle is not None:
            oprot.writeFieldBegin('TableTopEccentricAngle', TType.DOUBLE, 9)
            oprot.writeDouble(self.TableTopEccentricAngle)
            oprot.writeFieldEnd()
        if self.TableTopEccentricRotationDirection is not None:
            oprot.writeFieldBegin('TableTopEccentricRotationDirection', TType.DOUBLE, 10)
            oprot.writeDouble(self.TableTopEccentricRotationDirection)
            oprot.writeFieldEnd()
        if self.TableTopVerticalPosition is not None:
            oprot.writeFieldBegin('TableTopVerticalPosition', TType.DOUBLE, 11)
            oprot.writeDouble(self.TableTopVerticalPosition)
            oprot.writeFieldEnd()
        if self.TableTopLongitudinalPosition is not None:
            oprot.writeFieldBegin('TableTopLongitudinalPosition', TType.DOUBLE, 12)
            oprot.writeDouble(self.TableTopLongitudinalPosition)
            oprot.writeFieldEnd()
        if self.TableTopLateralPosition is not None:
            oprot.writeFieldBegin('TableTopLateralPosition', TType.DOUBLE, 13)
            oprot.writeDouble(self.TableTopLateralPosition)
            oprot.writeFieldEnd()
        if self.TableTopPitchAngle is not None:
            oprot.writeFieldBegin('TableTopPitchAngle', TType.DOUBLE, 14)
            oprot.writeDouble(self.TableTopPitchAngle)
            oprot.writeFieldEnd()
        if self.TableTopPitchRotationDirection is not None:
            oprot.writeFieldBegin('TableTopPitchRotationDirection', TType.DOUBLE, 15)
            oprot.writeDouble(self.TableTopPitchRotationDirection)
            oprot.writeFieldEnd()
        if self.TableTopRollAngle is not None:
            oprot.writeFieldBegin('TableTopRollAngle', TType.DOUBLE, 16)
            oprot.writeDouble(self.TableTopRollAngle)
            oprot.writeFieldEnd()
        if self.TableTopRollRotationDirection is not None:
            oprot.writeFieldBegin('TableTopRollRotationDirection', TType.DOUBLE, 17)
            oprot.writeDouble(self.TableTopRollRotationDirection)
            oprot.writeFieldEnd()
        if self.IsocentrePosition is not None:
            oprot.writeFieldBegin('IsocentrePosition', TType.STRUCT, 18)
            self.IsocentrePosition.write(oprot)
            oprot.writeFieldEnd()
        if self.JawPositionsX is not None:
            oprot.writeFieldBegin('JawPositionsX', TType.LIST, 19)
            oprot.writeListBegin(TType.DOUBLE, len(self.JawPositionsX))
            for iter182 in self.JawPositionsX:
                oprot.writeDouble(iter182)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.JawPositionsY is not None:
            oprot.writeFieldBegin('JawPositionsY', TType.LIST, 20)
            oprot.writeListBegin(TType.DOUBLE, len(self.JawPositionsY))
            for iter183 in self.JawPositionsY:
                oprot.writeDouble(iter183)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.MLCPositionsX is not None:
            oprot.writeFieldBegin('MLCPositionsX', TType.LIST, 21)
            oprot.writeListBegin(TType.DOUBLE, len(self.MLCPositionsX))
            for iter184 in self.MLCPositionsX:
                oprot.writeDouble(iter184)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 22)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter185, viter186 in self.metadata.items():
                oprot.writeString(kiter185.encode('utf-8') if sys.version_info[0] == 2 else kiter185)
                oprot.writeString(viter186.encode('utf-8') if sys.version_info[0] == 2 else viter186)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.CumulativeMetersetWeight is None:
            raise TProtocolException(message='Required field CumulativeMetersetWeight is unset!')
        if self.ControlPointIndex is None:
            raise TProtocolException(message='Required field ControlPointIndex is unset!')
        if self.GantryAngle is None:
            raise TProtocolException(message='Required field GantryAngle is unset!')
        if self.GantryRotationDirection is None:
            raise TProtocolException(message='Required field GantryRotationDirection is unset!')
        if self.BeamLimitingDeviceAngle is None:
            raise TProtocolException(message='Required field BeamLimitingDeviceAngle is unset!')
        if self.BeamLimitingDeviceRotationDirection is None:
            raise TProtocolException(message='Required field BeamLimitingDeviceRotationDirection is unset!')
        if self.PatientSupportAngle is None:
            raise TProtocolException(message='Required field PatientSupportAngle is unset!')
        if self.PatientSupportRotationDirection is None:
            raise TProtocolException(message='Required field PatientSupportRotationDirection is unset!')
        if self.TableTopEccentricAngle is None:
            raise TProtocolException(message='Required field TableTopEccentricAngle is unset!')
        if self.TableTopEccentricRotationDirection is None:
            raise TProtocolException(message='Required field TableTopEccentricRotationDirection is unset!')
        if self.TableTopVerticalPosition is None:
            raise TProtocolException(message='Required field TableTopVerticalPosition is unset!')
        if self.TableTopLongitudinalPosition is None:
            raise TProtocolException(message='Required field TableTopLongitudinalPosition is unset!')
        if self.TableTopLateralPosition is None:
            raise TProtocolException(message='Required field TableTopLateralPosition is unset!')
        if self.TableTopPitchAngle is None:
            raise TProtocolException(message='Required field TableTopPitchAngle is unset!')
        if self.TableTopPitchRotationDirection is None:
            raise TProtocolException(message='Required field TableTopPitchRotationDirection is unset!')
        if self.TableTopRollAngle is None:
            raise TProtocolException(message='Required field TableTopRollAngle is unset!')
        if self.TableTopRollRotationDirection is None:
            raise TProtocolException(message='Required field TableTopRollRotationDirection is unset!')
        if self.IsocentrePosition is None:
            raise TProtocolException(message='Required field IsocentrePosition is unset!')
        if self.JawPositionsX is None:
            raise TProtocolException(message='Required field JawPositionsX is unset!')
        if self.JawPositionsY is None:
            raise TProtocolException(message='Required field JawPositionsY is unset!')
        if self.MLCPositionsX is None:
            raise TProtocolException(message='Required field MLCPositionsX is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Dynamic_Machine_State(object):
    """
    Attributes:
     - BeamNumber
     - FinalCumulativeMetersetWeight
     - static_states
     - metadata

    """


    def __init__(self, BeamNumber=None, FinalCumulativeMetersetWeight=None, static_states=None, metadata=None,):
        self.BeamNumber = BeamNumber
        self.FinalCumulativeMetersetWeight = FinalCumulativeMetersetWeight
        self.static_states = static_states
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.BeamNumber = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.FinalCumulativeMetersetWeight = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.static_states = []
                    (_etype190, _size187) = iprot.readListBegin()
                    for _i191 in range(_size187):
                        _elem192 = Static_Machine_State()
                        _elem192.read(iprot)
                        self.static_states.append(_elem192)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype194, _vtype195, _size193) = iprot.readMapBegin()
                    for _i197 in range(_size193):
                        _key198 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val199 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.metadata[_key198] = _val199
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Dynamic_Machine_State')
        if self.BeamNumber is not None:
            oprot.writeFieldBegin('BeamNumber', TType.I64, 1)
            oprot.writeI64(self.BeamNumber)
            oprot.writeFieldEnd()
        if self.FinalCumulativeMetersetWeight is not None:
            oprot.writeFieldBegin('FinalCumulativeMetersetWeight', TType.DOUBLE, 2)
            oprot.writeDouble(self.FinalCumulativeMetersetWeight)
            oprot.writeFieldEnd()
        if self.static_states is not None:
            oprot.writeFieldBegin('static_states', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.static_states))
            for iter200 in self.static_states:
                iter200.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter201, viter202 in self.metadata.items():
                oprot.writeString(kiter201.encode('utf-8') if sys.version_info[0] == 2 else kiter201)
                oprot.writeString(viter202.encode('utf-8') if sys.version_info[0] == 2 else viter202)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.BeamNumber is None:
            raise TProtocolException(message='Required field BeamNumber is unset!')
        if self.FinalCumulativeMetersetWeight is None:
            raise TProtocolException(message='Required field FinalCumulativeMetersetWeight is unset!')
        if self.static_states is None:
            raise TProtocolException(message='Required field static_states is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RTPlan(object):
    """
    Attributes:
     - dynamic_states
     - metadata

    """


    def __init__(self, dynamic_states=None, metadata=None,):
        self.dynamic_states = dynamic_states
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dynamic_states = []
                    (_etype206, _size203) = iprot.readListBegin()
                    for _i207 in range(_size203):
                        _elem208 = Dynamic_Machine_State()
                        _elem208.read(iprot)
                        self.dynamic_states.append(_elem208)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype210, _vtype211, _size209) = iprot.readMapBegin()
                    for _i213 in range(_size209):
                        _key214 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val215 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.metadata[_key214] = _val215
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RTPlan')
        if self.dynamic_states is not None:
            oprot.writeFieldBegin('dynamic_states', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.dynamic_states))
            for iter216 in self.dynamic_states:
                iter216.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter217, viter218 in self.metadata.items():
                oprot.writeString(kiter217.encode('utf-8') if sys.version_info[0] == 2 else kiter217)
                oprot.writeString(viter218.encode('utf-8') if sys.version_info[0] == 2 else viter218)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dynamic_states is None:
            raise TProtocolException(message='Required field dynamic_states is unset!')
        if self.metadata is None:
            raise TProtocolException(message='Required field metadata is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Line_Sample(object):
    """
    Attributes:
     - line

    """


    def __init__(self, line=None,):
        self.line = line

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.line = samples_1D_double()
                    self.line.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Line_Sample')
        if self.line is not None:
            oprot.writeFieldBegin('line', TType.STRUCT, 1)
            self.line.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.line is None:
            raise TProtocolException(message='Required field line is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Transform3(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Transform3')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Sparse_Table(object):
    """
    Attributes:
     - table

    """


    def __init__(self, table=None,):
        self.table = table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table = table2()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Sparse_Table')
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 1)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table is None:
            raise TProtocolException(message='Required field table is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Drover(object):
    """
    Attributes:
     - contour_data
     - image_data
     - point_data
     - smesh_data
     - rtplan_data
     - lsamp_data
     - trans_data
     - table_data

    """


    def __init__(self, contour_data=None, image_data=None, point_data=None, smesh_data=None, rtplan_data=None, lsamp_data=None, trans_data=None, table_data=None,):
        self.contour_data = contour_data
        self.image_data = image_data
        self.point_data = point_data
        self.smesh_data = smesh_data
        self.rtplan_data = rtplan_data
        self.lsamp_data = lsamp_data
        self.trans_data = trans_data
        self.table_data = table_data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.contour_data = []
                    (_etype222, _size219) = iprot.readListBegin()
                    for _i223 in range(_size219):
                        _elem224 = Contour_Data()
                        _elem224.read(iprot)
                        self.contour_data.append(_elem224)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.image_data = []
                    (_etype228, _size225) = iprot.readListBegin()
                    for _i229 in range(_size225):
                        _elem230 = Image_Array()
                        _elem230.read(iprot)
                        self.image_data.append(_elem230)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.point_data = []
                    (_etype234, _size231) = iprot.readListBegin()
                    for _i235 in range(_size231):
                        _elem236 = Point_Cloud()
                        _elem236.read(iprot)
                        self.point_data.append(_elem236)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.smesh_data = []
                    (_etype240, _size237) = iprot.readListBegin()
                    for _i241 in range(_size237):
                        _elem242 = Surface_Mesh()
                        _elem242.read(iprot)
                        self.smesh_data.append(_elem242)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.rtplan_data = []
                    (_etype246, _size243) = iprot.readListBegin()
                    for _i247 in range(_size243):
                        _elem248 = RTPlan()
                        _elem248.read(iprot)
                        self.rtplan_data.append(_elem248)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.lsamp_data = []
                    (_etype252, _size249) = iprot.readListBegin()
                    for _i253 in range(_size249):
                        _elem254 = Line_Sample()
                        _elem254.read(iprot)
                        self.lsamp_data.append(_elem254)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.trans_data = []
                    (_etype258, _size255) = iprot.readListBegin()
                    for _i259 in range(_size255):
                        _elem260 = Transform3()
                        _elem260.read(iprot)
                        self.trans_data.append(_elem260)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.table_data = []
                    (_etype264, _size261) = iprot.readListBegin()
                    for _i265 in range(_size261):
                        _elem266 = Sparse_Table()
                        _elem266.read(iprot)
                        self.table_data.append(_elem266)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Drover')
        if self.contour_data is not None:
            oprot.writeFieldBegin('contour_data', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.contour_data))
            for iter267 in self.contour_data:
                iter267.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.image_data is not None:
            oprot.writeFieldBegin('image_data', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.image_data))
            for iter268 in self.image_data:
                iter268.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.point_data is not None:
            oprot.writeFieldBegin('point_data', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.point_data))
            for iter269 in self.point_data:
                iter269.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.smesh_data is not None:
            oprot.writeFieldBegin('smesh_data', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.smesh_data))
            for iter270 in self.smesh_data:
                iter270.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rtplan_data is not None:
            oprot.writeFieldBegin('rtplan_data', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.rtplan_data))
            for iter271 in self.rtplan_data:
                iter271.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lsamp_data is not None:
            oprot.writeFieldBegin('lsamp_data', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.lsamp_data))
            for iter272 in self.lsamp_data:
                iter272.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.trans_data is not None:
            oprot.writeFieldBegin('trans_data', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.trans_data))
            for iter273 in self.trans_data:
                iter273.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.table_data is not None:
            oprot.writeFieldBegin('table_data', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.table_data))
            for iter274 in self.table_data:
                iter274.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OperationsQuery(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('OperationsQuery')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class KnownOperation(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('KnownOperation')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadFilesQuery(object):
    """
    Attributes:
     - server_filename

    """


    def __init__(self, server_filename=None,):
        self.server_filename = server_filename

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.server_filename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadFilesQuery')
        if self.server_filename is not None:
            oprot.writeFieldBegin('server_filename', TType.STRING, 1)
            oprot.writeString(self.server_filename.encode('utf-8') if sys.version_info[0] == 2 else self.server_filename)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.server_filename is None:
            raise TProtocolException(message='Required field server_filename is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoadFilesResponse(object):
    """
    Attributes:
     - success
     - drover

    """


    def __init__(self, success=None, drover=None,):
        self.success = success
        self.drover = drover

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.drover = Drover()
                    self.drover.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadFilesResponse')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 1)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.drover is not None:
            oprot.writeFieldBegin('drover', TType.STRUCT, 2)
            self.drover.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.success is None:
            raise TProtocolException(message='Required field success is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecuteScriptQuery(object):
    """
    Attributes:
     - drover
     - invocation_metadata
     - filename_lex

    """


    def __init__(self, drover=None, invocation_metadata=None, filename_lex=None,):
        self.drover = drover
        self.invocation_metadata = invocation_metadata
        self.filename_lex = filename_lex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.drover = Drover()
                    self.drover.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.invocation_metadata = {}
                    (_ktype276, _vtype277, _size275) = iprot.readMapBegin()
                    for _i279 in range(_size275):
                        _key280 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val281 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.invocation_metadata[_key280] = _val281
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filename_lex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteScriptQuery')
        if self.drover is not None:
            oprot.writeFieldBegin('drover', TType.STRUCT, 1)
            self.drover.write(oprot)
            oprot.writeFieldEnd()
        if self.invocation_metadata is not None:
            oprot.writeFieldBegin('invocation_metadata', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.invocation_metadata))
            for kiter282, viter283 in self.invocation_metadata.items():
                oprot.writeString(kiter282.encode('utf-8') if sys.version_info[0] == 2 else kiter282)
                oprot.writeString(viter283.encode('utf-8') if sys.version_info[0] == 2 else viter283)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.filename_lex is not None:
            oprot.writeFieldBegin('filename_lex', TType.STRING, 3)
            oprot.writeString(self.filename_lex.encode('utf-8') if sys.version_info[0] == 2 else self.filename_lex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.drover is None:
            raise TProtocolException(message='Required field drover is unset!')
        if self.invocation_metadata is None:
            raise TProtocolException(message='Required field invocation_metadata is unset!')
        if self.filename_lex is None:
            raise TProtocolException(message='Required field filename_lex is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecuteScriptResponse(object):
    """
    Attributes:
     - success
     - drover
     - invocation_metadata
     - filename_lex

    """


    def __init__(self, success=None, drover=None, invocation_metadata=None, filename_lex=None,):
        self.success = success
        self.drover = drover
        self.invocation_metadata = invocation_metadata
        self.filename_lex = filename_lex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.drover = Drover()
                    self.drover.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.invocation_metadata = {}
                    (_ktype285, _vtype286, _size284) = iprot.readMapBegin()
                    for _i288 in range(_size284):
                        _key289 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val290 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.invocation_metadata[_key289] = _val290
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.filename_lex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteScriptResponse')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 1)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.drover is not None:
            oprot.writeFieldBegin('drover', TType.STRUCT, 2)
            self.drover.write(oprot)
            oprot.writeFieldEnd()
        if self.invocation_metadata is not None:
            oprot.writeFieldBegin('invocation_metadata', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.invocation_metadata))
            for kiter291, viter292 in self.invocation_metadata.items():
                oprot.writeString(kiter291.encode('utf-8') if sys.version_info[0] == 2 else kiter291)
                oprot.writeString(viter292.encode('utf-8') if sys.version_info[0] == 2 else viter292)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.filename_lex is not None:
            oprot.writeFieldBegin('filename_lex', TType.STRING, 4)
            oprot.writeString(self.filename_lex.encode('utf-8') if sys.version_info[0] == 2 else self.filename_lex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.success is None:
            raise TProtocolException(message='Required field success is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(vec3_double)
vec3_double.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, None, ),  # 3
)
all_structs.append(contour_of_points_double)
contour_of_points_double.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'points', (TType.STRUCT, [vec3_double, None], False), None, ),  # 1
    (2, TType.BOOL, 'closed', None, None, ),  # 2
    (3, TType.MAP, 'metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(contour_collection_double)
contour_collection_double.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'contours', (TType.STRUCT, [contour_of_points_double, None], False), None, ),  # 1
)
all_structs.append(point_set_double)
point_set_double.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'points', (TType.STRUCT, [vec3_double, None], False), None, ),  # 1
    (2, TType.LIST, 'normals', (TType.STRUCT, [vec3_double, None], False), None, ),  # 2
    (3, TType.LIST, 'colours', (TType.I64, None, False), None, ),  # 3
    (4, TType.MAP, 'metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(sample4_double)
sample4_double.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'sigma_x', None, None, ),  # 2
    (3, TType.DOUBLE, 'f', None, None, ),  # 3
    (4, TType.DOUBLE, 'sigma_f', None, None, ),  # 4
)
all_structs.append(samples_1D_double)
samples_1D_double.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'samples', (TType.STRUCT, [sample4_double, None], False), None, ),  # 1
    (2, TType.BOOL, 'uncertainties_known_to_be_independent_and_random', None, None, ),  # 2
    (3, TType.MAP, 'metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(fv_surface_mesh_double_int64)
fv_surface_mesh_double_int64.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'vertices', (TType.STRUCT, [vec3_double, None], False), None, ),  # 1
    (2, TType.LIST, 'vertex_normals', (TType.STRUCT, [vec3_double, None], False), None, ),  # 2
    (3, TType.LIST, 'vertex_colours', (TType.I64, None, False), None, ),  # 3
    (4, TType.LIST, 'faces', (TType.LIST, (TType.I64, None, False), False), None, ),  # 4
    (5, TType.LIST, 'involved_faces', (TType.LIST, (TType.I64, None, False), False), None, ),  # 5
    (6, TType.MAP, 'metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
)
all_structs.append(planar_image_double_double)
planar_image_double_double.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.I64, 'rows', None, None, ),  # 2
    (3, TType.I64, 'columns', None, None, ),  # 3
    (4, TType.I64, 'channels', None, None, ),  # 4
    (5, TType.DOUBLE, 'pxl_dx', None, None, ),  # 5
    (6, TType.DOUBLE, 'pxl_dy', None, None, ),  # 6
    (7, TType.DOUBLE, 'pxl_dz', None, None, ),  # 7
    (8, TType.STRUCT, 'anchor', [vec3_double, None], None, ),  # 8
    (9, TType.STRUCT, 'offset', [vec3_double, None], None, ),  # 9
    (10, TType.STRUCT, 'row_unit', [vec3_double, None], None, ),  # 10
    (11, TType.STRUCT, 'col_unit', [vec3_double, None], None, ),  # 11
    (12, TType.MAP, 'metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 12
)
all_structs.append(planar_image_collection_double_double)
planar_image_collection_double_double.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'images', (TType.STRUCT, [planar_image_double_double, None], False), None, ),  # 1
)
all_structs.append(cell_string)
cell_string.thrift_spec = (
)
all_structs.append(table2)
table2.thrift_spec = (
)
all_structs.append(Contour_Data)
Contour_Data.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'ccs', (TType.STRUCT, [contour_collection_double, None], False), None, ),  # 1
)
all_structs.append(Image_Array)
Image_Array.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'imagecoll', [planar_image_collection_double_double, None], None, ),  # 1
    (2, TType.STRING, 'filename', 'UTF8', None, ),  # 2
)
all_structs.append(Point_Cloud)
Point_Cloud.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'pset', [point_set_double, None], None, ),  # 1
)
all_structs.append(Surface_Mesh)
Surface_Mesh.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'meshes', [fv_surface_mesh_double_int64, None], None, ),  # 1
)
all_structs.append(Static_Machine_State)
Static_Machine_State.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'CumulativeMetersetWeight', None, None, ),  # 1
    (2, TType.I64, 'ControlPointIndex', None, None, ),  # 2
    (3, TType.DOUBLE, 'GantryAngle', None, None, ),  # 3
    (4, TType.DOUBLE, 'GantryRotationDirection', None, None, ),  # 4
    (5, TType.DOUBLE, 'BeamLimitingDeviceAngle', None, None, ),  # 5
    (6, TType.DOUBLE, 'BeamLimitingDeviceRotationDirection', None, None, ),  # 6
    (7, TType.DOUBLE, 'PatientSupportAngle', None, None, ),  # 7
    (8, TType.DOUBLE, 'PatientSupportRotationDirection', None, None, ),  # 8
    (9, TType.DOUBLE, 'TableTopEccentricAngle', None, None, ),  # 9
    (10, TType.DOUBLE, 'TableTopEccentricRotationDirection', None, None, ),  # 10
    (11, TType.DOUBLE, 'TableTopVerticalPosition', None, None, ),  # 11
    (12, TType.DOUBLE, 'TableTopLongitudinalPosition', None, None, ),  # 12
    (13, TType.DOUBLE, 'TableTopLateralPosition', None, None, ),  # 13
    (14, TType.DOUBLE, 'TableTopPitchAngle', None, None, ),  # 14
    (15, TType.DOUBLE, 'TableTopPitchRotationDirection', None, None, ),  # 15
    (16, TType.DOUBLE, 'TableTopRollAngle', None, None, ),  # 16
    (17, TType.DOUBLE, 'TableTopRollRotationDirection', None, None, ),  # 17
    (18, TType.STRUCT, 'IsocentrePosition', [vec3_double, None], None, ),  # 18
    (19, TType.LIST, 'JawPositionsX', (TType.DOUBLE, None, False), None, ),  # 19
    (20, TType.LIST, 'JawPositionsY', (TType.DOUBLE, None, False), None, ),  # 20
    (21, TType.LIST, 'MLCPositionsX', (TType.DOUBLE, None, False), None, ),  # 21
    (22, TType.MAP, 'metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 22
)
all_structs.append(Dynamic_Machine_State)
Dynamic_Machine_State.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'BeamNumber', None, None, ),  # 1
    (2, TType.DOUBLE, 'FinalCumulativeMetersetWeight', None, None, ),  # 2
    (3, TType.LIST, 'static_states', (TType.STRUCT, [Static_Machine_State, None], False), None, ),  # 3
    (4, TType.MAP, 'metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(RTPlan)
RTPlan.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dynamic_states', (TType.STRUCT, [Dynamic_Machine_State, None], False), None, ),  # 1
    (2, TType.MAP, 'metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(Line_Sample)
Line_Sample.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'line', [samples_1D_double, None], None, ),  # 1
)
all_structs.append(Transform3)
Transform3.thrift_spec = (
)
all_structs.append(Sparse_Table)
Sparse_Table.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table', [table2, None], None, ),  # 1
)
all_structs.append(Drover)
Drover.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'contour_data', (TType.STRUCT, [Contour_Data, None], False), None, ),  # 1
    (2, TType.LIST, 'image_data', (TType.STRUCT, [Image_Array, None], False), None, ),  # 2
    (3, TType.LIST, 'point_data', (TType.STRUCT, [Point_Cloud, None], False), None, ),  # 3
    (4, TType.LIST, 'smesh_data', (TType.STRUCT, [Surface_Mesh, None], False), None, ),  # 4
    (5, TType.LIST, 'rtplan_data', (TType.STRUCT, [RTPlan, None], False), None, ),  # 5
    (6, TType.LIST, 'lsamp_data', (TType.STRUCT, [Line_Sample, None], False), None, ),  # 6
    (7, TType.LIST, 'trans_data', (TType.STRUCT, [Transform3, None], False), None, ),  # 7
    (8, TType.LIST, 'table_data', (TType.STRUCT, [Sparse_Table, None], False), None, ),  # 8
)
all_structs.append(OperationsQuery)
OperationsQuery.thrift_spec = (
)
all_structs.append(KnownOperation)
KnownOperation.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)
all_structs.append(LoadFilesQuery)
LoadFilesQuery.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'server_filename', 'UTF8', None, ),  # 1
)
all_structs.append(LoadFilesResponse)
LoadFilesResponse.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'success', None, None, ),  # 1
    (2, TType.STRUCT, 'drover', [Drover, None], None, ),  # 2
)
all_structs.append(ExecuteScriptQuery)
ExecuteScriptQuery.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'drover', [Drover, None], None, ),  # 1
    (2, TType.MAP, 'invocation_metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'filename_lex', 'UTF8', None, ),  # 3
)
all_structs.append(ExecuteScriptResponse)
ExecuteScriptResponse.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'success', None, None, ),  # 1
    (2, TType.STRUCT, 'drover', [Drover, None], None, ),  # 2
    (3, TType.MAP, 'invocation_metadata', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'filename_lex', 'UTF8', None, ),  # 4
)
fix_spec(all_structs)
del all_structs
